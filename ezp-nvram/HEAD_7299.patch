Index: include/shutils.h
===================================================================
--- include/shutils.h	(revision 0)
+++ include/shutils.h	(revision 7299)
@@ -0,0 +1,200 @@
+/*
+ * Shell-like utility functions
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: shutils.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#ifndef _shutils_h_
+#define _shutils_h_
+#include <string.h>
+/*
+ * Reads file and returns contents
+ * @param	fd	file descriptor
+ * @return	contents of file or NULL if an error occurred
+ */
+extern char * fd2str(int fd);
+
+/*
+ * Reads file and returns contents
+ * @param	path	path to file
+ * @return	contents of file or NULL if an error occurred
+ */
+extern char * file2str(const char *path);
+
+/* 
+ * Waits for a file descriptor to become available for reading or unblocked signal
+ * @param	fd	file descriptor
+ * @param	timeout	seconds to wait before timing out or 0 for no timeout
+ * @return	1 if descriptor changed status or 0 if timed out or -1 on error
+ */
+extern int waitfor(int fd, int timeout);
+
+/* 
+ * Concatenates NULL-terminated list of arguments into a single
+ * commmand and executes it
+ * @param	argv	argument list
+ * @param	path	NULL, ">output", or ">>output"
+ * @param	timeout	seconds to wait before timing out or 0 for no timeout
+ * @param	ppid	NULL to wait for child termination or pointer to pid
+ * @return	return value of executed command or errno
+ */
+extern int _eval(char *const argv[], char *path, int timeout, pid_t *ppid);
+
+/* 
+ * Concatenates NULL-terminated list of arguments into a single
+ * commmand and executes it
+ * @param	argv	argument list
+ * @return	stdout of executed command or NULL if an error occurred
+ */
+extern char * _backtick(char *const argv[]);
+
+/* 
+ * Kills process whose PID is stored in plaintext in pidfile
+ * @param	pidfile	PID file
+ * @return	0 on success and errno on failure
+ */
+extern int kill_pidfile(char *pidfile);
+
+/*
+ * fread() with automatic retry on syscall interrupt
+ * @param	ptr	location to store to
+ * @param	size	size of each element of data
+ * @param	nmemb	number of elements
+ * @param	stream	file stream
+ * @return	number of items successfully read
+ */
+extern int safe_fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
+
+/*
+ * fwrite() with automatic retry on syscall interrupt
+ * @param	ptr	location to read from
+ * @param	size	size of each element of data
+ * @param	nmemb	number of elements
+ * @param	stream	file stream
+ * @return	number of items successfully written
+ */
+extern int safe_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
+
+/*
+ * Convert Ethernet address string representation to binary data
+ * @param	a	string in xx:xx:xx:xx:xx:xx notation
+ * @param	e	binary data
+ * @return	TRUE if conversion was successful and FALSE otherwise
+ */
+extern int ether_atoe(const char *a, unsigned char *e);
+
+/*
+ * Convert Ethernet address binary data to string representation
+ * @param	e	binary data
+ * @param	a	string in xx:xx:xx:xx:xx:xx notation
+ * @return	a
+ */
+extern char * ether_etoa(const unsigned char *e, char *a);
+
+/*
+ * Concatenate two strings together into a caller supplied buffer
+ * @param	s1	first string
+ * @param	s2	second string
+ * @param	buf	buffer large enough to hold both strings
+ * @return	buf
+ */
+static inline char * strcat_r(const char *s1, const char *s2, char *buf)
+{
+	strcpy(buf, s1);
+	strcat(buf, s2);
+	return buf;
+}	
+
+/* Check for a blank character; that is, a space or a tab */
+#define isblank(c) ((c) == ' ' || (c) == '\t')
+
+/* Strip trailing CR/NL from string <s> */
+#define chomp(s) ({ \
+	char *c = (s) + strlen((s)) - 1; \
+	while ((c > (s)) && (*c == '\n' || *c == '\r' || *c == ' ')) \
+		*c-- = '\0'; \
+	s; \
+})
+
+/* Simple version of _backtick() */
+#define backtick(cmd, args...) ({ \
+	char *argv[] = { cmd, ## args, NULL }; \
+	_backtick(argv); \
+})
+
+/* Simple version of _eval() (no timeout and wait for child termination) */
+#define eval(cmd, args...) ({ \
+	char *argv[] = { cmd, ## args, NULL }; \
+	_eval(argv, ">/dev/console", 0, NULL); \
+})
+
+/* Copy each token in wordlist delimited by space into word */
+#define foreach(word, wordlist, next) \
+	for (next = &wordlist[strspn(wordlist, " ")], \
+	     strncpy(word, next, sizeof(word)), \
+	     word[strcspn(word, " ")] = '\0', \
+	     word[sizeof(word) - 1] = '\0', \
+	     next = strchr(next, ' '); \
+	     strlen(word); \
+	     next = next ? &next[strspn(next, " ")] : "", \
+	     strncpy(word, next, sizeof(word)), \
+	     word[strcspn(word, " ")] = '\0', \
+	     word[sizeof(word) - 1] = '\0', \
+	     next = strchr(next, ' '))
+
+/* Return NUL instead of NULL if undefined */
+#define safe_getenv(s) (getenv(s) ? : "")
+
+/* Print directly to the console */
+#define cprintf(fmt, args...) do { \
+	FILE *fp = fopen("/dev/console", "w"); \
+	if (fp) { \
+		fprintf(fp, fmt, ## args); \
+		fclose(fp); \
+	} \
+} while (0)
+
+/* Debug print */
+#ifdef DEBUG
+#define dprintf(fmt, args...) cprintf("%s: " fmt, __FUNCTION__, ## args)
+#else
+#define dprintf(fmt, args...)
+#endif
+
+#ifdef vxworks
+
+#include <inetLib.h>
+#define inet_aton(a, n) ((inet_aton((a), (n)) == ERROR) ? 0 : 1)
+#define inet_ntoa(n) ({ char a[INET_ADDR_LEN]; inet_ntoa_b ((n), a); a; })
+
+#include <typedefs.h>
+#include <bcmutils.h>
+#define ether_atoe(a, e) bcm_ether_atoe((a), (e))
+#define ether_etoa(e, a) bcm_ether_ntoa((e), (a))
+
+/* These declarations are not available where you would expect them */
+extern int vsnprintf (char *, size_t, const char *, va_list);
+extern int snprintf(char *str, size_t count, const char *fmt, ...);
+extern char *strdup(const char *);
+extern char *strsep(char **stringp, char *delim);
+extern int strcasecmp(const char *s1, const char *s2); 
+extern int strncasecmp(const char *s1, const char *s2, size_t n); 
+
+/* Neither are socket() and connect() */
+#include <sockLib.h>
+
+#ifdef DEBUG
+#undef dprintf
+#define dprintf printf
+#endif
+#endif
+
+#endif /* _shutils_h_ */

Property changes on: include/shutils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/cyutils.h
===================================================================
--- include/cyutils.h	(revision 0)
+++ include/cyutils.h	(revision 7299)
@@ -0,0 +1,100 @@
+#include "code_pattern.h"
+
+#define EZPACKET_VERSION "1.2"
+#define MINOR_VERSION   "(Engineering Sample)"
+
+#define SERIAL_NUMBER		"000"
+#define LANG_VERSION		"v1.00.00"    //for lang.bin version control(setupwizard)
+#define PMON_BOOT_VERSION	"v1.8"
+#define CFE_BOOT_VERSION	"v2.4"	// for old cfe, no used now
+#define CFES_BOOT_VERSION	"v3.7"
+
+#define BOOT_IPADDR "192.168.1.10"
+#define BOOT_NETMASK "255.255.255.0"
+
+#define SUPPORT_4712_CHIP	0x0001
+#define SUPPORT_INTEL_FLASH	0x0002
+#define SUPPORT_5325E_SWITCH	0x0004
+#define SUPPORT_4704_CHIP	0x0008
+#define SUPPORT_5352E_CHIP	0x0010
+
+struct code_header {
+	char magic[4];
+	char res1[4];	// for extra magic
+	char fwdate[3];
+	char fwvern[3];
+	char id[4];	// U2ND
+	char hw_ver;    // 0) for 4702, 1) for 4712, 2) for 4712L, 3) for 4704, 4) for 5352E
+	char res2;
+	unsigned short flags;
+	unsigned char res3[10];
+} ;
+
+//#ifdef MULTILANG_SUPPORT
+struct lang_header {
+        char magic[4];
+        char res1[4];   // for extra magic
+        char fwdate[3];
+        char fwvern[3];
+        char id[4];     // U2ND
+        char hw_ver;    // 0: for 4702, 1: for 4712
+	char res2;
+        unsigned long len;
+        unsigned char res3[8];
+} ;
+//#endif
+
+struct boot_header {
+	char magic[3];
+	char res[29];
+};
+
+/***************************************
+ * define upnp misc                    *
+ ***************************************/
+  #if LANGUAGE == ENGLISH
+    #define URL			"http://www.linksys.com/"
+  #else
+    #define URL			"http://www.linksys.co.jp/"
+  #endif
+  #define DEV_FRIENDLY_NAME	MODEL_NAME
+  #define DEV_MFR		"Linksys Inc."
+  #define DEV_MFR_URL		URL
+  #define DEV_MODEL_DESCRIPTION	"Internet Access Server"
+  #define DEV_MODEL		MODEL_NAME
+  #define DEV_MODEL_NO		CYBERTAN_VERSION
+  #define DEV_MODEL_URL		URL
+
+/***************************************
+ * define Parental Control link        *
+ ***************************************/
+#if LOCALE == EUROPE
+  #define	SIGN_UP_URL	"http://pcsvc.ourlinksys.com/eu/language.jsp"
+  #define	MORE_INFO_URL	"http://www.linksys.com/pcsvc/eu/info_eu.asp"
+  #define	ADMIN_URL	"http://pcsvc.ourlinksys.com/en"
+#elif LOCALE == GERMANY
+  #define	SIGN_UP_URL	"http://pcsvc.ourlinksys.com/de/trial.asp"
+  #define	MORE_INFO_URL	"http://www.linksys.com/pcsvc/de/info_de.asp"
+  #define	ADMIN_URL	"http://pcsvc.ourlinksys.com/de/admin.asp"
+#elif LOCALE == FRANCE
+  #define	SIGN_UP_URL	"http://pcsvc.ourlinksys.com/fr/trial.asp"
+  #define	MORE_INFO_URL	"http://www.linksys.com/pcsvc/fr/info_fr.asp"
+  #define	ADMIN_URL	"http://pcsvc.ourlinksys.com/fr/admin.asp"
+#else
+  #define	SIGN_UP_URL	"http://pcsvc.ourlinksys.com/us/trial.asp"
+  #define	MORE_INFO_URL	"http://www.linksys.com/pcsvc/info.asp"
+  #define	ADMIN_URL	"http://pcsvc.ourlinksys.com/us/admin.asp"
+#endif
+
+/***************************************
+ * define PPTP info		       * 
+ ***************************************/
+#define	PPTP_VENDOR	"Linksys"
+#define PPTP_HOSTNAME	""
+
+/***************************************
+ * define L2TP info		       *
+ ***************************************/
+#define	L2TP_VENDOR	"Linksys"
+#define L2TP_HOSTNAME	MODEL_NAME
+

Property changes on: include/cyutils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/epivers.h
===================================================================
--- include/epivers.h	(revision 0)
+++ include/epivers.h	(revision 7299)
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: epivers.h 1629 2005-08-13 14:22:32Z nbd $
+ *
+*/
+
+#ifndef _epivers_h_
+#define _epivers_h_
+
+#ifdef	linux
+#include <linux/config.h>
+#endif
+
+/* Vendor Name, ASCII, 32 chars max */
+#ifdef COMPANYNAME
+#define	HPNA_VENDOR 		COMPANYNAME
+#else
+#define	HPNA_VENDOR 		"Broadcom Corporation"
+#endif
+
+/* Driver Date, ASCII, 32 chars max */
+#define HPNA_DRV_BUILD_DATE	__DATE__
+
+/* Hardware Manufacture Date, ASCII, 32 chars max */
+#define HPNA_HW_MFG_DATE	"Not Specified"
+
+/* See documentation for Device Type values, 32 values max */
+#ifndef	HPNA_DEV_TYPE
+
+#if	defined(CONFIG_BRCM_VJ)
+#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_DISPLAY }
+
+#elif	defined(CONFIG_BCRM_93725)
+#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_CM_BRIDGE, CDCF_V0_DEVICE_DISPLAY }
+
+#else
+#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_PCINIC }
+
+#endif
+
+#endif	/* !HPNA_DEV_TYPE */
+
+
+#define	EPI_MAJOR_VERSION	3
+
+#define	EPI_MINOR_VERSION	60
+
+#define	EPI_RC_NUMBER		13
+
+#define	EPI_INCREMENTAL_NUMBER	0
+
+#define	EPI_BUILD_NUMBER	0
+
+#define	EPI_VERSION		3,60,13,0
+
+#define	EPI_VERSION_NUM		0x033c0d00
+
+/* Driver Version String, ASCII, 32 chars max */
+#define	EPI_VERSION_STR		"3.60.13.0"
+#define	EPI_ROUTER_VERSION_STR	"3.61.13.0"
+
+#endif /* _epivers_h_ */

Property changes on: include/epivers.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/proto/802.11.h
===================================================================
--- include/proto/802.11.h	(revision 0)
+++ include/proto/802.11.h	(revision 7299)
@@ -0,0 +1,852 @@
+/*
+ * Copyright 2004, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ *
+ * Fundamental types and constants relating to 802.11 
+ *
+ * $Id: 802.11.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#ifndef _802_11_H_
+#define _802_11_H_
+
+#ifndef _TYPEDEFS_H_
+#include <typedefs.h>
+#endif
+
+#ifndef _NET_ETHERNET_H_
+#include <proto/ethernet.h>
+#endif
+
+/* enable structure packing */
+#if !defined(__GNUC__)
+#pragma pack(1)
+#endif
+
+/* some platforms require stronger medicine */
+#if defined(__GNUC__)
+#define	PACKED	__attribute__((packed))
+#else
+#define	PACKED
+#endif
+
+
+#define DOT11_TU_TO_US			1024	/* 802.11 Time Unit is 1024 microseconds */
+
+/* Generic 802.11 frame constants */
+#define DOT11_A3_HDR_LEN		24
+#define DOT11_A4_HDR_LEN		30
+#define DOT11_MAC_HDR_LEN		DOT11_A3_HDR_LEN
+#define DOT11_FCS_LEN			4
+#define DOT11_ICV_LEN			4
+#define DOT11_ICV_AES_LEN		8
+#define DOT11_QOS_LEN			2
+
+#define DOT11_KEY_INDEX_SHIFT		6
+#define DOT11_IV_LEN			4
+#define DOT11_IV_TKIP_LEN		8
+#define DOT11_IV_AES_OCB_LEN		4
+#define DOT11_IV_AES_CCM_LEN		8
+
+/* Includes MIC */
+#define DOT11_MAX_MPDU_BODY_LEN		2304
+/* A4 header + QoS + CCMP + PDU + ICV + FCS = 2352 */
+#define DOT11_MAX_MPDU_LEN		(DOT11_A4_HDR_LEN + \
+					 DOT11_QOS_LEN + \
+					 DOT11_IV_AES_CCM_LEN + \
+					 DOT11_MAX_MPDU_BODY_LEN + \
+					 DOT11_ICV_LEN + \
+					 DOT11_FCS_LEN)
+
+#define DOT11_MAX_SSID_LEN		32
+
+/* dot11RTSThreshold */
+#define DOT11_DEFAULT_RTS_LEN		2347
+#define DOT11_MAX_RTS_LEN		2347
+
+/* dot11FragmentationThreshold */
+#define DOT11_MIN_FRAG_LEN		256
+#define DOT11_MAX_FRAG_LEN		2346	/* Max frag is also limited by aMPDUMaxLength of the attached PHY */
+#define DOT11_DEFAULT_FRAG_LEN		2346
+
+/* dot11BeaconPeriod */
+#define DOT11_MIN_BEACON_PERIOD		1
+#define DOT11_MAX_BEACON_PERIOD		0xFFFF
+
+/* dot11DTIMPeriod */
+#define DOT11_MIN_DTIM_PERIOD		1
+#define DOT11_MAX_DTIM_PERIOD		0xFF
+
+/* 802.2 LLC/SNAP header used by 802.11 per 802.1H */
+#define DOT11_LLC_SNAP_HDR_LEN	8
+#define DOT11_OUI_LEN			3
+struct dot11_llc_snap_header {
+	uint8	dsap;				/* always 0xAA */
+	uint8	ssap;				/* always 0xAA */
+	uint8	ctl;				/* always 0x03 */
+	uint8	oui[DOT11_OUI_LEN];		/* RFC1042: 0x00 0x00 0x00
+						   Bridge-Tunnel: 0x00 0x00 0xF8 */
+	uint16	type;				/* ethertype */
+} PACKED;
+
+/* RFC1042 header used by 802.11 per 802.1H */
+#define RFC1042_HDR_LEN			(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN)
+
+/* Generic 802.11 MAC header */
+/*
+ * N.B.: This struct reflects the full 4 address 802.11 MAC header.
+ *		 The fields are defined such that the shorter 1, 2, and 3
+ *		 address headers just use the first k fields.
+ */
+struct dot11_header {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* duration/ID */
+	struct ether_addr	a1;		/* address 1 */
+	struct ether_addr	a2;		/* address 2 */
+	struct ether_addr	a3;		/* address 3 */
+	uint16			seq;		/* sequence control */
+	struct ether_addr	a4;		/* address 4 */
+} PACKED;
+
+/* Control frames */
+
+struct dot11_rts_frame {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+	struct ether_addr	ta;		/* transmitter address */
+} PACKED;
+#define	DOT11_RTS_LEN		16
+
+struct dot11_cts_frame {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+} PACKED;
+#define	DOT11_CTS_LEN		10
+
+struct dot11_ack_frame {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+} PACKED;
+#define	DOT11_ACK_LEN		10
+
+struct dot11_ps_poll_frame {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* AID */
+	struct ether_addr	bssid;		/* receiver address, STA in AP */
+	struct ether_addr	ta;		/* transmitter address */
+} PACKED;
+#define	DOT11_PS_POLL_LEN	16
+
+struct dot11_cf_end_frame {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+	struct ether_addr	bssid;		/* transmitter address, STA in AP */
+} PACKED;
+#define	DOT11_CS_END_LEN	16
+
+/* Management frame header */
+struct dot11_management_header {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* duration/ID */
+	struct ether_addr	da;		/* receiver address */
+	struct ether_addr	sa;		/* transmitter address */
+	struct ether_addr	bssid;		/* BSS ID */
+	uint16			seq;		/* sequence control */
+} PACKED;
+#define	DOT11_MGMT_HDR_LEN	24
+
+/* Management frame payloads */
+
+struct dot11_bcn_prb {
+	uint32			timestamp[2];
+	uint16			beacon_interval;
+	uint16			capability;
+} PACKED;
+#define	DOT11_BCN_PRB_LEN	12
+
+struct dot11_auth {
+	uint16			alg;		/* algorithm */
+	uint16			seq;		/* sequence control */
+	uint16			status;		/* status code */
+} PACKED;
+#define DOT11_AUTH_FIXED_LEN	6		/* length of auth frame without challenge info elt */
+
+struct dot11_assoc_req {
+	uint16			capability;	/* capability information */
+	uint16			listen;		/* listen interval */
+} PACKED;
+
+struct dot11_assoc_resp {
+	uint16			capability;	/* capability information */
+	uint16			status;		/* status code */
+	uint16			aid;		/* association ID */
+} PACKED;
+
+struct dot11_action_measure {
+	uint8	category;
+	uint8	action;
+	uint8	token;
+	uint8	data[1];
+} PACKED;
+#define DOT11_ACTION_MEASURE_LEN	3
+
+/**************
+  802.11h related definitions.
+**************/
+typedef struct {
+	uint8 id;
+	uint8 len;
+	uint8 power;
+} dot11_power_cnst_t;
+
+typedef struct {
+	uint8 min;
+	uint8 max;
+} dot11_power_cap_t;
+
+typedef struct {
+	uint8 id;
+	uint8 len;
+	uint8 tx_pwr;
+	uint8 margin;
+} dot11_tpc_rep_t;
+#define DOT11_MNG_IE_TPC_REPORT_LEN	2	/* length of IE data, not including 2 byte header */
+
+typedef struct {
+	uint8 id;
+	uint8 len;
+	uint8 first_channel;
+	uint8 num_channels;
+} dot11_supp_channels_t;
+
+struct dot11_channel_switch {
+	uint8 id;
+	uint8 len;
+	uint8 mode;
+	uint8 channel;
+	uint8 count;
+}  PACKED;
+typedef struct dot11_channel_switch dot11_channel_switch_t;
+
+/* 802.11h Measurement Request/Report IEs */
+/* Measurement Type field */
+#define DOT11_MEASURE_TYPE_BASIC 	0
+#define DOT11_MEASURE_TYPE_CCA 		1
+#define DOT11_MEASURE_TYPE_RPI	 	2
+
+/* Measurement Mode field */
+
+/* Measurement Request Modes */
+#define DOT11_MEASURE_MODE_ENABLE 	(1<<1)
+#define DOT11_MEASURE_MODE_REQUEST	(1<<2)
+#define DOT11_MEASURE_MODE_REPORT 	(1<<3)
+/* Measurement Report Modes */
+#define DOT11_MEASURE_MODE_LATE 	(1<<0)
+#define DOT11_MEASURE_MODE_INCAPABLE	(1<<1)
+#define DOT11_MEASURE_MODE_REFUSED	(1<<2)
+/* Basic Measurement Map bits */
+#define DOT11_MEASURE_BASIC_MAP_BSS	((uint8)(1<<0))
+#define DOT11_MEASURE_BASIC_MAP_OFDM	((uint8)(1<<1))
+#define DOT11_MEASURE_BASIC_MAP_UKNOWN	((uint8)(1<<2))
+#define DOT11_MEASURE_BASIC_MAP_RADAR	((uint8)(1<<3))
+#define DOT11_MEASURE_BASIC_MAP_UNMEAS	((uint8)(1<<4))
+
+typedef struct {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 channel;
+	uint8 start_time[8];
+	uint16 duration;
+} dot11_meas_req_t;
+#define DOT11_MNG_IE_MREQ_LEN 14
+/* length of Measure Request IE data not including variable len */
+#define DOT11_MNG_IE_MREQ_FIXED_LEN 3
+
+struct dot11_meas_rep {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	union 
+	{
+		struct {
+			uint8 channel;
+			uint8 start_time[8];
+			uint16 duration;
+			uint8 map;
+		} PACKED basic;
+		uint8 data[1];
+	} PACKED rep;
+} PACKED;
+typedef struct dot11_meas_rep dot11_meas_rep_t;
+
+/* length of Measure Report IE data not including variable len */
+#define DOT11_MNG_IE_MREP_FIXED_LEN	3
+
+struct dot11_meas_rep_basic {
+	uint8 channel;
+	uint8 start_time[8];
+	uint16 duration;
+	uint8 map;
+} PACKED;
+typedef struct dot11_meas_rep_basic dot11_meas_rep_basic_t;
+#define DOT11_MEASURE_BASIC_REP_LEN	12
+
+struct dot11_quiet {
+	uint8 id;
+	uint8 len;
+	uint8 count;	/* TBTTs until beacon interval in quiet starts */
+	uint8 period;	/* Beacon intervals between periodic quiet periods ? */
+	uint16 duration;/* Length of quiet period, in TU's */
+	uint16 offset;	/* TU's offset from TBTT in Count field */
+} PACKED;
+typedef struct dot11_quiet dot11_quiet_t;
+
+typedef struct {
+	uint8 channel;
+	uint8 map;
+} chan_map_tuple_t;
+
+typedef struct {
+	uint8 id;
+	uint8 len;
+	uint8 eaddr[ETHER_ADDR_LEN];
+	uint8 interval;
+	chan_map_tuple_t map[1];
+} dot11_ibss_dfs_t;
+
+/* WME Elements */
+#define WME_OUI			"\x00\x50\xf2"
+#define WME_VER			1
+#define WME_TYPE		2
+#define WME_SUBTYPE_IE		0	/* Information Element */
+#define WME_SUBTYPE_PARAM_IE	1	/* Parameter Element */
+#define WME_SUBTYPE_TSPEC	2	/* Traffic Specification */
+
+/* WME Access Category Indices (ACIs) */
+#define AC_BE			0	/* Best Effort */
+#define AC_BK			1	/* Background */
+#define AC_VI			2	/* Video */
+#define AC_VO			3	/* Voice */
+#define AC_MAX			4
+
+/* WME Information Element (IE) */
+struct wme_ie {
+	uint8 oui[3];
+	uint8 type;
+	uint8 subtype;
+	uint8 version;
+	uint8 acinfo;
+} PACKED;
+typedef struct wme_ie wme_ie_t;
+#define WME_IE_LEN 7
+
+struct wme_acparam {
+	uint8	ACI;
+	uint8	ECW;
+	uint16  TXOP;		/* stored in network order (ls octet first) */
+} PACKED;
+typedef struct wme_acparam wme_acparam_t;
+
+/* WME Parameter Element (PE) */
+struct wme_params {
+	uint8 oui[3];
+	uint8 type;
+	uint8 subtype;
+	uint8 version;
+	uint8 acinfo;
+	uint8 rsvd;
+	wme_acparam_t acparam[4];
+} PACKED;
+typedef struct wme_params wme_params_t;
+#define WME_PARAMS_IE_LEN	24
+
+/* acinfo */
+#define WME_COUNT_MASK 	0x0f
+/* ACI */
+#define WME_AIFS_MASK 	0x0f
+#define WME_ACM_MASK 	0x10
+#define WME_ACI_MASK 	0x60
+#define WME_ACI_SHIFT 	5
+/* ECW */
+#define WME_CWMIN_MASK	0x0f
+#define WME_CWMAX_MASK	0xf0
+#define WME_CWMAX_SHIFT	4
+
+#define WME_TXOP_UNITS	32
+
+/* WME Traffic Specification (TSPEC) element */
+#define WME_SUBTYPE_TSPEC 2
+#define WME_TSPEC_HDR_LEN		2
+#define WME_TSPEC_BODY_OFF		2
+struct wme_tspec {
+	uint8 oui[DOT11_OUI_LEN];	/* WME_OUI */
+	uint8 type;			/* WME_TYPE */
+	uint8 subtype;			/* WME_SUBTYPE_TSPEC */
+	uint8 version;			/* WME_VERSION */
+	uint16 ts_info;			/* TS Info */
+	uint16 nom_msdu_size;		/* (Nominal or fixed) MSDU Size (bytes) */
+	uint16 max_msdu_size;		/* Maximum MSDU Size (bytes) */
+	uint32 min_service_interval;	/* Minimum Service Interval (us) */
+	uint32 max_service_interval;	/* Maximum Service Interval (us) */
+	uint32 inactivity_interval;	/* Inactivity Interval (us) */
+	uint32 service_start;		/* Service Start Time (us) */
+	uint32 min_rate;		/* Minimum Data Rate (bps) */
+	uint32 mean_rate;		/* Mean Data Rate (bps) */
+	uint32 max_burst_size;		/* Maximum Burst Size (bytes) */
+	uint32 min_phy_rate;		/* Minimum PHY Rate (bps) */
+	uint32 peak_rate;		/* Peak Data Rate (bps) */
+	uint32 delay_bound;		/* Delay Bound (us) */
+	uint16 surplus_bandwidth;	/* Surplus Bandwidth Allowance Factor */
+	uint16 medium_time;		/* Medium Time (32 us/s periods) */
+} PACKED;
+typedef struct wme_tspec wme_tspec_t;
+#define WME_TSPEC_LEN 56		/* not including 2-byte header */
+
+/* ts_info */
+/* 802.1D priority is duplicated - bits 13-11 AND bits 3-1 */
+#define TS_INFO_PRIO_SHIFT_HI		11
+#define TS_INFO_PRIO_MASK_HI		(0x7 << TS_INFO_PRIO_SHIFT_HI)
+#define TS_INFO_PRIO_SHIFT_LO		1
+#define TS_INFO_PRIO_MASK_LO		(0x7 << TS_INFO_PRIO_SHIFT_LO)
+#define TS_INFO_CONTENTION_SHIFT	7
+#define TS_INFO_CONTENTION_MASK		(0x1 << TS_INFO_CONTENTION_SHIFT)
+#define TS_INFO_DIRECTION_SHIFT		5
+#define TS_INFO_DIRECTION_MASK		(0x3 << TS_INFO_DIRECTION_SHIFT)
+#define TS_INFO_UPLINK			(0 << TS_INFO_DIRECTION_SHIFT)
+#define TS_INFO_DOWNLINK		(1 << TS_INFO_DIRECTION_SHIFT)
+#define TS_INFO_BIDIRECTIONAL		(3 << TS_INFO_DIRECTION_SHIFT)
+
+/* nom_msdu_size */
+#define FIXED_MSDU_SIZE 0x8000		/* MSDU size is fixed */
+#define MSDU_SIZE_MASK	0x7fff		/* (Nominal or fixed) MSDU size */
+
+/* surplus_bandwidth */
+/* Represented as 3 bits of integer, binary point, 13 bits fraction */
+#define	INTEGER_SHIFT	13
+#define FRACTION_MASK	0x1FFF
+
+/* Management Notification Frame */
+struct dot11_management_notification {
+	uint8 category;			/* DOT11_ACTION_NOTIFICATION */
+	uint8 action;
+	uint8 token;
+	uint8 status;
+	uint8 data[1];			/* Elements */
+} PACKED;
+#define DOT11_MGMT_NOTIFICATION_LEN 4	/* Fixed length */
+
+/* WME Action Codes */
+#define WME_SETUP_REQUEST	0
+#define WME_SETUP_RESPONSE	1
+#define WME_TEARDOWN		2
+
+/* WME Setup Response Status Codes */
+#define WME_ADMISSION_ACCEPTED	0
+#define WME_INVALID_PARAMETERS	1
+#define WME_ADMISSION_REFUSED	3
+
+/* Macro to take a pointer to a beacon or probe response
+ * header and return the char* pointer to the SSID info element
+ */
+#define BCN_PRB_SSID(hdr) ((char*)(hdr) + DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_LEN)
+
+/* Authentication frame payload constants */
+#define DOT11_OPEN_SYSTEM	0
+#define DOT11_SHARED_KEY	1
+#define DOT11_CHALLENGE_LEN	128
+
+/* Frame control macros */
+#define FC_PVER_MASK		0x3
+#define FC_PVER_SHIFT		0
+#define FC_TYPE_MASK		0xC
+#define FC_TYPE_SHIFT		2
+#define FC_SUBTYPE_MASK		0xF0
+#define FC_SUBTYPE_SHIFT	4
+#define FC_TODS			0x100
+#define FC_TODS_SHIFT		8
+#define FC_FROMDS		0x200
+#define FC_FROMDS_SHIFT		9
+#define FC_MOREFRAG		0x400
+#define FC_MOREFRAG_SHIFT	10
+#define FC_RETRY		0x800
+#define FC_RETRY_SHIFT		11
+#define FC_PM			0x1000
+#define FC_PM_SHIFT		12
+#define FC_MOREDATA		0x2000
+#define FC_MOREDATA_SHIFT	13
+#define FC_WEP			0x4000
+#define FC_WEP_SHIFT		14
+#define FC_ORDER		0x8000
+#define FC_ORDER_SHIFT		15
+
+/* sequence control macros */
+#define SEQNUM_SHIFT		4
+#define FRAGNUM_MASK		0xF
+
+/* Frame Control type/subtype defs */
+
+/* FC Types */
+#define FC_TYPE_MNG		0
+#define FC_TYPE_CTL		1
+#define FC_TYPE_DATA		2
+
+/* Management Subtypes */
+#define FC_SUBTYPE_ASSOC_REQ		0
+#define FC_SUBTYPE_ASSOC_RESP		1
+#define FC_SUBTYPE_REASSOC_REQ		2
+#define FC_SUBTYPE_REASSOC_RESP		3
+#define FC_SUBTYPE_PROBE_REQ		4
+#define FC_SUBTYPE_PROBE_RESP		5
+#define FC_SUBTYPE_BEACON		8
+#define FC_SUBTYPE_ATIM			9
+#define FC_SUBTYPE_DISASSOC		10
+#define FC_SUBTYPE_AUTH			11
+#define FC_SUBTYPE_DEAUTH		12
+#define FC_SUBTYPE_ACTION		13
+
+/* Control Subtypes */
+#define FC_SUBTYPE_PS_POLL		10
+#define FC_SUBTYPE_RTS			11
+#define FC_SUBTYPE_CTS			12
+#define FC_SUBTYPE_ACK			13
+#define FC_SUBTYPE_CF_END		14
+#define FC_SUBTYPE_CF_END_ACK		15
+
+/* Data Subtypes */
+#define FC_SUBTYPE_DATA			0
+#define FC_SUBTYPE_DATA_CF_ACK		1
+#define FC_SUBTYPE_DATA_CF_POLL		2
+#define FC_SUBTYPE_DATA_CF_ACK_POLL	3
+#define FC_SUBTYPE_NULL			4
+#define FC_SUBTYPE_CF_ACK		5
+#define FC_SUBTYPE_CF_POLL		6
+#define FC_SUBTYPE_CF_ACK_POLL		7
+#define FC_SUBTYPE_QOS_DATA		8
+#define FC_SUBTYPE_QOS_NULL		12
+
+/* type-subtype combos */
+#define FC_KIND_MASK		(FC_TYPE_MASK | FC_SUBTYPE_MASK)
+
+#define FC_KIND(t, s) (((t) << FC_TYPE_SHIFT) | ((s) << FC_SUBTYPE_SHIFT))
+
+#define FC_ASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_REQ)
+#define FC_ASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_RESP)
+#define FC_REASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_REQ)
+#define FC_REASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_RESP)
+#define FC_PROBE_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_REQ)
+#define FC_PROBE_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_RESP)
+#define FC_BEACON	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_BEACON)
+#define FC_DISASSOC	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DISASSOC)
+#define FC_AUTH		FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_AUTH)
+#define FC_DEAUTH	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DEAUTH)
+#define FC_ACTION	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION)
+
+#define FC_PS_POLL	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_PS_POLL)
+#define FC_RTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_RTS)
+#define FC_CTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTS)
+#define FC_ACK		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_ACK)
+#define FC_CF_END	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END)
+#define FC_CF_END_ACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END_ACK)
+
+#define FC_DATA		FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA)
+#define FC_NULL_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_NULL)
+#define FC_DATA_CF_ACK	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA_CF_ACK)
+#define FC_QOS_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_DATA)
+#define FC_QOS_NULL	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_NULL)
+
+/* QoS Control Field */
+
+/* 802.1D Tag */
+#define QOS_PRIO_SHIFT		0
+#define QOS_PRIO_MASK		0x0007
+#define QOS_PRIO(qos)		(((qos) & QOS_PRIO_MASK) >> QOS_PRIO_SHIFT)
+
+/* Ack Policy (0 means Acknowledge) */
+#define QOS_ACK_SHIFT		5
+#define QOS_ACK_MASK		0x0060
+#define QOS_ACK(qos)		(((qos) & QOS_ACK_MASK) >> QOS_ACK_SHIFT)
+
+/* Management Frames */
+
+/* Management Frame Constants */
+
+/* Fixed fields */
+#define DOT11_MNG_AUTH_ALGO_LEN		2
+#define DOT11_MNG_AUTH_SEQ_LEN		2
+#define DOT11_MNG_BEACON_INT_LEN	2
+#define DOT11_MNG_CAP_LEN		2
+#define DOT11_MNG_AP_ADDR_LEN		6
+#define DOT11_MNG_LISTEN_INT_LEN	2
+#define DOT11_MNG_REASON_LEN		2
+#define DOT11_MNG_AID_LEN		2
+#define DOT11_MNG_STATUS_LEN		2
+#define DOT11_MNG_TIMESTAMP_LEN		8
+
+/* DUR/ID field in assoc resp is 0xc000 | AID */
+#define DOT11_AID_MASK			0x3fff
+
+/* Reason Codes */
+#define DOT11_RC_RESERVED			0
+#define DOT11_RC_UNSPECIFIED			1	/* Unspecified reason */
+#define DOT11_RC_AUTH_INVAL			2	/* Previous authentication no longer valid */
+#define DOT11_RC_DEAUTH_LEAVING			3	/* Deauthenticated because sending station is
+							   leaving (or has left) IBSS or ESS */
+#define DOT11_RC_INACTIVITY			4	/* Disassociated due to inactivity */
+#define DOT11_RC_BUSY				5	/* Disassociated because AP is unable to handle
+							   all currently associated stations */
+#define DOT11_RC_INVAL_CLASS_2			6	/* Class 2 frame received from
+							   nonauthenticated station */
+#define DOT11_RC_INVAL_CLASS_3			7	/* Class 3 frame received from
+							   nonassociated station */
+#define DOT11_RC_DISASSOC_LEAVING		8	/* Disassociated because sending station is
+							   leaving (or has left) BSS */
+#define DOT11_RC_NOT_AUTH			9	/* Station requesting (re)association is
+							   not authenticated with responding station */
+#define DOT11_RC_MAX				23	/* Reason codes > 23 are reserved */
+
+/* Status Codes */
+#define DOT11_STATUS_SUCCESS			0	/* Successful */
+#define DOT11_STATUS_FAILURE			1	/* Unspecified failure */
+#define DOT11_STATUS_CAP_MISMATCH		10	/* Cannot support all requested capabilities
+							   in the Capability Information field */
+#define DOT11_STATUS_REASSOC_FAIL		11	/* Reassociation denied due to inability to
+							   confirm that association exists */
+#define DOT11_STATUS_ASSOC_FAIL			12	/* Association denied due to reason outside
+							   the scope of this standard */
+#define DOT11_STATUS_AUTH_MISMATCH		13	/* Responding station does not support the
+							   specified authentication algorithm */
+#define DOT11_STATUS_AUTH_SEQ			14	/* Received an Authentication frame with
+							   authentication transaction sequence number
+							   out of expected sequence */
+#define DOT11_STATUS_AUTH_CHALLENGE_FAIL	15	/* Authentication rejected because of challenge failure */
+#define DOT11_STATUS_AUTH_TIMEOUT		16	/* Authentication rejected due to timeout waiting
+							   for next frame in sequence */
+#define DOT11_STATUS_ASSOC_BUSY_FAIL		17	/* Association denied because AP is unable to
+							   handle additional associated stations */
+#define DOT11_STATUS_ASSOC_RATE_MISMATCH	18	/* Association denied due to requesting station
+							   not supporting all of the data rates in the
+							   BSSBasicRateSet parameter */
+#define DOT11_STATUS_ASSOC_SHORT_REQUIRED	19	/* Association denied due to requesting station
+							   not supporting the Short Preamble option */
+#define DOT11_STATUS_ASSOC_PBCC_REQUIRED	20	/* Association denied due to requesting station
+							   not supporting the PBCC Modulation option */
+#define DOT11_STATUS_ASSOC_AGILITY_REQUIRED	21	/* Association denied due to requesting station
+							   not supporting the Channel Agility option */
+#define DOT11_STATUS_ASSOC_SPECTRUM_REQUIRED	22	/* Association denied because Spectrum Management 
+							   capability is required. */
+#define DOT11_STATUS_ASSOC_BAD_POWER_CAP	23	/* Association denied because the info in the 
+							   Power Cap element is unacceptable. */
+#define DOT11_STATUS_ASSOC_BAD_SUP_CHANNELS	24	/* Association denied because the info in the 
+							   Supported Channel element is unacceptable */
+#define DOT11_STATUS_ASSOC_SHORTSLOT_REQUIRED	25	/* Association denied due to requesting station
+							   not supporting the Short Slot Time option */
+#define DOT11_STATUS_ASSOC_ERPBCC_REQUIRED	26	/* Association denied due to requesting station
+							   not supporting the ER-PBCC Modulation option */
+#define DOT11_STATUS_ASSOC_DSSOFDM_REQUIRED	27	/* Association denied due to requesting station
+							   not supporting the DSS-OFDM option */
+
+/* Info Elts, length of INFORMATION portion of Info Elts */
+#define DOT11_MNG_DS_PARAM_LEN			1
+#define DOT11_MNG_IBSS_PARAM_LEN		2
+
+/* TIM Info element has 3 bytes fixed info in INFORMATION field,
+ * followed by 1 to 251 bytes of Partial Virtual Bitmap */
+#define DOT11_MNG_TIM_FIXED_LEN			3
+#define DOT11_MNG_TIM_DTIM_COUNT		0
+#define DOT11_MNG_TIM_DTIM_PERIOD		1
+#define DOT11_MNG_TIM_BITMAP_CTL		2
+#define DOT11_MNG_TIM_PVB			3
+
+/* TLV defines */
+#define TLV_TAG_OFF		0
+#define TLV_LEN_OFF		1
+#define TLV_HDR_LEN		2
+#define TLV_BODY_OFF		2
+
+/* Management Frame Information Element IDs */
+#define DOT11_MNG_SSID_ID			0
+#define DOT11_MNG_RATES_ID			1
+#define DOT11_MNG_FH_PARMS_ID			2
+#define DOT11_MNG_DS_PARMS_ID			3
+#define DOT11_MNG_CF_PARMS_ID			4
+#define DOT11_MNG_TIM_ID			5
+#define DOT11_MNG_IBSS_PARMS_ID			6
+#define DOT11_MNG_COUNTRY_ID			7
+#define DOT11_MNG_HOPPING_PARMS_ID		8
+#define DOT11_MNG_HOPPING_TABLE_ID		9
+#define DOT11_MNG_REQUEST_ID			10
+#define DOT11_MNG_CHALLENGE_ID			16
+#define DOT11_MNG_PWR_CONSTRAINT_ID		32    /* 11H PowerConstraint	*/
+#define DOT11_MNG_PWR_CAP_ID			33    /* 11H PowerCapability	*/
+#define DOT11_MNG_TPC_REQUEST_ID 		34    /* 11H TPC Request	*/
+#define DOT11_MNG_TPC_REPORT_ID			35    /* 11H TPC Report		*/
+#define DOT11_MNG_SUPP_CHANNELS_ID		36    /* 11H Supported Channels	*/
+#define DOT11_MNG_CHANNEL_SWITCH_ID		37    /* 11H ChannelSwitch Announcement*/
+#define DOT11_MNG_MEASURE_REQUEST_ID		38    /* 11H MeasurementRequest	*/
+#define DOT11_MNG_MEASURE_REPORT_ID		39    /* 11H MeasurementReport	*/
+#define DOT11_MNG_QUIET_ID			40    /* 11H Quiet		*/
+#define DOT11_MNG_IBSS_DFS_ID			41    /* 11H IBSS_DFS 		*/
+#define DOT11_MNG_ERP_ID			42
+#define DOT11_MNG_NONERP_ID			47
+#define DOT11_MNG_EXT_RATES_ID			50
+#define DOT11_MNG_WPA_ID			221
+#define DOT11_MNG_PROPR_ID			221
+
+/* ERP info element bit values */
+#define DOT11_MNG_ERP_LEN			1	/* ERP is currently 1 byte long */
+#define DOT11_MNG_NONERP_PRESENT		0x01	/* NonERP (802.11b) STAs are present in the BSS */
+#define DOT11_MNG_USE_PROTECTION		0x02	/* Use protection mechanisms for ERP-OFDM frames */
+#define DOT11_MNG_BARKER_PREAMBLE		0x04	/* Short Preambles: 0 == allowed, 1 == not allowed */
+
+/* Capability Information Field */
+#define DOT11_CAP_ESS				0x0001
+#define DOT11_CAP_IBSS				0x0002
+#define DOT11_CAP_POLLABLE			0x0004
+#define DOT11_CAP_POLL_RQ			0x0008
+#define DOT11_CAP_PRIVACY			0x0010
+#define DOT11_CAP_SHORT				0x0020
+#define DOT11_CAP_PBCC				0x0040
+#define DOT11_CAP_AGILITY			0x0080
+#define DOT11_CAP_SPECTRUM			0x0100
+#define DOT11_CAP_SHORTSLOT			0x0400
+#define DOT11_CAP_CCK_OFDM			0x2000
+
+/* Action Frame Constants */
+#define DOT11_ACTION_CAT_ERR_MASK	0x80
+#define DOT11_ACTION_CAT_SPECT_MNG	0x00
+#define DOT11_ACTION_NOTIFICATION	0x11	/* 17 */
+
+#define DOT11_ACTION_ID_M_REQ		0
+#define DOT11_ACTION_ID_M_REP		1
+#define DOT11_ACTION_ID_TPC_REQ		2
+#define DOT11_ACTION_ID_TPC_REP		3
+#define DOT11_ACTION_ID_CHANNEL_SWITCH	4
+
+/* MLME Enumerations */
+#define DOT11_BSSTYPE_INFRASTRUCTURE		0
+#define DOT11_BSSTYPE_INDEPENDENT		1
+#define DOT11_BSSTYPE_ANY			2
+#define DOT11_SCANTYPE_ACTIVE			0
+#define DOT11_SCANTYPE_PASSIVE			1
+
+/* 802.11 A PHY constants */
+#define APHY_SLOT_TIME		9
+#define APHY_SIFS_TIME		16
+#define APHY_DIFS_TIME		(APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))
+#define APHY_PREAMBLE_TIME	16
+#define APHY_SIGNAL_TIME	4
+#define APHY_SYMBOL_TIME	4
+#define APHY_SERVICE_NBITS	16
+#define APHY_TAIL_NBITS		6
+#define	APHY_CWMIN		15
+
+/* 802.11 B PHY constants */
+#define BPHY_SLOT_TIME		20
+#define BPHY_SIFS_TIME		10
+#define BPHY_DIFS_TIME		50
+#define BPHY_PLCP_TIME		192
+#define BPHY_PLCP_SHORT_TIME	96
+#define	BPHY_CWMIN		31
+
+/* 802.11 G constants */
+#define DOT11_OFDM_SIGNAL_EXTENSION	6
+
+#define PHY_CWMAX		1023
+
+#define	DOT11_MAXNUMFRAGS	16	/* max # fragments per MSDU */
+
+/* dot11Counters Table - 802.11 spec., Annex D */
+typedef struct d11cnt {
+	uint32		txfrag;		/* dot11TransmittedFragmentCount */
+	uint32		txmulti;	/* dot11MulticastTransmittedFrameCount */
+	uint32		txfail;		/* dot11FailedCount */
+	uint32		txretry;	/* dot11RetryCount */
+	uint32		txretrie;	/* dot11MultipleRetryCount */
+	uint32		rxdup;		/* dot11FrameduplicateCount */
+	uint32		txrts;		/* dot11RTSSuccessCount */
+	uint32		txnocts;	/* dot11RTSFailureCount */
+	uint32		txnoack;	/* dot11ACKFailureCount */
+	uint32		rxfrag;		/* dot11ReceivedFragmentCount */
+	uint32		rxmulti;	/* dot11MulticastReceivedFrameCount */
+	uint32		rxcrc;		/* dot11FCSErrorCount */
+	uint32		txfrmsnt;	/* dot11TransmittedFrameCount */
+	uint32		rxundec;	/* dot11WEPUndecryptableCount */
+} d11cnt_t;
+
+/* BRCM OUI */
+#define BRCM_OUI		"\x00\x10\x18"
+
+/* BRCM info element */
+struct brcm_ie {
+	uchar	id;		
+	uchar	len;   
+	uchar 	oui[3];
+	uchar	ver;
+	uchar	assoc;		/*  # of assoc STAs */
+	uchar	flags;		/* misc flags */
+} PACKED;
+#define BRCM_IE_LEN		8
+typedef	struct brcm_ie brcm_ie_t;
+#define BRCM_IE_VER		1
+
+/* brcm_ie flags */
+#define	BRF_ABCAP		0x1	/* afterburner capable */
+#define	BRF_ABRQRD		0x2	/* afterburner requested */
+
+/* WPA definitions */
+#define WPA_VERSION		1
+#define WPA_OUI			"\x00\x50\xF2"
+
+#define WPA_OUI_LEN	3
+
+/* WPA authentication modes */
+#define WPA_AUTH_NONE		0	/* None */
+#define WPA_AUTH_UNSPECIFIED	1	/* Unspecified authentication over 802.1X: default for WPA */
+#define WPA_AUTH_PSK		2	/* Pre-shared Key over 802.1X */
+#define WPA_AUTH_DISABLED	255	/* Legacy (i.e., non-WPA) */
+				 
+#define IS_WPA_AUTH(auth)	((auth) == WPA_AUTH_NONE || \
+				 (auth) == WPA_AUTH_UNSPECIFIED || \
+				 (auth) == WPA_AUTH_PSK)
+
+
+/* Key related defines */
+#define DOT11_MAX_DEFAULT_KEYS	4	/* number of default keys */
+#define DOT11_MAX_KEY_SIZE	32	/* max size of any key */
+#define DOT11_MAX_IV_SIZE	16	/* max size of any IV */
+#define DOT11_EXT_IV_FLAG	(1<<5)	/* flag to indicate IV is > 4 bytes */
+
+#define WEP1_KEY_SIZE		5	/* max size of any WEP key */
+#define WEP1_KEY_HEX_SIZE	10	/* size of WEP key in hex. */
+#define WEP128_KEY_SIZE		13	/* max size of any WEP key */
+#define WEP128_KEY_HEX_SIZE	26	/* size of WEP key in hex. */
+#define TKIP_MIC_SIZE		8	/* size of TKIP MIC */
+#define TKIP_EOM_SIZE		7	/* max size of TKIP EOM */
+#define TKIP_EOM_FLAG		0x5a	/* TKIP EOM flag byte */
+#define TKIP_KEY_SIZE		32	/* size of any TKIP key */
+#define TKIP_MIC_AUTH_TX	16	/* offset to Authenticator MIC TX key */
+#define TKIP_MIC_AUTH_RX	24	/* offset to Authenticator MIC RX key */
+#define TKIP_MIC_SUP_RX		16	/* offset to Supplicant MIC RX key */
+#define TKIP_MIC_SUP_TX		24	/* offset to Supplicant MIC TX key */
+#define AES_KEY_SIZE		16	/* size of AES key */
+
+#undef PACKED
+#if !defined(__GNUC__)
+#pragma pack()
+#endif
+
+#endif /* _802_11_H_ */

Property changes on: include/proto/802.11.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/proto/ethernet.h
===================================================================
--- include/proto/ethernet.h	(revision 0)
+++ include/proto/ethernet.h	(revision 7299)
@@ -0,0 +1,179 @@
+/*******************************************************************************
+ * $Id: ethernet.h 1629 2005-08-13 14:22:32Z nbd $
+ * Copyright 2004, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * From FreeBSD 2.2.7: Fundamental constants relating to ethernet.
+ ******************************************************************************/
+
+#ifndef _NET_ETHERNET_H_	    /* use native BSD ethernet.h when available */
+#define _NET_ETHERNET_H_
+
+#ifndef _TYPEDEFS_H_
+#include "typedefs.h"
+#endif
+
+#if defined(__GNUC__)
+#define	PACKED	__attribute__((packed))
+#else
+#define	PACKED
+#endif
+
+/*
+ * The number of bytes in an ethernet (MAC) address.
+ */
+#ifndef ETHER_ADDR_LEN
+#define	ETHER_ADDR_LEN		6
+#endif
+
+/*
+ * The number of bytes in the type field.
+ */
+#ifndef	ETHER_TYPE_LEN
+#define	ETHER_TYPE_LEN		2
+#endif
+
+/*
+ * The number of bytes in the trailing CRC field.
+ */
+#ifndef	ETHER_CRC_LEN
+#define	ETHER_CRC_LEN		4
+#endif
+
+/*
+ * The length of the combined header.
+ */
+#ifndef	ETHER_HDR_LEN
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN*2+ETHER_TYPE_LEN)
+#endif
+
+/*
+ * The minimum packet length.
+ */
+#ifndef ETHER_MIN_LEN
+#define	ETHER_MIN_LEN		64
+#endif
+
+/*
+ * The minimum packet user data length.
+ */
+#ifndef ETHER_MIN_DATA
+#define	ETHER_MIN_DATA		46
+#endif
+
+/*
+ * The maximum packet length.
+ */
+#ifndef ETHER_MAX_LEN
+#define	ETHER_MAX_LEN		1518
+#endif
+
+/*
+ * The maximum packet user data length.
+ */
+#define	ETHER_MAX_DATA		1500
+
+/*
+ * Used to uniquely identify a 802.1q VLAN-tagged header.
+ */
+#define	VLAN_TAG			0x8100
+
+/*
+ * Located after dest & src address in ether header.
+ */
+#define VLAN_FIELDS_OFFSET		(ETHER_ADDR_LEN * 2)
+
+/*
+ * 4 bytes of vlan field info.
+ */
+#define VLAN_FIELDS_SIZE		4
+
+/* location of bits in 16-bit vlan fields */
+#define VLAN_PRI_SHIFT		13	/* user priority */
+#define VLAN_CFI_SHIFT		12	/* canonical format indicator bit */
+
+/* 3 bits of priority */
+#define VLAN_PRI_MASK			7
+/* 12 bits of vlan identfier (VID) */
+#define VLAN_VID_MASK		0xFFF	/* VLAN identifier (VID) field */
+
+struct  vlan_tags {
+	uint16  tag_type;	/* 0x8100 for VLAN */
+	uint16  tag_control;	/* prio | cfi | vid */
+} PACKED ;
+
+/* 802.1X ethertype */
+
+#define	ETHER_TYPE_IP		0x0800		/* IP */
+#define	ETHER_TYPE_BRCM		0x886c		/* Broadcom Corp. */
+#define	ETHER_TYPE_802_1X	0x888e		/* 802.1x */
+
+#define	ETHER_BRCM_SUBTYPE_LEN	4		/* Broadcom 4byte subtype follows ethertype */
+#define	ETHER_BRCM_CRAM		0x1		/* Broadcom subtype cram protocol */
+
+/*
+ * A macro to validate a length with
+ */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+#ifndef __NET_ETHERNET_H
+#ifndef __INCif_etherh     /* Quick and ugly hack for VxWorks */
+/*
+ * Structure of a 10Mb/s Ethernet header.
+ */
+struct	ether_header {
+	uint8	ether_dhost[ETHER_ADDR_LEN];
+	uint8	ether_shost[ETHER_ADDR_LEN];
+	uint16	ether_type;
+} PACKED ;
+
+/*
+ * Structure of a 48-bit Ethernet address.
+ */
+struct	ether_addr {
+	uint8 octet[ETHER_ADDR_LEN];
+} PACKED ;
+#endif
+#endif
+
+/*
+ * Takes a pointer, returns true if a 48-bit multicast address
+ * (including broadcast, since it is all ones)
+ */
+#define ETHER_ISMULTI(ea) (((uint8 *)(ea))[0] & 1)
+
+/*
+ * Takes a pointer, returns true if a 48-bit broadcast (all ones)
+ */
+#define ETHER_ISBCAST(ea) ((((uint8 *)(ea))[0] &		\
+			    ((uint8 *)(ea))[1] &		\
+			    ((uint8 *)(ea))[2] &		\
+			    ((uint8 *)(ea))[3] &		\
+			    ((uint8 *)(ea))[4] &		\
+			    ((uint8 *)(ea))[5]) == 0xff)
+
+static const struct ether_addr ether_bcast = {{255, 255, 255, 255, 255, 255}};
+
+/*
+ * Takes a pointer, returns true if a 48-bit null address (all zeros)
+ */
+#define ETHER_ISNULLADDR(ea) ((((uint8 *)(ea))[0] |		\
+			    ((uint8 *)(ea))[1] |		\
+			    ((uint8 *)(ea))[2] |		\
+			    ((uint8 *)(ea))[3] |		\
+			    ((uint8 *)(ea))[4] |		\
+			    ((uint8 *)(ea))[5]) == 0)
+
+/* Differentiated Services Codepoint - lower 6 bits of tos in iphdr */
+#define	DSCP_PRI_MASK		0x3F		/* bits 0-6 */
+#define	DSCP_WME_PRI_MASK	0x38		/* bits 3-6 */
+#define	DSCP_WME_PRI_SHIFT	3
+
+#undef PACKED
+
+#endif /* _NET_ETHERNET_H_ */

Property changes on: include/proto/ethernet.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/wlioctl.h
===================================================================
--- include/wlioctl.h	(revision 0)
+++ include/wlioctl.h	(revision 7299)
@@ -0,0 +1,1098 @@
+/*
+ * Custom OID/ioctl definitions for
+ * Broadcom 802.11abg Networking Device Driver
+ *
+ * Definitions subject to change without notice.
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: wlioctl.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#ifndef _wlioctl_h_
+#define	_wlioctl_h_
+
+#include <typedefs.h>
+#include <proto/ethernet.h>
+#include <proto/802.11.h>
+
+#if defined(__GNUC__)
+#define	PACKED	__attribute__((packed))
+#else
+#define	PACKED
+#endif
+
+#define WLC_ESSID_MAX_SIZE	32
+
+/* EZP */
+#define WLC_IOCTL_SMLEN     256     /* "small" length ioctl buffer required */
+
+
+#define WL_NUMRATES		255	/* max # of rates in a rateset */
+
+typedef struct wl_rateset {
+	uint32	count;			/* # rates in this set */
+	uint8	rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+} wl_rateset_t;
+
+#define WL_CHANSPEC_CHAN_MASK	0x0fff
+#define WL_CHANSPEC_BAND_MASK	0xf000
+#define WL_CHANSPEC_BAND_SHIFT	12
+#define WL_CHANSPEC_BAND_A	0x1000
+#define WL_CHANSPEC_BAND_B	0x2000
+
+/*
+ * Per-bss information structure.
+ */
+
+#define	WL_LEGACY_BSS_INFO_VERSION	106	/* an older supported version of wl_bss_info struct */
+#define	WL_BSS_INFO_VERSION		107	/* current version of wl_bss_info struct */
+
+typedef struct wl_bss_info106 {
+	uint		version;	/* version field */
+	struct ether_addr BSSID;
+	uint8		SSID_len;
+	uint8		SSID[32];
+	uint8		Privacy;	/* 0=No WEP, 1=Use WEP */
+	int16		RSSI;		/* receive signal strength (in dBm) */
+	uint16		beacon_period;	/* units are Kusec */
+	uint16		atim_window;	/* units are Kusec */
+	uint8		channel;	/* Channel no. */
+	int8		infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
+	struct {
+		uint	count;		/* # rates in this set */
+		uint8	rates[12];	/* rates in 500kbps units w/hi bit set if basic */
+	} rateset;			/* supported rates */
+        uint8           dtim_period;    /* DTIM period */
+	int8		phy_noise;	/* noise right after tx (in dBm) */
+	uint16		capability;	/* Capability information */
+	struct dot11_bcn_prb *prb;	/* probe response frame (ioctl na) */
+	uint16		prb_len;	/* probe response frame length (ioctl na) */
+	struct {
+		uint8 supported;	/* wpa supported */
+		uint8 multicast;	/* multicast cipher */
+		uint8 ucount;		/* count of unicast ciphers */
+		uint8 unicast[4];	/* unicast ciphers */
+		uint8 acount;		/* count of auth modes */
+		uint8 auth[4];		/* Authentication modes */
+	} wpa;
+} wl_bss_info106_t;
+
+typedef struct wl_bss_info {
+	uint32		version;	/* version field */
+	uint32		length;		/* byte length of data in this record, starting at version and including IEs */
+	struct ether_addr BSSID;
+	uint16		beacon_period;	/* units are Kusec */
+	uint16		capability;	/* Capability information */
+	uint8		SSID_len;
+	uint8		SSID[32];
+	struct {
+		uint	count;		/* # rates in this set */
+		uint8	rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+	} rateset;			/* supported rates */
+	uint8		channel;	/* Channel no. */
+	uint16		atim_window;	/* units are Kusec */
+        uint8           dtim_period;    /* DTIM period */
+	int16		RSSI;		/* receive signal strength (in dBm) */
+	int8		phy_noise;	/* noise (in dBm) */
+	uint32		ie_length;	/* byte length of Information Elements */
+	/* variable length Information Elements */
+} wl_bss_info_t;
+
+typedef struct wlc_ssid {
+	uint32		SSID_len;
+	uchar		SSID[32];
+} wlc_ssid_t;
+
+typedef struct wl_scan_params {
+	wlc_ssid_t ssid;	/* default is {0, ""} */
+	struct ether_addr bssid;/* default is bcast */
+	int8 bss_type;		/* default is any, DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT */
+	int8 scan_type;		/* -1 use default, DOT11_SCANTYPE_ACTIVE/PASSIVE */
+	int32 nprobes;		/* -1 use default, number of probes per channel */
+	int32 active_time;	/* -1 use default, dwell time per channel for active scanning */
+	int32 passive_time;	/* -1 use default, dwell time per channel for passive scanning */
+	int32 home_time;	/* -1 use default, dwell time for the home channel between channel scans */
+	int32 channel_num;	/* 0 use default (all available channels), count of channels in channel_list */
+	uint16 channel_list[1];	/* list of chanspecs */
+} wl_scan_params_t;
+/* size of wl_scan_params not including variable length array */
+#define WL_SCAN_PARAMS_FIXED_SIZE 64
+
+typedef struct wl_scan_results {
+	uint32 buflen;
+	uint32 version;
+	uint32 count;
+	wl_bss_info_t bss_info[1];
+} wl_scan_results_t;
+/* size of wl_scan_results not including variable length array */
+#define WL_SCAN_RESULTS_FIXED_SIZE 12
+
+/* uint32 list */
+typedef struct wl_uint32_list {
+	/* in - # of elements, out - # of entries */
+	uint32 count;
+	/* variable length uint32 list */
+	uint32 element[1];
+} wl_uint32_list_t;
+
+#define WLC_CNTRY_BUF_SZ        4       /* Country string is 3 bytes + NULL */
+
+typedef struct wl_channels_in_country {
+	uint32 buflen;
+	uint32 band;
+	char country_abbrev[WLC_CNTRY_BUF_SZ];
+	uint32 count;
+	uint32 channel[1];
+} wl_channels_in_country_t;
+
+typedef struct wl_country_list {
+	uint32 buflen;
+	uint32 band_set;
+	uint32 band;
+	uint32 count;
+	char country_abbrev[1];
+} wl_country_list_t;
+
+#define WL_RM_TYPE_BASIC	1
+#define WL_RM_TYPE_CCA		2
+#define WL_RM_TYPE_RPI		3
+
+#define WL_RM_FLAG_PARALLEL	(1<<0)
+
+#define WL_RM_FLAG_LATE		(1<<1)
+#define WL_RM_FLAG_INCAPABLE	(1<<2)
+#define WL_RM_FLAG_REFUSED	(1<<3)
+
+typedef struct wl_rm_req_elt {
+	int8	type;
+	int8	flags;
+	uint16	chanspec;
+	uint32	token;		/* token for this measurement */
+	uint32	tsf_h;		/* TSF high 32-bits of Measurement start time */
+	uint32	tsf_l;		/* TSF low 32-bits */
+	uint32	dur;		/* TUs */
+} wl_rm_req_elt_t;
+
+typedef struct wl_rm_req {
+	uint32	token;		/* overall measurement set token */
+	uint32	count;		/* number of measurement reqests */
+	wl_rm_req_elt_t	req[1];	/* variable length block of requests */
+} wl_rm_req_t;
+#define WL_RM_REQ_FIXED_LEN	8
+
+typedef struct wl_rm_rep_elt {
+	int8	type;
+	int8	flags;
+	uint16	chanspec;
+	uint32	token;		/* token for this measurement */
+	uint32	tsf_h;		/* TSF high 32-bits of Measurement start time */
+	uint32	tsf_l;		/* TSF low 32-bits */
+	uint32	dur;		/* TUs */
+	uint32	len;		/* byte length of data block */
+	uint8	data[1];	/* variable length data block */
+} wl_rm_rep_elt_t;
+#define WL_RM_REP_ELT_FIXED_LEN	24	/* length excluding data block */
+
+#define WL_RPI_REP_BIN_NUM 8
+typedef struct wl_rm_rpi_rep {
+	uint8	rpi[WL_RPI_REP_BIN_NUM];
+	int8	rpi_max[WL_RPI_REP_BIN_NUM];
+} wl_rm_rpi_rep_t;
+
+typedef struct wl_rm_rep {
+	uint32	token;		/* overall measurement set token */
+	uint32	len;		/* length of measurement report block */
+	wl_rm_rep_elt_t	rep[1];	/* variable length block of reports */
+} wl_rm_rep_t;
+#define WL_RM_REP_FIXED_LEN	8
+
+
+#define WLC_MAX_KEY_SIZE	32	/* max size of any key */
+#define WLC_MAX_IV_SIZE		16	/* max size of any IV */
+#define WLC_EXT_IV_FLAG		(1<<5)	/* flag to indicate IV is > 4 bytes */
+#define WLC_MAX_DEFAULT_KEYS	4	/* # of default WEP keys */
+#define WLC_MAX_KEYS		54	/* Max # of WEP keys */
+#define WLC_WEP1_KEY_SIZE	5	/* max size of any WEP key */
+#define WLC_WEP1_KEY_HEX_SIZE	10	/* size of WEP key in hex. */
+#define WLC_WEP128_KEY_SIZE	13	/* max size of any WEP key */
+#define WLC_WEP128_KEY_HEX_SIZE	26	/* size of WEP key in hex. */
+#define WLC_TKIP_MIC_SIZE	8	/* size of TKIP MIC */
+#define WLC_TKIP_EOM_SIZE	7	/* max size of TKIP EOM */
+#define WLC_TKIP_EOM_FLAG	0x5a	/* TKIP EOM flag byte */
+#define WLC_TKIP_KEY_SIZE	32	/* size of any TKIP key */
+#define WLC_TKIP_MIC_AUTH_TX	16	/* offset to Authenticator MIC TX key */
+#define WLC_TKIP_MIC_AUTH_RX	24	/* offset to Authenticator MIC RX key */
+#define WLC_TKIP_MIC_SUP_RX	16	/* offset to Supplicant MIC RX key */
+#define WLC_TKIP_MIC_SUP_TX	24	/* offset to Supplicant MIC TX key */
+#define WLC_TKIP_P1_KEY_SIZE	10	/* size of TKHash Phase1 output, in bytes */
+#define WLC_TKIP_P2_KEY_SIZE	16	/* size of TKHash Phase2 output */
+#define WLC_AES_KEY_SIZE	16	/* size of AES key */
+
+
+typedef enum sup_auth_status {
+	WLC_SUP_DISCONNECTED = 0,
+	WLC_SUP_CONNECTING,
+	WLC_SUP_IDREQUIRED,
+	WLC_SUP_AUTHENTICATING,
+	WLC_SUP_AUTHENTICATED,
+	WLC_SUP_KEYXCHANGE,
+	WLC_SUP_KEYED
+} sup_auth_status_t;
+
+/* Enumerate crypto algorithms */
+#define	CRYPTO_ALGO_OFF			0
+#define	CRYPTO_ALGO_WEP1		1
+#define	CRYPTO_ALGO_TKIP		2
+#define	CRYPTO_ALGO_WEP128		3
+#define CRYPTO_ALGO_AES_CCM		4
+#define CRYPTO_ALGO_AES_OCB_MSDU	5
+#define CRYPTO_ALGO_AES_OCB_MPDU	6
+#define CRYPTO_ALGO_NALG		7
+
+#define WSEC_GEN_MIC_ERROR	0x0001
+#define WSEC_GEN_REPLAY		0x0002
+
+#define WL_SOFT_KEY	(1 << 0)	/* Indicates this key is using soft encrypt */
+#define WL_PRIMARY_KEY	(1 << 1)	/* Indicates this key is the primary (ie tx) key */
+#define WL_KF_RES_4	(1 << 4)	/* Reserved for backward compat */
+#define WL_KF_RES_5	(1 << 5)	/* Reserved for backward compat */
+
+
+typedef struct wlc_tkip_info {
+	uint16		phase1[WLC_TKIP_P1_KEY_SIZE/sizeof(uint16)];	/* tkhash phase1 result */
+	uint8		phase2[WLC_TKIP_P2_KEY_SIZE];	/* tkhash phase2 result */
+	uint32		micl;
+	uint32		micr;
+} tkip_info_t;
+
+typedef struct _wsec_iv {
+	uint32		hi;	/* upper 32 bits of IV */
+	uint16		lo;	/* lower 16 bits of IV */
+} wsec_iv_t;
+
+typedef struct wsec_key {
+	uint32		index;		/* key index */
+	uint32		len;		/* key length */
+	uint8		data[WLC_MAX_KEY_SIZE];	/* key data */
+	tkip_info_t	tkip_tx;	/* tkip transmit state */
+	tkip_info_t	tkip_rx;	/* tkip receive state */
+	uint32		algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	uint32		flags;		/* misc flags */
+	uint32 		algo_hw;	/* cache for hw register*/
+	uint32 		aes_mode;	/* cache for hw register*/
+	int		iv_len;		/* IV length */		
+	int		iv_initialized;	/* has IV been initialized already? */		
+	int		icv_len;	/* ICV length */
+	wsec_iv_t	rxiv;		/* Rx IV */
+	wsec_iv_t	txiv;		/* Tx IV */
+	struct ether_addr ea;		/* per station */
+} wsec_key_t;
+
+
+
+typedef struct wl_wsec_key {
+	uint32		index;		/* key index */
+	uint32		len;		/* key length */
+	uint8		data[DOT11_MAX_KEY_SIZE];	/* key data */
+	uint32		pad_1[18];
+	uint32		algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	uint32		flags;		/* misc flags */
+	uint32 		pad_2[2];
+	int		pad_3;
+	int		iv_initialized;	/* has IV been initialized already? */		
+	int		pad_4;
+	/* Rx IV */
+	struct {
+		uint32	hi;		/* upper 32 bits of IV */
+		uint16	lo;		/* lower 16 bits of IV */
+	} rxiv;
+	uint32		pad_5[2];
+	struct ether_addr ea;		/* per station */
+} wl_wsec_key_t;
+
+/* For use with wlc_wep_key.flags */
+#define WSEC_PRIMARY_KEY	(1 << 1)	/* Indicates this key is the primary (ie tx) key */
+#define WSEC_TKIP_ERROR		(1 << 2)	/* Provoke deliberate error */
+
+#define WSEC_MIN_PSK_LEN	8
+#define WSEC_MAX_PSK_LEN	64
+
+/* Flag for key material needing passhash'ing */
+#define WSEC_PASSPHRASE		(1<<0)
+
+/* recepticle for WLC_SET_WSEC_PMK parameter */
+typedef struct {
+	ushort	key_len;		/* octets in key material */
+	ushort	flags;			/* key handling qualification */
+	uint8	key[WSEC_MAX_PSK_LEN];	/* PMK material */
+} wsec_pmk_t;
+
+/* wireless security bitvec */
+#define WEP_ENABLED		1
+#define TKIP_ENABLED		2
+#define AES_ENABLED		4
+#define WSEC_SWFLAG		8
+
+#define WSEC_SW(wsec)		((wsec) & WSEC_SWFLAG)
+#define WSEC_HW(wsec)		(!WSEC_SW(wsec))
+#define WSEC_WEP_ENABLED(wsec)	((wsec) & WEP_ENABLED)
+#define WSEC_TKIP_ENABLED(wsec)	((wsec) & TKIP_ENABLED)
+#define WSEC_AES_ENABLED(wsec)	((wsec) & AES_ENABLED)
+#define WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
+
+
+/* wireless authentication bit vector */
+#define WPA_ENABLED	1
+#define PSK_ENABLED	2
+
+#define WAUTH_WPA_ENABLED(wauth)	((wauth) & WPA_ENABLED)
+#define WAUTH_PSK_ENABLED(wauth)	((wauth) & PSK_ENABLED)
+#define WAUTH_ENABLED(wauth)		((wauth) & (WPA_ENABLED | PSK_ENABLED))
+
+/* group/mcast cipher */
+#define WPA_MCAST_CIPHER(wsec)	(((wsec) & TKIP_ENABLED) ? WPA_CIPHER_TKIP : \
+				((wsec) & AES_ENABLED) ? WPA_CIPHER_AES_CCM : \
+				WPA_CIPHER_NONE)
+
+
+typedef struct wl_led_info {
+	uint32		index;		/* led index */
+	uint32		behavior;
+	bool		activehi;
+} wl_led_info_t;
+
+/*
+ * definitions for driver messages passed from WL to NAS.
+ */
+/* Use this to recognize wpa and 802.1x driver messages. */
+static const uint8 wl_wpa_snap_template[] =
+	{ 0xaa, 0xaa, 0x03, 0x00, 0x90, 0x4c };
+
+#define WL_WPA_MSG_IFNAME_MAX	16
+
+/* WPA driver message */
+typedef struct wl_wpa_header {
+	struct ether_header eth;
+	struct dot11_llc_snap_header snap;
+	uint8 version;
+	uint8 type;
+	/* version 2 additions */
+	char ifname[WL_WPA_MSG_IFNAME_MAX];
+	/* version specific data */
+	/* uint8 data[1]; */
+} wl_wpa_header_t PACKED;
+
+/*
+ * definitions for 802.2 messages passed from WL to NAS.
+ */
+/* This seems not to be defined outside the kernel on linux. */
+#ifndef ETH_P_802_2
+#define ETH_P_802_2		4
+#endif
+
+#define WL_WPA_HEADER_LEN	(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN + 2 + WL_WPA_MSG_IFNAME_MAX)
+
+/* WPA driver message ethertype - private between wlc and nas */
+#define WL_WPA_ETHER_TYPE	0x9999
+
+/* WPA driver message current version */
+#define WL_WPA_MSG_VERSION	2
+
+/* Type field values for the 802.2 driver messages for WPA. */
+#define WLC_ASSOC_MSG		1
+#define WLC_DISASSOC_MSG	2
+#define WLC_PTK_MIC_MSG		3
+#define WLC_GTK_MIC_MSG		4
+
+/* Use this to recognize 802.2 driver messages. */
+static const uint8 wpa_snap_template[] =
+	{ 0xaa, 0xaa, 0x03, 0x00, 0x90, 0x4c };
+
+
+/* 802.1x driver message */
+typedef struct wl_eapol_header {
+	struct ether_header eth;
+	struct dot11_llc_snap_header snap;
+	uint8 version;
+	uint8 reserved;
+	char ifname[WL_WPA_MSG_IFNAME_MAX];
+	/* version specific data */
+	/* uint8 802_1x_msg[1]; */
+} wl_eapol_header_t PACKED;
+
+#define WL_EAPOL_HEADER_LEN	(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN + 2 + WL_WPA_MSG_IFNAME_MAX)
+
+/* 802.1x driver message ethertype - private between wlc and nas */
+#define WL_EAPOL_ETHER_TYPE	0x999A
+
+/* 802.1x driver message current version */
+#define WL_EAPOL_MSG_VERSION	1
+
+/* srom read/write struct passed through ioctl */
+typedef struct {
+	uint   byteoff;		/* byte offset */
+	uint   nbytes;		/* number of bytes */
+	uint16 buf[1];
+} srom_rw_t;
+
+/* R_REG and W_REG struct passed through ioctl */
+typedef struct {
+	uint32	byteoff;	/* byte offset of the field in d11regs_t */
+	uint32	val;		/* read/write value of the field */
+	uint32	size;		/* sizeof the field */
+} rw_reg_t;
+
+/* Structure used by GET/SET_ATTEN ioctls */
+typedef struct {
+	uint16	auto_ctrl;	/* 1: Automatic control, 0: overriden */
+	uint16	bb;		/* Baseband attenuation */
+	uint16	radio;		/* Radio attenuation */
+	uint16	txctl1;		/* Radio TX_CTL1 value */
+} atten_t;
+
+/* Used to get specific STA parameters */ 
+typedef struct {
+	uint32	val;
+	struct ether_addr ea;
+} scb_val_t;
+
+/* callback registration data types */
+
+typedef struct _mac_event_params {
+	uint msg;
+	struct ether_addr *addr;
+	uint result;
+	uint status; 
+	uint auth_type;
+} mac_event_params_t;
+
+typedef struct _mic_error_params {
+	struct ether_addr *ea;
+	bool group;
+	bool flush_txq;
+} mic_error_params_t;
+
+typedef enum _wl_callback {
+	WL_MAC_EVENT_CALLBACK = 0,
+	WL_LINK_UP_CALLBACK,
+	WL_LINK_DOWN_CALLBACK,
+	WL_MIC_ERROR_CALLBACK,
+	WL_LAST_CALLBACK
+} wl_callback_t;
+
+typedef struct _callback {
+	void (*fn)(void *, void *);
+	void *context;
+} callback_t;
+
+typedef struct _scan_callback {
+	void (*fn)(void *);
+	void *context;
+} scan_callback_t;
+
+/* used to register an arbitrary callback via the IOCTL interface */
+typedef struct _set_callback {
+	int index;
+	callback_t callback;
+} set_callback_t;
+
+
+
+/* Event data type */
+typedef struct {
+	uint msg;			/* Message (see below) */
+	struct ether_addr *addr;	/* Station address (if applicable) */
+	uint status;			/* Status code (see below) */
+	uint reason;			/* Reason code (if applicable) */
+	uint auth_type;			/* WLC_E_AUTH */
+	bool link;			/* WLC_E_LINK */
+	bool group;			/* WLC_E_MIC_ERROR */
+	bool flush_txq;			/* WLC_E_MIC_ERROR */
+} wlc_event_t;
+
+typedef struct {
+	uint16		ver;	/* version of this struct */
+	uint16		cap;	/* sta's advertized capabilities */
+	uint32 		flags;	/* flags defined below */
+	uint32		idle;	/* time since data pkt rx'd from sta */
+	struct ether_addr	ea;	/* Station address */
+	wl_rateset_t	rateset;	/* rateset in use */
+} sta_info_t;
+
+#define WL_STA_INFO_LEN	300
+#define WL_STA_VER	1
+
+/* flags fields */
+#define WL_STA_BRCM	0x01
+#define WL_STA_WME	0x02
+#define WL_STA_ABCAP	0x04
+#define WL_STA_AUTHE	0x08 
+#define WL_STA_ASSOC	0x10 
+#define WL_STA_AUTHO	0x20 
+
+/* Event messages */
+#define WLC_E_SET_SSID		1
+#define WLC_E_JOIN		2
+#define WLC_E_START		3
+#define WLC_E_AUTH		4
+#define WLC_E_AUTH_IND		5
+#define WLC_E_DEAUTH		6
+#define WLC_E_DEAUTH_IND	7
+#define WLC_E_ASSOC		8
+#define WLC_E_ASSOC_IND		9
+#define WLC_E_REASSOC		10
+#define WLC_E_REASSOC_IND	11
+#define WLC_E_DISASSOC		12
+#define WLC_E_DISASSOC_IND	13
+#define WLC_E_QUIET_START	14	/* 802.11h Quiet period started */
+#define WLC_E_QUIET_END		15	/* 802.11h Quiet period ended */
+#define WLC_E_GOT_BEACONS	16	
+#define WLC_E_LINK		17	/* Link indication */
+#define WLC_E_MIC_ERROR		18	/* TKIP MIC error occurred */
+#define WLC_E_NDIS_LINK		19	/* NDIS style link indication */
+#define WLC_E_ROAM		20
+#define WLC_E_LAST		21
+
+/* Event status codes */
+#define WLC_E_STATUS_SUCCESS		0
+#define WLC_E_STATUS_FAIL		1
+#define WLC_E_STATUS_TIMEOUT		2
+#define WLC_E_STATUS_NO_NETWORKS	3
+#define WLC_E_STATUS_ABORT		4
+
+typedef struct wlc_event_cb {
+	uint msg;				/* Event message or 0 for all */
+	void (*fn)(void *, wlc_event_t *);	/* Callback function */
+	void *context;				/* Passed to callback function */
+	struct wlc_event_cb *next;		/* Next in the chain */
+} wlc_event_cb_t;
+
+/*
+ * Country locale determines which channels are available to us.
+ */
+typedef enum _wlc_locale {
+	WLC_WW = 0,	/* Worldwide */
+	WLC_THA,	/* Thailand */
+	WLC_ISR,	/* Israel */
+	WLC_JDN,	/* Jordan */
+	WLC_PRC,	/* China */
+	WLC_JPN,	/* Japan */
+	WLC_FCC,	/* USA */
+	WLC_EUR,	/* Europe */
+	WLC_USL,	/* US Low Band only */
+	WLC_JPH,	/* Japan High Band only */
+	WLC_ALL,	/* All the channels in this band */
+	WLC_11D,	/* Represents locale recieved by 11d beacons */
+	WLC_LAST_LOCALE,
+	WLC_UNDEFINED_LOCALE = 0xf
+} wlc_locale_t;
+
+/* channel encoding */
+typedef struct channel_info {
+	int hw_channel;
+	int target_channel;
+	int scan_channel;
+} channel_info_t;
+
+/* For ioctls that take a list of MAC addresses */
+struct maclist {
+	uint count;			/* number of MAC addresses */
+	struct ether_addr ea[1];	/* variable length array of MAC addresses */
+};
+
+/* get pkt count struct passed through ioctl */
+typedef struct get_pktcnt {
+	uint rx_good_pkt;
+	uint rx_bad_pkt;
+	uint tx_good_pkt;
+	uint tx_bad_pkt;
+} get_pktcnt_t;
+
+/* Linux network driver ioctl encoding */
+typedef struct wl_ioctl {
+	uint cmd;	/* common ioctl definition */
+	void *buf;	/* pointer to user buffer */
+	uint len;	/* length of user buffer */
+	bool set;	/* get or set request (optional) */
+	uint used;	/* bytes read or written (optional) */
+	uint needed;	/* bytes needed (optional) */
+} wl_ioctl_t;
+
+/* 
+ * Structure for passing hardware and software 
+ * revision info up from the driver. 
+ */
+typedef struct wlc_rev_info {
+	uint		vendorid;	/* PCI vendor id */
+	uint		deviceid;	/* device id of chip */
+	uint		radiorev;	/* radio revision */
+	uint		chiprev;	/* chip revision */
+	uint		corerev;	/* core revision */
+	uint		boardid;	/* board identifier (usu. PCI sub-device id) */
+	uint		boardvendor;	/* board vendor (usu. PCI sub-vendor id) */
+	uint		boardrev;	/* board revision */
+	uint		driverrev;	/* driver version */
+	uint		ucoderev;	/* microcode version */
+	uint		bus;		/* bus type */
+	uint        chipnum;    /* chip number */
+} wlc_rev_info_t;
+
+/* check this magic number */
+#define WLC_IOCTL_MAGIC		0x14e46c77
+
+/* bump this number if you change the ioctl interface */
+#define WLC_IOCTL_VERSION	1
+
+/* maximum length buffer required */
+#define WLC_IOCTL_MAXLEN	8192
+
+/* common ioctl definitions */
+#define WLC_GET_MAGIC				0
+#define WLC_GET_VERSION				1
+#define WLC_UP					2
+#define WLC_DOWN				3
+#define WLC_GET_LOOP				4
+#define WLC_SET_LOOP				5
+#define WLC_DUMP				6
+#define WLC_GET_MSGLEVEL			7
+#define WLC_SET_MSGLEVEL			8
+#define WLC_GET_PROMISC				9
+#define WLC_SET_PROMISC				10
+#define WLC_OBSOLETE				11 
+#define WLC_GET_RATE				12
+#define WLC_SET_RATE				13
+#define WLC_GET_INSTANCE			14
+#define WLC_GET_FRAG				15
+#define WLC_SET_FRAG				16
+#define WLC_GET_RTS				17
+#define WLC_SET_RTS				18
+#define WLC_GET_INFRA				19
+#define WLC_SET_INFRA				20
+#define WLC_GET_AUTH				21
+#define WLC_SET_AUTH				22
+#define WLC_GET_BSSID				23
+#define WLC_SET_BSSID				24
+#define WLC_GET_SSID				25
+#define WLC_SET_SSID				26
+#define WLC_RESTART				27
+#define WLC_DUMP_SCB				28 
+#define WLC_GET_CHANNEL				29
+#define WLC_SET_CHANNEL				30
+#define WLC_GET_SRL				31
+#define WLC_SET_SRL				32
+#define WLC_GET_LRL				33
+#define WLC_SET_LRL				34
+#define WLC_GET_PLCPHDR				35
+#define WLC_SET_PLCPHDR				36
+#define WLC_GET_RADIO				37
+#define WLC_SET_RADIO				38
+#define WLC_GET_PHYTYPE				39
+#define WLC_DUMP_RATE				40
+#define WLC_SET_RATE_PARAMS			41
+#define WLC_GET_WEP				42
+#define WLC_SET_WEP				43
+#define WLC_GET_KEY				44
+#define WLC_SET_KEY				45
+#define WLC_GET_REGULATORY			46
+#define WLC_SET_REGULATORY			47
+#define WLC_GET_PASSIVE				48	/* added by nbd */
+#define WLC_SET_PASSIVE				49	/* added by nbd */
+#define WLC_SCAN				50
+#define WLC_SCAN_RESULTS			51
+#define WLC_DISASSOC				52
+#define WLC_REASSOC				53
+#define WLC_GET_ROAM_TRIGGER			54
+#define WLC_SET_ROAM_TRIGGER			55
+#define WLC_GET_ROAM_DELTA			56
+#define WLC_SET_ROAM_DELTA			57
+#define WLC_GET_ROAM_SCAN_PERIOD		58
+#define WLC_SET_ROAM_SCAN_PERIOD		59
+#define WLC_EVM					60
+#define WLC_GET_TXANT				61
+#define WLC_SET_TXANT				62
+#define WLC_GET_ANTDIV				63
+#define WLC_SET_ANTDIV				64
+#define WLC_GET_TXPWR				65
+#define WLC_SET_TXPWR				66
+#define WLC_GET_CLOSED				67
+#define WLC_SET_CLOSED				68
+#define WLC_GET_MACLIST				69
+#define WLC_SET_MACLIST				70
+#define WLC_GET_RATESET				71
+#define WLC_SET_RATESET				72
+#define WLC_GET_LOCALE				73
+#define WLC_SET_LOCALE				74
+#define WLC_GET_BCNPRD				75
+#define WLC_SET_BCNPRD				76
+#define WLC_GET_DTIMPRD				77
+#define WLC_SET_DTIMPRD				78
+#define WLC_GET_SROM				79
+#define WLC_SET_SROM				80
+#define WLC_GET_WEP_RESTRICT			81
+#define WLC_SET_WEP_RESTRICT			82
+#define WLC_GET_COUNTRY				83
+#define WLC_SET_COUNTRY				84
+#define WLC_GET_PM				85
+#define WLC_SET_PM				86
+#define WLC_GET_WAKE				87
+#define WLC_SET_WAKE				88
+#define	WLC_GET_D11CNTS				89
+#define WLC_GET_FORCELINK			90	/* ndis only */
+#define WLC_SET_FORCELINK			91	/* ndis only */
+#define WLC_FREQ_ACCURACY			92
+#define WLC_CARRIER_SUPPRESS			93
+#define WLC_GET_PHYREG				94
+#define WLC_SET_PHYREG				95
+#define WLC_GET_RADIOREG			96
+#define WLC_SET_RADIOREG			97
+#define WLC_GET_REVINFO				98
+#define WLC_GET_UCANTDIV			99
+#define WLC_SET_UCANTDIV			100
+#define WLC_R_REG				101
+#define WLC_W_REG				102
+#define WLC_DIAG_LOOPBACK			103
+#define WLC_RESET_D11CNTS			104
+#define WLC_GET_MACMODE				105
+#define WLC_SET_MACMODE				106
+#define WLC_GET_MONITOR				107     /* added by nbd */
+#define WLC_SET_MONITOR				108     /* added by nbd */
+#define WLC_GET_GMODE				109
+#define WLC_SET_GMODE				110
+#define WLC_GET_LEGACY_ERP			111
+#define WLC_SET_LEGACY_ERP			112
+#define WLC_GET_RX_ANT				113
+#define WLC_GET_CURR_RATESET			114	/* current rateset */
+#define WLC_GET_SCANSUPPRESS			115
+#define WLC_SET_SCANSUPPRESS			116
+#define WLC_GET_AP				117
+#define WLC_SET_AP				118
+#define WLC_GET_EAP_RESTRICT			119
+#define WLC_SET_EAP_RESTRICT			120
+#define WLC_SCB_AUTHORIZE			121
+#define WLC_SCB_DEAUTHORIZE			122
+#define WLC_GET_WDSLIST				123
+#define WLC_SET_WDSLIST				124
+#define WLC_GET_ATIM				125
+#define WLC_SET_ATIM				126
+#define WLC_GET_RSSI				127
+#define WLC_GET_PHYANTDIV			128
+#define WLC_SET_PHYANTDIV			129
+#define WLC_AP_RX_ONLY				130
+#define WLC_GET_TX_PATH_PWR			131
+#define WLC_SET_TX_PATH_PWR			132
+#define WLC_GET_WSEC				133
+#define WLC_SET_WSEC				134
+#define WLC_GET_PHY_NOISE			135
+#define WLC_GET_BSS_INFO			136
+#define WLC_GET_PKTCNTS				137
+#define WLC_GET_LAZYWDS				138
+#define WLC_SET_LAZYWDS				139
+#define WLC_GET_BANDLIST			140
+#define WLC_GET_BAND				141
+#define WLC_SET_BAND				142
+#define WLC_SCB_DEAUTHENTICATE			143
+#define WLC_GET_SHORTSLOT			144
+#define WLC_GET_SHORTSLOT_OVERRIDE		145
+#define WLC_SET_SHORTSLOT_OVERRIDE		146
+#define WLC_GET_SHORTSLOT_RESTRICT		147
+#define WLC_SET_SHORTSLOT_RESTRICT		148
+#define WLC_GET_GMODE_PROTECTION		149
+#define WLC_GET_GMODE_PROTECTION_OVERRIDE	150
+#define WLC_SET_GMODE_PROTECTION_OVERRIDE	151
+#define WLC_UPGRADE				152
+#define WLC_GET_MRATE				153
+#define WLC_SET_MRATE				154
+#define WLC_GET_IGNORE_BCNS			155
+#define WLC_SET_IGNORE_BCNS			156
+#define WLC_GET_SCB_TIMEOUT			157
+#define WLC_SET_SCB_TIMEOUT			158
+#define WLC_GET_ASSOCLIST			159
+#define WLC_GET_CLK				160
+#define WLC_SET_CLK				161
+#define WLC_GET_UP				162
+#define WLC_OUT					163
+#define WLC_GET_WPA_AUTH			164
+#define WLC_SET_WPA_AUTH			165
+#define WLC_GET_UCFLAGS				166
+#define WLC_SET_UCFLAGS				167
+#define WLC_GET_PWRIDX				168
+#define WLC_SET_PWRIDX				169
+#define WLC_GET_TSSI				170
+#define WLC_GET_SUP_RATESET_OVERRIDE		171
+#define WLC_SET_SUP_RATESET_OVERRIDE		172
+#define WLC_SET_FAST_TIMER			173
+#define WLC_GET_FAST_TIMER			174
+#define WLC_SET_SLOW_TIMER			175
+#define WLC_GET_SLOW_TIMER			176
+#define WLC_DUMP_PHYREGS			177
+#define WLC_GET_GMODE_PROTECTION_CONTROL	178
+#define WLC_SET_GMODE_PROTECTION_CONTROL	179
+#define WLC_GET_PHYLIST				180
+#define WLC_ENCRYPT_STRENGTH			181	/* ndis only */
+#define WLC_DECRYPT_STATUS			182	/* ndis only */
+#define WLC_GET_KEY_SEQ				183
+#define WLC_GET_SCAN_CHANNEL_TIME		184
+#define WLC_SET_SCAN_CHANNEL_TIME		185
+#define WLC_GET_SCAN_UNASSOC_TIME		186
+#define WLC_SET_SCAN_UNASSOC_TIME		187
+#define WLC_GET_SCAN_HOME_TIME			188
+#define WLC_SET_SCAN_HOME_TIME			189
+#define WLC_GET_SCAN_PASSES			190
+#define WLC_SET_SCAN_PASSES			191
+#define WLC_GET_PRB_RESP_TIMEOUT		192
+#define WLC_SET_PRB_RESP_TIMEOUT		193
+#define WLC_GET_ATTEN				194
+#define WLC_SET_ATTEN				195
+#define WLC_GET_SHMEM				196	/* diag */
+#define WLC_SET_SHMEM				197	/* diag */
+#define WLC_GET_GMODE_PROTECTION_CTS		198
+#define WLC_SET_GMODE_PROTECTION_CTS		199
+#define WLC_SET_TKIP_MIC_FLAG			200
+#define WLC_SCB_DEAUTHENTICATE_FOR_REASON	201
+#define WLC_TKIP_COUNTERMEASURES		202
+#define WLC_GET_PIOMODE				203
+#define WLC_SET_PIOMODE				204
+#define WLC_SET_LED				209
+#define WLC_GET_LED				210
+#define WLC_GET_INTERFERENCE_MODE		211
+#define WLC_SET_INTERFERENCE_MODE		212
+#define WLC_GET_CHANNEL_QA			213
+#define WLC_START_CHANNEL_QA			214
+#define WLC_GET_CHANNEL_SEL			215
+#define WLC_START_CHANNEL_SEL			216
+#define WLC_GET_VALID_CHANNELS			217
+#define WLC_GET_FAKEFRAG			218
+#define WLC_SET_FAKEFRAG			219
+#define WLC_GET_PWROUT_PERCENTAGE		220
+#define WLC_SET_PWROUT_PERCENTAGE		221
+#define WLC_SET_BAD_FRAME_PREEMPT		222
+#define WLC_GET_BAD_FRAME_PREEMPT		223
+#define WLC_SET_LEAP_LIST			224
+#define WLC_GET_LEAP_LIST			225
+#define WLC_GET_CWMIN				226
+#define WLC_SET_CWMIN				227
+#define WLC_GET_CWMAX				228
+#define WLC_SET_CWMAX				229
+#define WLC_GET_WET				230
+#define WLC_SET_WET				231
+#define WLC_GET_KEY_PRIMARY			235
+#define WLC_SET_KEY_PRIMARY			236
+#define WLC_SCAN_WITH_CALLBACK			240
+#define WLC_WDS_GET_REMOTE_HWADDR		246	/* currently handled in wl_linux.c/wl_vx.c */
+#define WLC_SET_CS_SCAN_TIMER			248
+#define WLC_GET_CS_SCAN_TIMER			249
+#define WLC_CURRENT_PWR				256
+#define WLC_GET_CHANNELS_IN_COUNTRY		260
+#define WLC_GET_COUNTRY_LIST			261
+#define WLC_GET_VAR				262	/* get value of named variable */
+#define WLC_SET_VAR				263	/* set named variable to value */
+#define WLC_NVRAM_GET				264
+#define WLC_NVRAM_SET				265
+#define WLC_SET_WSEC_PMK			268
+#define WLC_GET_AUTH_MODE			269
+#define WLC_SET_AUTH_MODE			270
+#define WLC_LAST				273	/* do not change - use get_var/set_var */
+
+/*
+ * Minor kludge alert:
+ * Duplicate a few definitions that irelay requires from epiioctl.h here
+ * so caller doesn't have to include this file and epiioctl.h .
+ * If this grows any more, it would be time to move these irelay-specific
+ * definitions out of the epiioctl.h and into a separate driver common file.
+ */
+#ifndef EPICTRL_COOKIE
+#define EPICTRL_COOKIE		0xABADCEDE
+#endif
+
+/* vx wlc ioctl's offset */
+#define CMN_IOCTL_OFF 0x180
+
+/*
+ * custom OID support
+ *
+ * 0xFF - implementation specific OID
+ * 0xE4 - first byte of Broadcom PCI vendor ID
+ * 0x14 - second byte of Broadcom PCI vendor ID
+ * 0xXX - the custom OID number
+ */
+
+/* begin 0x1f values beyond the start of the ET driver range. */
+#define WL_OID_BASE		0xFFE41420
+
+/* NDIS overrides */
+#define OID_WL_GETINSTANCE	(WL_OID_BASE + WLC_GET_INSTANCE)
+#define OID_WL_GET_FORCELINK	(WL_OID_BASE + WLC_GET_FORCELINK)
+#define OID_WL_SET_FORCELINK	(WL_OID_BASE + WLC_SET_FORCELINK)
+#define	OID_WL_ENCRYPT_STRENGTH	(WL_OID_BASE + WLC_ENCRYPT_STRENGTH)
+#define OID_WL_DECRYPT_STATUS	(WL_OID_BASE + WLC_DECRYPT_STATUS)
+
+#define WL_DECRYPT_STATUS_SUCCESS	1
+#define WL_DECRYPT_STATUS_FAILURE	2
+#define WL_DECRYPT_STATUS_UNKNOWN	3
+
+/* allows user-mode app to poll the status of USB image upgrade */
+#define WLC_UPGRADE_SUCCESS			0
+#define WLC_UPGRADE_PENDING			1
+
+/* Bit masks for radio disabled status - returned by WL_GET_RADIO */
+#define WL_RADIO_SW_DISABLE	(1<<0)
+#define WL_RADIO_HW_DISABLE	(1<<1)
+
+/* Override bit for WLC_SET_TXPWR.  if set, ignore other level limits */
+#define WL_TXPWR_OVERRIDE	(1<<31)
+
+
+/* Bus types */
+#define WL_SB_BUS	0	/* Silicon Backplane */
+#define WL_PCI_BUS	1	/* PCI target */
+#define WL_PCMCIA_BUS	2	/* PCMCIA target */
+
+/* band types */
+#define	WLC_BAND_AUTO		0	/* auto-select */
+#define	WLC_BAND_A		1	/* "a" band (5   Ghz) */
+#define	WLC_BAND_B		2	/* "b" band (2.4 Ghz) */
+
+/* MAC list modes */
+#define WLC_MACMODE_DISABLED	0	/* MAC list disabled */
+#define WLC_MACMODE_DENY	1	/* Deny specified (i.e. allow unspecified) */
+#define WLC_MACMODE_ALLOW	2	/* Allow specified (i.e. deny unspecified) */	
+
+
+/* 54g modes (basic bits may still be overridden) */
+#define GMODE_LEGACY_B		0	/* Rateset: 1b, 2b, 5.5, 11 */
+					/* Preamble: Long */
+					/* Shortslot: Off */
+#define GMODE_AUTO		1	/* Rateset: 1b, 2b, 5.5b, 11b, 18, 24, 36, 54 */
+					/* Extended Rateset: 6, 9, 12, 48 */
+					/* Preamble: Long */
+					/* Shortslot: Auto */
+#define GMODE_ONLY		2	/* Rateset: 1b, 2b, 5.5b, 11b, 18, 24b, 36, 54 */
+					/* Extended Rateset: 6b, 9, 12b, 48 */
+					/* Preamble: Short required */
+					/* Shortslot: Auto */
+#define GMODE_B_DEFERRED	3	/* Rateset: 1b, 2b, 5.5b, 11b, 18, 24, 36, 54 */
+					/* Extended Rateset: 6, 9, 12, 48 */
+					/* Preamble: Long */
+					/* Shortslot: On */
+#define GMODE_PERFORMANCE	4	/* Rateset: 1b, 2b, 5.5b, 6b, 9, 11b, 12b, 18, 24b, 36, 48, 54 */
+					/* Preamble: Short required */
+					/* Shortslot: On and required */
+#define GMODE_LRS		5	/* Rateset: 1b, 2b, 5.5b, 11b */
+					/* Extended Rateset: 6, 9, 12, 18, 24, 36, 48, 54 */
+					/* Preamble: Long */
+					/* Shortslot: Auto */
+#define GMODE_MAX		6
+
+
+/* values for PLCPHdr_override */
+#define WLC_PLCP_AUTO	-1
+#define WLC_PLCP_SHORT	0
+#define WLC_PLCP_LONG	1
+
+/* values for g_protection_override */
+#define WLC_G_PROTECTION_AUTO	-1
+#define WLC_G_PROTECTION_OFF	0
+#define WLC_G_PROTECTION_ON	1
+
+/* values for g_protection_control */
+#define WLC_G_PROTECTION_CTL_OFF	0
+#define WLC_G_PROTECTION_CTL_LOCAL	1
+#define WLC_G_PROTECTION_CTL_OVERLAP	2
+
+/* Values for PM */
+#define PM_OFF	0
+#define PM_MAX	1
+#define PM_FAST 2
+
+/* interference mitigation options */
+#define	INTERFERE_NONE	0	/* off */
+#define	NON_WLAN        1	/* foreign/non 802.11 interference, no auto detect */
+#define	WLAN_MANUAL     2	/* ACI: no auto detection */
+#define	WLAN_AUTO       3	/* ACI: auto - detact */
+
+/* Message levels */
+#define WL_ERROR_VAL		0x0001
+#define WL_TRACE_VAL		0x0002
+#define WL_PRHDRS_VAL		0x0004
+#define WL_PRPKT_VAL		0x0008
+#define WL_INFORM_VAL		0x0010
+#define WL_TMP_VAL		0x0020
+#define WL_OID_VAL		0x0040
+#define WL_RATE_VAL		0x0080
+#define WL_ASSOC_VAL		0x0100
+#define WL_PRUSR_VAL		0x0200
+#define WL_PS_VAL		0x0400
+#define WL_TXPWR_VAL		0x0800
+#define WL_GMODE_VAL		0x1000
+#define WL_DUAL_VAL		0x2000
+#define WL_WSEC_VAL		0x4000
+#define WL_WSEC_DUMP_VAL	0x8000
+#define WL_LOG_VAL		0x10000
+#define WL_NRSSI_VAL		0x20000
+#define WL_LOFT_VAL		0x40000
+#define WL_REGULATORY_VAL	0x80000
+#define WL_ACI_VAL		0x100000
+
+
+/* 802.11h enforcement levels */
+#define SPECT_MNGMT_OFF         0   /* 11h disabled */
+#define SPECT_MNGMT_LOOSE       1   /* Allow scan lists to contain non-11h AP */
+				    /* when 11h is enabled */
+#define SPECT_MNGMT_STRICT      2   /* Prine out non-11h APs from scan list */
+
+
+
+/* max # of leds supported by GPIO (gpio pin# == led index#) */
+#define	WL_LED_NUMGPIO		16	/* gpio 0-15 */
+
+/* led per-pin behaviors */
+#define	WL_LED_OFF		0		/* always off */
+#define	WL_LED_ON		1		/* always on */
+#define	WL_LED_ACTIVITY		2		/* activity */
+#define	WL_LED_RADIO		3		/* radio enabled */
+#define	WL_LED_ARADIO		4		/* 5  Ghz radio enabled */
+#define	WL_LED_BRADIO		5		/* 2.4Ghz radio enabled */
+#define	WL_LED_BGMODE		6		/* on if gmode, off if bmode */
+#define	WL_LED_WI1		7		
+#define	WL_LED_WI2		8		
+#define	WL_LED_WI3		9		
+#define	WL_LED_ASSOC		10		/* associated state indicator */
+#define	WL_LED_INACTIVE		11		/* null behavior (clears default behavior) */
+#define	WL_LED_NUMBEHAVIOR	12
+
+/* led behavior numeric value format */
+#define	WL_LED_BEH_MASK		0x7f		/* behavior mask */
+#define	WL_LED_AL_MASK		0x80		/* activelow (polarity) bit */
+
+
+/* maximum channels */
+#define WL_NUMCHANNELS	64	/* max # of channels in the band */
+
+/* rate check */
+#define WL_RATE_OFDM(r)		(((r) & 0x7f) == 12 || ((r) & 0x7f) == 18 || \
+				 ((r) & 0x7f) == 24 || ((r) & 0x7f) == 36 || \
+				 ((r) & 0x7f) == 48 || ((r) & 0x7f) == 72 || \
+				 ((r) & 0x7f) == 96 || ((r) & 0x7f) == 108)
+
+/* WDS link local endpoint WPA role */
+#define WL_WDS_WPA_ROLE_AUTH	0	/* authenticator */
+#define WL_WDS_WPA_ROLE_SUP	1	/* supplicant */
+#define WL_WDS_WPA_ROLE_AUTO	255	/* auto, based on mac addr value */
+
+/* afterburner_override */
+#define	ABO_AUTO		-1	/* auto - no override */
+#define	ABO_OFF			0	/* force afterburner off */
+#define	ABO_ON			1	/* force afterburner on */
+
+#define GMODE_AFTERBURNER 6
+
+#undef PACKED
+
+#endif /* _wlioctl_h_ */

Property changes on: include/wlioctl.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/cy_conf.h
===================================================================
--- include/cy_conf.h	(revision 0)
+++ include/cy_conf.h	(revision 7299)
@@ -0,0 +1,70 @@
+
+#define	DNSMASQ_SUPPORT	1
+#define	CONFIG_DNSMASQ	y
+#define	UDHCPD_SUPPORT	1
+#define	CONFIG_UDHCPD	y
+#define	UDHCPC_SUPPORT	1
+#define	CONFIG_UDHCPC	y
+#define	PPPOE_SUPPORT	1
+#define	CONFIG_PPPOE	y
+#define	PPTP_SUPPORT	1
+#define	CONFIG_PPTP	y
+#define	L2TP_SUPPORT	1
+#define	CONFIG_L2TP	y
+#define	PPPD_SUPPORT	1
+#define	CONFIG_PPPD	y
+#define	ZEBRA_SUPPORT	1
+#define	CONFIG_ZEBRA	y
+#define	TFTPD_SUPPORT	1
+#define	CONFIG_TFTPD	y
+#define	DDNS_SUPPORT	1
+#define	CONFIG_DDNS	y
+#define	CRON_SUPPORT	1
+#define	CONFIG_CRON	y
+#define	HTTPD_SUPPORT	1
+#define	CONFIG_HTTPD	y
+#define	GET_POST_SUPPORT	1
+#define	CONFIG_GET_POST	y
+
+#if 1
+#define	HEARTBEAT_SUPPORT	1
+#define	CONFIG_HEARTBEAT	y
+#define	MULTICAST_SUPPORT	1
+#define	CONFIG_MULTICAST	y
+#define	SETUP_WIZARD_SUPPORT	1
+#define	CONFIG_SETUP_WIZARD	y
+#define	PARENTAL_CONTROL_SUPPORT	1
+#define	CONFIG_PARENTAL_CONTROL	y
+/* EZP */
+/* #define	HTTPS_SUPPORT	1 */
+#define	CONFIG_HTTPS	y
+#define	EOU_SUPPORT	1
+#define	CONFIG_EOU	y
+#define	EZC_SUPPORT	1
+#define	CONFIG_EZC	y
+#define	WRITE_MAC_SUPPORT	1
+#define	CONFIG_WRITE_MAC	y
+#define	DIAG_SUPPORT	1
+#define	CONFIG_DIAG	y
+#endif
+
+#define	SPEED_BOOSTER_SUPPORT	1
+#define	CONFIG_SPEED_BOOSTER	y
+#define	XBOX_SUPPORT	1
+#define	CONFIG_XBOX	y
+
+#if 0
+#define	MPPPOE_SUPPORT	1
+#define	CONFIG_MPPPOE	y
+#define	UNNUMBERIP_SUPPORT	1
+#define	CONFIG_UNNUMBERIP	y
+#endif
+
+#define	WL_STA_SUPPORT	1
+#define	CONFIG_WL_STA	y
+#define	BACKUP_RESTORE_SUPPORT	1
+#define	CONFIG_BACKUP_RESTORE	y
+#define	PORT_TRIGGER_SUPPORT	1
+#define	CONFIG_PORT_TRIGGER	y
+#define	HW_QOS_SUPPORT	1
+#define	CONFIG_HW_QOS	y

Property changes on: include/cy_conf.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/utils.h
===================================================================
--- include/utils.h	(revision 0)
+++ include/utils.h	(revision 7299)
@@ -0,0 +1,133 @@
+#include <cy_conf.h>
+#include <net/if.h>
+
+extern int diag_led(int type, int act);
+extern int C_led(int i);
+extern int get_single_ip(char *ipaddr, int which);
+extern char *get_mac_from_ip(char *ip);
+extern struct dns_lists *get_dns_list(int no);
+extern int dns_to_resolv(void);
+extern char *get_wan_face(void);
+extern int check_wan_link(int num);
+extern char *get_complete_lan_ip(char *ip);
+extern int get_int_len(int num);
+extern int file_to_buf(char *path, char *buf, int len);
+extern int buf_to_file(char *path, char *buf);
+extern pid_t* find_pid_by_name( char* pidName);
+extern int find_pid_by_ps(char* pidName);
+extern int *find_all_pid_by_ps(char* pidName);
+extern char *find_name_by_proc(int pid);
+extern int get_ppp_pid(char *file);
+extern long convert_ver(char *ver);
+extern int check_flash(void);
+extern int check_action(void);
+extern int check_now_boot(void);
+extern int check_hw_type(void);
+extern int is_exist(char *filename);
+extern void set_ip_forward(char c);
+struct mtu_lists *get_mtu(char *proto);
+extern void set_host_domain_name(void);
+
+extern void encode(char *buf, int len);
+extern void decode(char *buf, int len);
+
+extern int sys_netdev_ioctl(int family, int socket, char *if_name, int cmd, struct ifreq *ifr);
+
+int ct_openlog(const char *ident, int option, int facility, char *log_name);
+void ct_syslog(int level, int enable, const char *fmt,...);
+void ct_logger(int level, const char *fmt,...);
+struct wl_assoc_mac * get_wl_assoc_mac(int *c);
+	
+
+
+enum { DMZ, SESSION, DIAG , WL};
+
+enum { START_LED, STOP_LED };
+
+typedef enum { ACT_IDLE, 
+	       ACT_TFTP_UPGRADE, 
+	       ACT_WEB_UPGRADE, 
+	       ACT_WEBS_UPGRADE, 
+	       ACT_SW_RESTORE, 
+	       ACT_HW_RESTORE } ACTION;
+
+enum { UNKNOWN_BOOT = -1, PMON_BOOT, CFE_BOOT };
+
+/* EZP: enum { BCM4702_CHIP, BCM4712_CHIP, BCM5325E_CHIP }; */
+enum { BCM4702_CHIP, BCM4712_CHIP, BCM5325E_CHIP, BCM4704_BCM5325F_CHIP, BCM5352E_CHIP, NO_DEFINE_CHIP };
+
+enum { FIRST, SECOND };
+
+enum { SYSLOG_LOG=1, SYSLOG_DEBUG, CONSOLE_ONLY, LOG_CONSOLE, DEBUG_CONSOLE };
+
+#define ACTION(cmd)	buf_to_file(ACTION_FILE, cmd)
+
+struct dns_lists {
+        int num_servers;
+        char dns_server[4][16];
+};
+
+#define NOT_USING	0
+#define USING		1
+
+struct wl_assoc_mac
+{
+	char mac[18];
+};
+
+struct mtu_lists {
+        char	*proto;	/* protocol */
+        char	*min;	/* min mtu */
+        char	*max;	/* max mtu */
+};
+
+
+#define PPP_PSEUDO_IP	"10.64.64.64"
+#define PPP_PSEUDO_NM	"255.255.255.255"
+#define PPP_PSEUDO_GW	"10.112.112.112"
+
+#define PING_TMP	"/tmp/ping.log"
+#define TRACEROUTE_TMP	"/tmp/traceroute.log"
+#define MAX_BUF_LEN	254
+
+#define RESOLV_FILE	"/tmp/resolv.conf"
+#define HOSTS_FILE	"/tmp/hosts"
+
+#define LOG_FILE	"/var/log/mess"
+
+#define ACTION_FILE	"/tmp/action"
+
+
+#define split(word, wordlist, next, delim) \
+	for (next = wordlist, \
+	     strncpy(word, next, sizeof(word)), \
+	     word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
+	     next = next ? next + sizeof(delim) - 1 : NULL ; \
+	     strlen(word); \
+	     next = next ? : "", \
+	     strncpy(word, next, sizeof(word)), \
+	     word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
+	     next = next ? next + sizeof(delim) - 1 : NULL)
+
+#define STRUCT_LEN(name)    sizeof(name)/sizeof(name[0])
+
+#define printHEX(str,len) { \
+	int i; \
+	for (i=0 ; i<len ; i++) { \
+		printf("%02X ", (unsigned char)*(str+i)); \
+		if(((i+1)%16) == 0) printf("- "); \
+		if(((i+1)%32) == 0) printf("\n"); \
+	} \
+	printf("\n\n"); \
+}
+
+
+#define printASC(str,len) { \
+	int i; \
+	for (i=0 ; i<len ; i++) { \
+		printf("%c", (unsigned char)*(str+i)); \
+		if(((i+1)%16) == 0) printf("- "); \
+		if(((i+1)%32) == 0) printf("\n"); \
+	} \
+	printf("\n\n"); \
+}

Property changes on: include/utils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/bcmutils.h
===================================================================
--- include/bcmutils.h	(revision 0)
+++ include/bcmutils.h	(revision 7299)
@@ -0,0 +1,159 @@
+/*
+ * Misc useful os-independent macros and functions.
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id: bcmutils.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#ifndef	_bcmutils_h_
+#define	_bcmutils_h_
+
+#ifndef MIN
+#define	MIN(a, b)		(((a)<(b))?(a):(b))
+#endif
+
+#ifndef MAX
+#define	MAX(a, b)		(((a)>(b))?(a):(b))
+#endif
+
+#define CEIL(x, y)		(((x) + ((y)-1)) / (y))
+#define	ROUNDUP(x, y)		((((ulong)(x)+((y)-1))/(y))*(y))
+#define	ISALIGNED(a, x)		(((uint)(a) & ((x)-1)) == 0)
+#define	ISPOWEROF2(x)		((((x)-1)&(x))==0)
+#define	OFFSETOF(type, member)	((uint) &((type *)0)->member)
+#define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
+
+/* bit map related macros */
+#ifndef setbit
+#define	NBBY	8	/* 8 bits per byte */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif
+
+#define	NBITS(type)	(sizeof (type) * 8)
+
+#define _BCM_U	0x01	/* upper */
+#define _BCM_L	0x02	/* lower */
+#define _BCM_D	0x04	/* digit */
+#define _BCM_C	0x08	/* cntrl */
+#define _BCM_P	0x10	/* punct */
+#define _BCM_S	0x20	/* white space (space/lf/tab) */
+#define _BCM_X	0x40	/* hex digit */
+#define _BCM_SP	0x80	/* hard space (0x20) */
+
+extern unsigned char bcm_ctype[];
+#define bcm_ismask(x) (bcm_ctype[(int)(unsigned char)(x)])
+
+#define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_isalpha(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L)) != 0)
+#define bcm_iscntrl(c)	((bcm_ismask(c)&(_BCM_C)) != 0)
+#define bcm_isdigit(c)	((bcm_ismask(c)&(_BCM_D)) != 0)
+#define bcm_isgraph(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_islower(c)	((bcm_ismask(c)&(_BCM_L)) != 0)
+#define bcm_isprint(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D|_BCM_SP)) != 0)
+#define bcm_ispunct(c)	((bcm_ismask(c)&(_BCM_P)) != 0)
+#define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
+#define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
+#define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
+
+/*
+ * Spin at most 'us' microseconds while 'exp' is true.
+ * Caller should explicitly test 'exp' when this completes
+ * and take appropriate error action if 'exp' is still true.
+ */
+#define SPINWAIT(exp, us) { \
+	uint countdown = (us) + 9; \
+	while ((exp) && (countdown >= 10)) {\
+		OSL_DELAY(10); \
+		countdown -= 10; \
+	} \
+}
+
+/* generic osl packet queue */
+struct pktq {
+	void *head;	/* first packet to dequeue */
+	void *tail;	/* last packet to dequeue */
+	uint len;	/* number of queued packets */
+	uint maxlen;	/* maximum number of queued packets */
+	bool priority;	/* enqueue by packet priority */
+};
+#define DEFAULT_QLEN	128
+
+#define	pktq_len(q)	((q)->len)
+#define	pktq_avail(q)	((q)->maxlen - (q)->len)
+#define	pktq_head(q)	((q)->head)
+#define	pktq_full(q)	((q)->len >= (q)->maxlen)
+
+/* crc defines */
+#define CRC8_INIT_VALUE  0xff		/* Initial CRC8 checksum value */
+#define CRC8_GOOD_VALUE  0x9f		/* Good final CRC8 checksum value */
+#define CRC16_INIT_VALUE 0xffff		/* Initial CRC16 checksum value */
+#define CRC16_GOOD_VALUE 0xf0b8		/* Good final CRC16 checksum value */
+#define CRC32_INIT_VALUE 0xffffffff	/* Initial CRC32 checksum value */
+#define CRC32_GOOD_VALUE 0xdebb20e3	/* Good final CRC32 checksum value */
+
+/* tag_ID/length/value_buffer tuple */
+typedef struct bcm_tlv {
+	uint8	id;
+	uint8	len;
+	uint8	data[1];
+} bcm_tlv_t;
+
+/* Check that bcm_tlv_t fits into the given buflen */
+#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (buflen) >= 2 + (elt)->len)
+
+/* buffer length for ethernet address from bcm_ether_ntoa() */
+#define ETHER_ADDR_STR_LEN	18
+
+/*
+* load 32-bit value from unaligned byte array
+*/
+#ifdef IL_BIGENDIAN
+#define load32_ua(a)	((((uint8 *)(a))[0] << 24) + (((uint8 *)(a))[1] << 16) + \
+			(((uint8 *)(a))[2] << 8) + ((uint8 *)(a))[3])
+#else
+#define load32_ua(a)	((((uint8 *)(a))[3] << 24) + (((uint8 *)(a))[2] << 16) + \
+			(((uint8 *)(a))[1] << 8) + ((uint8 *)(a))[0])
+#endif
+
+/* externs */
+extern uint bcm_atoi(char *s);
+extern uchar bcm_toupper(uchar c);
+extern ulong bcm_strtoul(char *cp, char **endp, uint base);
+extern void deadbeef(char *p, uint len);
+extern void prhex(char *msg, uchar *buf, uint len);
+extern void prpkt(char *msg, void *drv, void *p0);
+extern uint pktcopy(void *drv, void *p, uint offset, int len, uchar *buf);
+extern uint pkttotlen(void *drv, void *);
+extern uchar *bcm_ether_ntoa(char *ea, char *buf);
+extern int bcm_ether_atoe(char *p, char *ea);
+extern void bcm_mdelay(uint ms);
+extern char *getvar(char *vars, char *name);
+extern int getintvar(char *vars, char *name);
+extern char *bcmstrstr(char *haystack, char *needle);
+
+#ifdef EZPACKET
+extern uint8 crc8(uint8 *p, uint nbytes, uint8 crc);
+extern uint16 crc16(uint8 *p, uint nbytes, uint16 crc);
+extern uint32 crc32(uint8 *p, uint nbytes, uint32 crc);
+#endif
+extern bcm_tlv_t *bcm_next_tlv(bcm_tlv_t *elt, int *buflen);
+extern bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen, uint key);
+extern bcm_tlv_t *bcm_parse_ordered_tlvs(void *buf, int buflen, uint key);
+extern void pktq_init(struct pktq *q, uint maxlen, bool priority);
+extern bool pktenq(struct pktq *q, void *p, bool lifo);
+extern void *pktdeq(struct pktq *q);
+
+#define	bcmlog(fmt, a1, a2)
+#define	bcmdumplog(buf, size)	*buf = '\0'
+#define	bcmdumplogent(buf, idx)	-1
+
+#endif	/* _bcmutils_h_ */

Property changes on: include/bcmutils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/typedefs.h
===================================================================
--- include/typedefs.h	(revision 0)
+++ include/typedefs.h	(revision 7299)
@@ -0,0 +1,293 @@
+/*
+ * Copyright 2004, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id: typedefs.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#ifndef _TYPEDEFS_H_
+#define _TYPEDEFS_H_
+
+
+/* Define 'SITE_TYPEDEFS' in the compile to include a site specific
+ * typedef file "site_typedefs.h".
+ *
+ * If 'SITE_TYPEDEFS' is not defined, then the "Inferred Typedefs"
+ * section of this file makes inferences about the compile environment
+ * based on defined symbols and possibly compiler pragmas.
+ *
+ * Following these two sections is the "Default Typedefs"
+ * section. This section is only prcessed if 'USE_TYPEDEF_DEFAULTS' is
+ * defined. This section has a default set of typedefs and a few
+ * proprocessor symbols (TRUE, FALSE, NULL, ...).
+ */
+
+#ifdef SITE_TYPEDEFS
+
+/*******************************************************************************
+ * Site Specific Typedefs
+ *******************************************************************************/
+
+#include "site_typedefs.h"
+
+#else
+
+/*******************************************************************************
+ * Inferred Typedefs
+ *******************************************************************************/
+
+/* Infer the compile environment based on preprocessor symbols and pramas.
+ * Override type definitions as needed, and include configuration dependent
+ * header files to define types.
+ */
+
+#ifdef __cplusplus
+
+#define TYPEDEF_BOOL
+#ifndef FALSE
+#define FALSE	false
+#endif
+#ifndef TRUE
+#define TRUE	true
+#endif
+
+#else	/* ! __cplusplus */
+
+/* for Windows build, define bool as a uchar instead of the default int */
+#if defined(_WIN32)
+
+#define TYPEDEF_BOOL
+typedef	unsigned char	bool;
+
+#endif /* _WIN32 */
+
+#endif	/* ! __cplusplus */
+
+#ifdef _MSC_VER	    /* Microsoft C */
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+typedef signed __int64	int64;
+typedef unsigned __int64 uint64;
+#endif
+
+#if defined(MACOSX) && defined(KERNEL)
+#define TYPEDEF_BOOL
+#endif
+
+
+#if defined(linux)
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#define TYPEDEF_ULONG
+#endif
+
+#if !defined(linux) && !defined(_WIN32) && !defined(PMON) && !defined(_CFE_)
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#endif
+
+
+/* Do not support the (u)int64 types with strict ansi for GNU C */
+#if defined(__GNUC__) && defined(__STRICT_ANSI__)
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+#endif
+
+/* ICL accepts unsigned 64 bit type only, and complains in ANSI mode
+ * for singned or unsigned */
+#if defined(__ICL)
+
+#define TYPEDEF_INT64
+
+#if defined(__STDC__)
+#define TYPEDEF_UINT64
+#endif
+
+#endif /* __ICL */
+
+
+#if !defined(_WIN32) && !defined(PMON) && !defined(_CFE_)
+
+/* pick up ushort & uint from standard types.h */
+#if defined(linux) && defined(__KERNEL__)
+
+#include <linux/types.h>	/* sys/types.h and linux/types.h are oil and water */
+
+#else
+
+#include <sys/types.h>	
+
+#endif
+
+#endif /* !_WIN32 && !PMON && !_CFE_ */
+
+#if defined(MACOSX) && defined(KERNEL)
+#include <IOKit/IOTypes.h>
+#endif
+
+
+/* use the default typedefs in the next section of this file */
+#define USE_TYPEDEF_DEFAULTS
+
+#endif /* SITE_TYPEDEFS */
+
+
+/*******************************************************************************
+ * Default Typedefs
+ *******************************************************************************/
+
+#ifdef USE_TYPEDEF_DEFAULTS
+#undef USE_TYPEDEF_DEFAULTS
+
+#ifndef TYPEDEF_BOOL
+typedef	int	bool;
+#endif
+
+/*----------------------- define uchar, ushort, uint, ulong ----------------*/
+
+#ifndef TYPEDEF_UCHAR
+typedef unsigned char	uchar;
+#endif
+
+#ifndef TYPEDEF_USHORT
+typedef unsigned short	ushort;
+#endif
+
+#ifndef TYPEDEF_UINT
+typedef unsigned int	uint;
+#endif
+
+#ifndef TYPEDEF_ULONG
+typedef unsigned long	ulong;
+#endif
+
+/*----------------------- define [u]int8/16/32/64 --------------------------*/
+
+#ifndef TYPEDEF_UINT8
+typedef unsigned char	uint8;
+#endif
+
+#ifndef TYPEDEF_UINT16
+typedef unsigned short	uint16;
+#endif
+
+#ifndef TYPEDEF_UINT32
+typedef unsigned int	uint32;
+#endif
+
+#ifndef TYPEDEF_UINT64
+typedef unsigned long long uint64;
+#endif
+
+#ifndef TYPEDEF_INT8
+typedef signed char	int8;
+#endif
+
+#ifndef TYPEDEF_INT16
+typedef signed short	int16;
+#endif
+
+#ifndef TYPEDEF_INT32
+typedef signed int	int32;
+#endif
+
+#ifndef TYPEDEF_INT64
+typedef signed long long int64;
+#endif
+
+/*----------------------- define float32/64, float_t -----------------------*/
+
+#ifndef TYPEDEF_FLOAT32
+typedef float		float32;
+#endif
+
+#ifndef TYPEDEF_FLOAT64
+typedef double		float64;
+#endif
+
+/*
+ * abstracted floating point type allows for compile time selection of
+ * single or double precision arithmetic.  Compiling with -DFLOAT32
+ * selects single precision; the default is double precision.
+ */
+
+#ifndef TYPEDEF_FLOAT_T
+
+#if defined(FLOAT32)
+typedef float32 float_t;
+#else /* default to double precision floating point */
+typedef float64 float_t;
+#endif
+
+#endif /* TYPEDEF_FLOAT_T */
+
+/*----------------------- define macro values -----------------------------*/
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#ifndef ON
+#define	ON	1
+#endif
+
+/*----------------------- define PTRSZ, INLINE ----------------------------*/
+
+#ifndef PTRSZ
+#define	PTRSZ	sizeof (char*)
+#endif
+
+#ifndef INLINE
+
+#ifdef _MSC_VER
+
+#define INLINE __inline
+
+#elif __GNUC__
+
+#define INLINE __inline__
+
+#else
+
+#define INLINE
+
+#endif /* _MSC_VER */
+
+#endif /* INLINE */
+
+#undef TYPEDEF_BOOL
+#undef TYPEDEF_UCHAR
+#undef TYPEDEF_USHORT
+#undef TYPEDEF_UINT
+#undef TYPEDEF_ULONG
+#undef TYPEDEF_UINT8
+#undef TYPEDEF_UINT16
+#undef TYPEDEF_UINT32
+#undef TYPEDEF_UINT64
+#undef TYPEDEF_INT8
+#undef TYPEDEF_INT16
+#undef TYPEDEF_INT32
+#undef TYPEDEF_INT64
+#undef TYPEDEF_FLOAT32
+#undef TYPEDEF_FLOAT64
+#undef TYPEDEF_FLOAT_T
+
+#endif /* USE_TYPEDEF_DEFAULTS */
+
+#endif /* _TYPEDEFS_H_ */

Property changes on: include/typedefs.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/wlutils.h
===================================================================
--- include/wlutils.h	(revision 0)
+++ include/wlutils.h	(revision 7299)
@@ -0,0 +1,59 @@
+/*
+ * Broadcom wireless network adapter utility functions
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: wlutils.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#ifndef _wlutils_h_
+#define _wlutils_h_
+
+#include <typedefs.h>
+#include <wlioctl.h>
+
+/*
+ * Pass a wlioctl request to the specified interface.
+ * @param	name	interface name
+ * @param	cmd	WLC_GET_MAGIC <= cmd < WLC_LAST
+ * @param	buf	buffer for passing in and/or receiving data
+ * @param	len	length of buf
+ * @return	>= 0 if successful or < 0 otherwise
+ */
+extern int wl_ioctl(char *name, int cmd, void *buf, int len);
+
+/*
+ * Get the MAC (hardware) address of the specified interface.
+ * @param	name	interface name
+ * @param	hwaddr	6-byte buffer for receiving address
+ * @return	>= 0 if successful or < 0 otherwise
+ */
+extern int wl_hwaddr(char *name, unsigned char *hwaddr);
+
+/*
+ * Probe the specified interface.
+ * @param	name	interface name
+ * @return	>= 0 if a Broadcom wireless device or < 0 otherwise
+ */
+extern int wl_probe(char *name);
+
+/*
+ * Set/Get named variable.
+ * @param	name	interface name
+ * @param	var	variable name
+ * @param	val	variable value/buffer
+ * @param	len	variable value/buffer length
+ * @return	success == 0, failure != 0
+ */
+extern int wl_set_val(char *name, char *var, void *val, int len);
+extern int wl_get_val(char *name, char *var, void *val, int len);
+extern int wl_set_int(char *name, char *var, int val);
+extern int wl_get_int(char *name, char *var, int *val);
+
+#endif /* _wlutils_h_ */

Property changes on: include/wlutils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/bcmnvram.h
===================================================================
--- include/bcmnvram.h	(revision 0)
+++ include/bcmnvram.h	(revision 7299)
@@ -0,0 +1,187 @@
+/*
+ * NVRAM variable manipulation
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: bcmnvram.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#ifndef _bcmnvram_h_
+#define _bcmnvram_h_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#include <typedefs.h>
+
+struct nvram_header {
+	uint32 magic;
+	uint32 len;
+	uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:27 init, mem. test 28, 29-31 reserved */
+	uint32 config_refresh;	/* 0:15 config, 16:31 refresh */
+	uint32 config_ncdl;	/* ncdl values for memc */
+};
+
+/* None of specific NVRAM options. */
+#define NVRAM_NONE 0x00
+/* NOT allowed to be disclosed (e.g. a config file). */
+#define NVRAM_PRIVATE 0x01
+/* 
+ * NOT allowed to be overwritten (e.g. a license key). If the value is
+ * empty, it could be written for once.
+ */
+#define NVRAM_PROTECTED 0x02
+/* For temporary use. */
+#define NVRAM_TEMP 0x04
+/* Customized by the authorized program. */
+#define NVRAM_CUSTOMIZED 0x08
+/* NVRAM could be empty. */
+#define NVRAM_EMPTY 0x10
+/* NVRAM value should be set by *_default if this value is empty . */
+#define NVRAM_DEFAULT 0x20
+/* NVRAM is undefined. */
+#define NVRAM_UNDEFINED 0x80000000
+
+struct nvram_tuple {
+	char *name;
+	char *value;
+    uint32 option;
+	struct nvram_tuple *next;
+};
+
+/*
+ * Initialize NVRAM access. May be unnecessary or undefined on certain
+ * platforms.
+ */
+extern int nvram_init(void *sbh);
+
+/*
+ * Disable NVRAM access. May be unnecessary or undefined on certain
+ * platforms.
+ */
+extern void nvram_exit(void);
+
+/*
+ * Get the value of an NVRAM variable. The pointer returned may be
+ * invalid after a set.
+ * @param	name	name of variable to get
+ * @return	value of variable or NULL if undefined
+ */
+extern char * nvram_get(const char *name);
+
+/* 
+ * Get the value of an NVRAM variable.
+ * @param	name	name of variable to get
+ * @return	value of variable or NUL if undefined
+ */
+#define nvram_safe_get(name) (nvram_get(name) ? : "")
+
+#define nvram_safe_unset(name) ({ \
+	if(nvram_get(name)) \
+		nvram_unset(name); \
+})
+
+#define nvram_safe_set(name, value) ({ \
+	if(!nvram_get(name) || strcmp(nvram_get(name), value)) \
+		nvram_set(name, value); \
+})
+
+/*
+ * Match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is string equal
+ *		to match or FALSE otherwise
+ */
+static INLINE int
+nvram_match(char *name, char *match) {
+	const char *value = nvram_get(name);
+	return (value && !strcmp(value, match));
+}
+
+/*
+ * Inversely match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is not string
+ *		equal to invmatch or FALSE otherwise
+ */
+static INLINE int
+nvram_invmatch(char *name, char *invmatch) {
+	const char *value = nvram_get(name);
+	return (value && strcmp(value, invmatch));
+}
+
+/*
+ * Set the value of an NVRAM variable. The name and value strings are
+ * copied into private storage. Pointers to previously set values
+ * may become invalid. The new value may be immediately
+ * retrieved but will not be permanently stored until a commit.
+ * @param	name	name of variable to set
+ * @param	value	value of variable
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_set(const char *name, const char *value);
+
+extern int nvram_fset(const char *name, const char *value);
+
+/*
+ * Unset an NVRAM variable. Pointers to previously set values
+ * remain valid until a set.
+ * @param	name	name of variable to unset
+ * @return	0 on success and errno on failure
+ * NOTE: use nvram_commit to commit this change to flash.
+ */
+extern int nvram_unset(const char *name);
+
+/*
+ * Commit NVRAM variables to permanent storage. All pointers to values
+ * may be invalid after a commit.
+ * NVRAM values are undefined after a commit.
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_commit(void);
+
+/*
+ * Set NVRAM variables in booting.
+ */
+extern void nvram_boot(void);
+
+/*
+ * Reset NVRAM variables.
+ */
+extern void nvram_default(void);
+extern void nvram_default_rule(char *rulename);
+
+/*
+ * Reset NVRAM variables and reboot.
+ */
+extern void nvram_factory(void);
+
+/*
+ * Get all NVRAM variables (format name=value\0 ... \0\0).
+ * @param	buf	buffer to store variables
+ * @param	count	size of buffer in bytes
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_getall(char *buf, int count);
+
+extern int file2nvram(char *filename, char *varname);
+extern int nvram2file(char *varname, char *filename);
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#define NVRAM_MAGIC		0x48534C46	/* 'FLSH' */
+#define NVRAM_VERSION		1
+#define NVRAM_HEADER_SIZE	20
+#define NVRAM_SPACE		0x8000
+#define FLASH_BASE		0xbfc00000	/* Extif core */
+#define FLASH_MIN		0x00100000	/* Minimum flash size */
+#define FLASH_MAX		0x00400000	/* Maximum flash size with extif */
+
+#endif /* _bcmnvram_h_ */

Property changes on: include/bcmnvram.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/wlcompat.h
===================================================================
--- include/wlcompat.h	(revision 0)
+++ include/wlcompat.h	(revision 7299)
@@ -0,0 +1,36 @@
+/*
+ * wlcompat.h
+ *
+ * Copyright (C) 2005 Felix Fietkau <nbd@vd-s.ath.cx>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * $Id: wlcompat.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+#include <linux/wireless.h>
+
+#ifndef WLCOMPAT_H
+#define WLCOMPAT_H
+
+#define WLCOMPAT_SET_MONITOR		SIOCIWFIRSTPRIV + 0
+#define WLCOMPAT_GET_MONITOR		SIOCIWFIRSTPRIV + 1
+#define WLCOMPAT_SET_TXPWR_LIMIT	SIOCIWFIRSTPRIV + 2
+#define WLCOMPAT_GET_TXPWR_LIMIT	SIOCIWFIRSTPRIV + 3
+#define WLCOMPAT_SET_ANTDIV		SIOCIWFIRSTPRIV + 4
+#define WLCOMPAT_GET_ANTDIV		SIOCIWFIRSTPRIV + 5
+#define WLCOMPAT_SET_TXANT		SIOCIWFIRSTPRIV + 6
+#define WLCOMPAT_GET_TXANT		SIOCIWFIRSTPRIV + 7
+
+#endif

Property changes on: include/wlcompat.h
___________________________________________________________________
Added: svn:executable
   + *

Index: include/code_pattern.h
===================================================================
--- include/code_pattern.h	(revision 0)
+++ include/code_pattern.h	(revision 7299)
@@ -0,0 +1,124 @@
+#define CODE_ID		"U2ND"
+#define BOOT_PATTERN	"EST"
+#define UP_PMON		1
+#define UP_MAC		2
+#define UP_CODE		3
+#define UP_PIGGY	4
+#define UP_EOU_KEY	5
+#define UP_SN		6
+#define UP_LANG		7
+
+#define LINKSYS		7
+#define CISCO		90
+
+#define ENGLISH 	1
+#define JAPANESE	2
+#define GERMAN		3
+#define FRENCH		4
+#define KOREAN		5
+
+#define	USA		1
+#define	JAPAN		2
+#define	EUROPE		3
+#define WW		4
+#define GERMANY		5
+#define	KOREA		6
+#define	FRANCE		7
+
+#define	WRT54G		1
+#define	WRT54GS		2
+#define	WRT54V5		3
+#define	DPN		4
+#define	RTA41		5
+#define WRT54GL         6
+#define WRT54GSV4	7
+
+
+#define LINKSYS_MODEL	WRT54GL
+/***************************************
+ * define country                      *
+ * LOCALE=COUNTRY =                    *
+ ***************************************/
+#define COUNTRY		LOCALE
+#define LOCALE		USA
+//#define LOCALE		JAPAN
+//#define LOCALE		EUROPE
+//#define LOCALE		WW
+//#define LOCALE		GERMANY	
+//#define LOCALE		FRANCE
+//#define LOCALE		KOREA
+
+/***************************************
+ * define model name and code pattern  *
+ * MODEL_NAME =                        *
+ * CODE_PATTERN =                      *
+ ***************************************/
+	#define UI_STYLE	CISCO
+		#define CODE_PATTERN   "W54G"
+		#if LOCALE == GERMANY
+			#define MODEL_NAME	"WRT54G-DE"
+			#define MODEL_VERSION	""
+		#elif LOCALE == FRANCE
+			#define MODEL_NAME	"WRT54G-FR"
+			#define MODEL_VERSION	""
+		#elif LOCALE == JAPAN
+			#define MODEL_NAME	"WRT54G-JP"
+			#define MODEL_VERSION	""
+		#else
+			#define MODEL_NAME	"WRT54GL"
+			#define MODEL_VERSION	"V1"
+		#endif
+		#define	CT_VENDOR		"LINKSYS"
+		/*Barry add for Control Intel Flash Downgrade code*/
+		#define INTEL_FLASH_SUPPORT_VERSION_FROM "v1.41.8"
+		#define BCM4712_CHIP_SUPPORT_VERSION_FROM "v1.50.0"
+		#define INTEL_FLASH_SUPPORT_BOOT_VERSION_FROM "v1.3"
+		#define BCM4712_CHIP_SUPPORT_BOOT_VERSION_FROM "v2.0"
+
+/***************************************
+ * define language                     *
+ * LANGUAGE =                          *
+ * LANG_SEL=EN                         *
+ * HTTP_CHARSET =		       *
+ ***************************************/
+#if LOCALE == JAPAN
+	#define	LANGUAGE	JAPANESE
+	#define	HTTP_CHARSET	"shift-jis"
+#elif LOCALE == GERMANY
+	#define LANGUAGE	GERMAN
+	#define	HTTP_CHARSET	"iso-8859-1"
+#elif LOCALE == FRANCE
+	#define LANGUAGE	FRENCH
+	#define	HTTP_CHARSET	"iso-8859-1"
+#elif LOCALE == KOREA
+	#define LANGUAGE 	KOREAN
+	#define	HTTP_CHARSET	"euc-kr"
+#else
+	#define LANGUAGE 	ENGLISH
+	#define	HTTP_CHARSET	"iso-8859-1"
+#endif
+
+/***************************************
+ * define wireless max channel         *
+ * WL_MAX_CHANNEL =                    *
+ ***************************************/
+#if LOCALE == JAPAN || LOCALE == EUROPE || LOCALE == GERMANY || LOCALE == FRANCE
+	#define	WL_MAX_CHANNEL	"13"
+#else
+	#define WL_MAX_CHANNEL	"11"
+#endif
+
+/***************************************
+ * define web file path                *
+ * WEB_PAGE =                          *
+ ***************************************/
+#if UI_STYLE ==  CISCO
+	#define WEB_PAGE	"cisco_wrt54g_m"
+#endif
+
+/***************************************
+ * check LOCALE
+ ***************************************/
+ #if LOCALE != JAPAN && LOCALE != USA && LOCALE != EUROPE && LOCALE != GERMANY && LOCALE != FRANCE
+	#error	"The LOCALE for LINKSYS is error, must be USA, EUROPE, JAPAN, GERMANY or FRANCE"
+ #endif

Property changes on: include/code_pattern.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/linux_timer.c
===================================================================
--- src/linux_timer.c	(revision 0)
+++ src/linux_timer.c	(revision 7299)
@@ -0,0 +1,738 @@
+/*
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * Low resolution timer interface linux specific implementation.
+ *
+ * $Id: linux_timer.c 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+/*
+* debug facilities
+*/
+#define TIMER_DEBUG	0
+#if TIMER_DEBUG
+#define TIMERDBG(fmt, args...) printf("%s: " fmt "\n" , __FUNCTION__ , ## args)
+#else
+#define TIMERDBG(fmt, args...)
+#endif
+
+
+/*
+ * POSIX timer support for Linux. Taken from linux_timer.c in upnp
+ */
+
+#define __USE_GNU
+
+
+#include <stdlib.h>	    // for malloc, free, etc.
+#include <string.h>	    // for memset, strncasecmp, etc.
+#include <assert.h>	    // for assert, of course.
+#include <signal.h>	    // for sigemptyset, etc.
+#include <stdio.h>	    // for printf, etc.
+#include <sys/time.h>
+#include <time.h>
+
+/* define TIMER_PROFILE to enable code which guages how accurate the timer functions are.
+   For each expiring timer the code will print the expected time interval and the actual time interval.
+#define TIMER_PROFILE
+*/
+#undef TIMER_PROFILE
+
+/*
+timer_cancel( ) - cancel a timer
+timer_connect( ) - connect a user routine to the timer signal
+timer_create( ) - allocate a timer using the specified clock for a timing base (POSIX)
+timer_delete( ) - remove a previously created timer (POSIX)
+timer_gettime( ) - get the remaining time before expiration and the reload value (POSIX)
+timer_getoverrun( ) - return the timer expiration overrun (POSIX)
+timer_settime( ) - set the time until the next expiration and arm timer (POSIX)
+nanosleep( ) - suspend the current task until the time interval elapses (POSIX)
+*/
+
+#define MS_PER_SEC 1000
+#define US_PER_SEC 1000000
+#define US_PER_MS  1000
+#define UCLOCKS_PER_SEC 1000000
+
+typedef void (*event_callback_t)(timer_t, int);
+
+#ifndef TIMESPEC_TO_TIMEVAL
+# define TIMESPEC_TO_TIMEVAL(tv, ts) {                                   \
+        (tv)->tv_sec = (ts)->tv_sec;                                    \
+        (tv)->tv_usec = (ts)->tv_nsec / 1000;                           \
+}
+#endif
+
+#ifndef TIMEVAL_TO_TIMESPEC
+# define TIMEVAL_TO_TIMESPEC(tv, ts) {                                   \
+        (ts)->tv_sec = (tv)->tv_sec;                                    \
+        (ts)->tv_nsec = (tv)->tv_usec * 1000;                           \
+}
+#endif
+
+#define ROUNDUP(x,y) ((((x)+(y)-1)/(y))*(y))
+
+#define timerroundup(t,g) \
+    do { \
+	if (!timerisset(t)) (t)->tv_usec=1; \
+	if ((t)->tv_sec == 0) (t)->tv_usec=ROUNDUP((t)->tv_usec, g); \
+    } while (0)
+
+typedef long uclock_t;
+
+#define TFLAG_NONE	0
+#define TFLAG_CANCELLED	(1<<0)
+#define TFLAG_DELETED	(1<<1)
+
+struct event {
+    struct timeval it_interval;
+    struct timeval it_value;
+    event_callback_t func;
+    int arg;
+    unsigned short flags;
+    struct event *next;
+#ifdef TIMER_PROFILE
+    uint expected_ms;
+    uclock_t start;
+#endif
+};
+
+void timer_cancel(timer_t timerid);
+
+static void alarm_handler(int i);
+static void check_event_queue();
+static void print_event_queue();
+static void check_timer();
+#if THIS_FINDS_USE
+static int count_queue(struct event *);
+#endif
+static int timer_change_settime(timer_t timer_id, const struct itimerspec *timer_spec);
+void block_timer();
+void unblock_timer();
+
+static struct event *event_queue = NULL;
+static struct event *event_freelist;
+static uint g_granularity;
+static int g_maxevents = 0;
+
+uclock_t uclock()
+{
+    struct timeval tv;
+
+    gettimeofday(&tv, NULL);
+    return ((tv.tv_sec * US_PER_SEC) + tv.tv_usec);
+}
+
+
+void init_event_queue(int n)
+{
+    int i;
+    struct itimerval tv;
+    
+    g_maxevents = n;
+    event_freelist = (struct event *) malloc(n * sizeof(struct event));
+    memset(event_freelist, 0, n * sizeof(struct event));
+
+    for (i = 0; i < (n-1); i++) 
+	event_freelist[i].next = &event_freelist[i+1];
+
+    event_freelist[i].next = NULL;
+
+    tv.it_interval.tv_sec = 0;
+    tv.it_interval.tv_usec = 1;
+    tv.it_value.tv_sec = 0;
+    tv.it_value.tv_usec = 0;
+    setitimer (ITIMER_REAL, &tv, 0);
+    setitimer (ITIMER_REAL, 0, &tv);
+    g_granularity = tv.it_interval.tv_usec;
+
+    signal(SIGALRM, alarm_handler);
+}
+
+
+int clock_gettime(
+    clockid_t         clock_id, /* clock ID (always CLOCK_REALTIME) */
+    struct timespec * tp        /* where to store current time */
+)
+{
+    struct timeval tv;
+    int n;
+
+
+    n = gettimeofday(&tv, NULL);
+    TIMEVAL_TO_TIMESPEC(&tv, tp);
+    
+    return n;
+}
+
+
+int timer_create(
+    clockid_t         clock_id, /* clock ID (always CLOCK_REALTIME) */
+    struct sigevent * evp,      /* user event handler */
+    timer_t *         pTimer    /* ptr to return value */
+)
+{
+    struct event *event;
+
+    if (clock_id != CLOCK_REALTIME) {
+	TIMERDBG("timer_create can only support clock id CLOCK_REALTIME");
+	exit(1);
+    }
+
+    if (evp != NULL) {
+	if (evp->sigev_notify != SIGEV_SIGNAL || evp->sigev_signo != SIGALRM) {
+	    TIMERDBG("timer_create can only support signalled alarms using SIGALRM");
+	    exit(1);
+	}
+    }
+
+    event = event_freelist;
+    if (event == NULL) {
+	print_event_queue();
+    }
+    assert(event != NULL);
+
+    event->flags = TFLAG_NONE;
+    
+    event_freelist = event->next;
+    event->next = NULL;
+
+    check_event_queue();
+
+    *pTimer = (timer_t) event;
+
+    return 0;
+}
+
+int timer_delete(
+    timer_t timerid /* timer ID */
+)
+{
+    struct event *event = (struct event *) timerid;
+    
+    if (event->flags & TFLAG_DELETED) {
+	TIMERDBG("Cannot delete a deleted event");
+	return 1;
+    }
+
+    timer_cancel(timerid);
+    
+    event->flags |= TFLAG_DELETED;
+
+    event->next = event_freelist;
+    event_freelist = event;
+
+    return 0;
+}
+
+int timer_connect
+(
+    timer_t     timerid, /* timer ID */
+    void (*routine)(timer_t, int), /* user routine */
+    int         arg      /* user argument */
+)
+{
+    struct event *event = (struct event *) timerid;
+
+    assert(routine != NULL);
+    event->func = routine;
+    event->arg = arg;
+    
+    return 0;
+}    
+
+/* 
+ * Please Call this function only from the call back functions of the alarm_handler.
+ * This is just a hack 
+*/
+int timer_change_settime
+(
+    timer_t                   timerid, /* timer ID */
+    const struct itimerspec * value   /* time to be set */
+)
+{
+    struct event *event = (struct event *) timerid;
+
+    TIMESPEC_TO_TIMEVAL(&event->it_interval, &value->it_interval);
+    TIMESPEC_TO_TIMEVAL(&event->it_value, &value->it_value);
+
+    return 1; 	
+}
+
+int timer_settime
+(
+    timer_t                   timerid, /* timer ID */
+    int                       flags,   /* absolute or relative */
+    const struct itimerspec * value,   /* time to be set */
+    struct itimerspec *       ovalue   /* previous time set (NULL=no result) */
+)
+{
+    struct itimerval itimer;
+    struct event *event = (struct event *) timerid;
+    struct event **ppevent;
+
+    TIMESPEC_TO_TIMEVAL(&event->it_interval, &value->it_interval);
+    TIMESPEC_TO_TIMEVAL(&event->it_value, &value->it_value);
+
+    /* if .it_value is zero, the timer is disarmed */
+    if (!timerisset(&event->it_value)) {
+	timer_cancel(timerid);
+	return 0;
+    }
+
+    block_timer();
+
+#ifdef TIMER_PROFILE
+    event->expected_ms = (event->it_value.tv_sec * MS_PER_SEC) + (event->it_value.tv_usec / US_PER_MS);
+    event->start = uclock();
+#endif
+    if (event->next) {
+	TIMERDBG("calling timer_settime with a timer that is already on the queue.");
+    }
+
+
+    /* We always want to make sure that the event at the head of the
+       queue has a timeout greater than the itimer granularity.
+       Otherwise we end up with the situation that the time remaining
+       on an itimer is greater than the time at the head of the queue
+       in the first place. */
+    timerroundup(&event->it_value, g_granularity);
+
+    timerclear(&itimer.it_value);
+    getitimer(ITIMER_REAL, &itimer);
+    if (timerisset(&itimer.it_value)) {
+	// reset the top timer to have an interval equal to the remaining interval 
+	// when the timer was cancelled.
+	if (event_queue) {
+	    if (timercmp(&(itimer.it_value), &(event_queue->it_value), >)) {
+		// it is an error if the amount of time remaining is more than the amount of time 
+		// requested by the top event.
+		//
+		TIMERDBG("timer_settime: TIMER ERROR!");
+
+	    } else {
+		// some portion of the top event has already expired.
+		// Reset the interval of the top event to remaining
+		// time left in that interval.
+		//
+		event_queue->it_value = itimer.it_value;
+
+		// if we were the earliest timer before now, we are still the earliest timer now.
+		// we do not need to reorder the list.
+	    }
+	}
+    }
+
+    // Now, march down the list, decrementing the new timer by the
+    // current it_value of each event on the queue.
+    ppevent = &event_queue;
+    while (*ppevent) {
+	if ( timercmp(&(event->it_value), &((*ppevent)->it_value), <) ) {
+	    // if the proposed event will trigger sooner than the next event
+	    // in the queue, we will insert the new event just before the next one.
+	    //
+	    // we also need to adjust the delta value to the next event.
+	    timersub(&((*ppevent)->it_value), &(event->it_value), &((*ppevent)->it_value));
+	    break;
+	}
+	// subtract the interval of the next event from the proposed interval.
+	timersub(&(event->it_value), &((*ppevent)->it_value), &(event->it_value));
+
+	ppevent = &((*ppevent)->next);
+    }
+    
+    // we have found our proper place in the queue, 
+    // link our new event into the pending event queue.
+    event->next = *ppevent;
+    *ppevent = event;
+
+    check_event_queue();
+
+    // if our new event ended up at the front of the queue, reissue the timer.
+    if (event == event_queue) {
+	timerroundup(&event_queue->it_value, g_granularity);
+	timerclear(&itimer.it_interval);
+	itimer.it_value = event_queue->it_value;
+	
+	// we want to be sure to never turn off the timer completely, 
+	// so if the next interval is zero, set it to some small value.
+	if (!timerisset(&(itimer.it_value)))
+	    itimer.it_value = (struct timeval) { 0, 1 };
+	
+	assert(!timerisset(&itimer.it_interval));
+	assert(itimer.it_value.tv_sec > 0 || itimer.it_value.tv_usec >= g_granularity);
+	assert(event_queue->it_value.tv_sec > 0 || event_queue->it_value.tv_usec >= g_granularity);
+	setitimer(ITIMER_REAL, &itimer, NULL);
+	check_timer();
+    }
+
+    event->flags &= ~TFLAG_CANCELLED;
+    
+    unblock_timer();
+
+    return 0;
+}
+
+static void check_timer()
+{
+    struct itimerval itimer;
+    
+    getitimer(ITIMER_REAL, &itimer);
+    if (timerisset(&itimer.it_interval)) {
+	TIMERDBG("ERROR timer interval is set.");
+    }
+    if (timercmp(&(itimer.it_value), &(event_queue->it_value), >)) {
+	TIMERDBG("ERROR timer expires later than top event.");
+    }
+}
+
+
+static void check_event_queue()
+{
+    struct timeval sum;
+    struct event *event;
+    int i = 0;
+
+#ifdef notdef
+    int nfree = 0;
+    struct event *p;
+    for (p = event_freelist; p; p = p->next)
+	nfree++;
+    printf("%d free events\n", nfree);
+#endif
+    
+    timerclear(&sum);
+    for (event = event_queue; event; event = event->next) {
+	if (i > g_maxevents) {
+	    TIMERDBG("timer queue looks like it loops back on itself!");
+	    print_event_queue();
+	    exit(1);
+	}
+	i++;
+    }
+}
+
+#if THIS_FINDS_USE
+/* The original upnp version has this unused function, so I left it in
+   to maintain the resemblance. */
+static int count_queue(struct event *event_queue)
+{
+    struct event *event;
+    int i = 0;
+    for (event = event_queue; event; event = event->next) 
+	i++;
+    return i;
+}
+#endif
+
+static void print_event_queue()
+{
+    struct event *event;
+    int i = 0;
+
+    for (event = event_queue; event; event = event->next) {
+	printf("#%d (0x%x)->0x%x: \t%d sec %d usec\t%p\n", 
+	       i++, (unsigned int) event, (unsigned int) event->next, (int) event->it_value.tv_sec, (int) event->it_value.tv_usec, event->func);
+	if (i > g_maxevents) {
+	    printf("...(giving up)\n");
+	    break;
+	}
+    }
+}
+
+// The top element of the event queue must have expired.
+// Remove that element, run its function, and reset the timer.
+// if there is no interval, recycle the event structure.
+static void alarm_handler(int i)
+{
+    struct event *event, **ppevent;
+    struct itimerval itimer;
+    struct timeval small_interval = { 0, g_granularity/2 };
+#ifdef TIMER_PROFILE
+    uint junk;
+    uclock_t end;
+    uint actual;
+#endif
+
+    block_timer();
+
+    // Loop through the event queue and remove the first event plus any 
+    // subsequent events that will expire very soon thereafter (within 'small_interval'}.
+    //
+    do {
+	// remove the top event.
+	event = event_queue;
+	event_queue = event_queue->next;
+	event->next = NULL;
+
+#ifdef TIMER_PROFILE
+	end = uclock();
+	actual = ((end-event->start)/((uclock_t)UCLOCKS_PER_SEC/1000));
+	if (actual < 0)
+	    junk = end;
+	TIMERDBG("expected %d ms  actual %d ms", event->expected_ms, ((end-event->start)/((uclock_t)UCLOCKS_PER_SEC/1000)));
+#endif
+	
+	    // call the event callback function
+	    (*(event->func))((timer_t) event, (int)event->arg);
+
+	/* If the event has been cancelled, do NOT put it back on the queue. */
+	if ( !(event->flags & TFLAG_CANCELLED) ) {
+
+	    // if the event is a recurring event, reset the timer and
+	    // find its correct place in the sorted list of events.
+	    //
+	    if (timerisset(&event->it_interval)) {
+		// event is recurring...
+		//
+		event->it_value = event->it_interval;
+#ifdef TIMER_PROFILE
+		event->expected_ms = (event->it_value.tv_sec * MS_PER_SEC) + (event->it_value.tv_usec / US_PER_MS);
+		event->start = uclock();
+#endif
+		timerroundup(&event->it_value, g_granularity);
+
+		// Now, march down the list, decrementing the new timer by the
+		// current delta of each event on the queue.
+		ppevent = &event_queue;
+		while (*ppevent) {
+		    if ( timercmp(&(event->it_value), &((*ppevent)->it_value), <) ) {
+			// if the proposed event will trigger sooner than the next event
+			// in the queue, we will insert the new event just before the next one.
+			//
+			// we also need to adjust the delta value to the next event.
+			timersub(&((*ppevent)->it_value), &(event->it_value), &((*ppevent)->it_value));
+			break;
+		    }
+		    timersub(&(event->it_value), &((*ppevent)->it_value), &(event->it_value));
+		    ppevent = &((*ppevent)->next);
+		}
+
+		// we have found our proper place in the queue, 
+		// link our new event into the pending event queue.
+		event->next = *ppevent;
+		*ppevent = event;
+	    } else {
+		// there is no interval, so recycle the event structure.
+		//timer_delete((timer_t) event);
+	    }
+	}
+
+	check_event_queue();
+	
+    } while (event_queue && timercmp(&event_queue->it_value, &small_interval, <));
+    
+    // re-issue the timer...
+    if (event_queue) {
+	timerroundup(&event_queue->it_value, g_granularity);
+
+	timerclear(&itimer.it_interval);
+	itimer.it_value = event_queue->it_value;
+	// we want to be sure to never turn off the timer completely, 
+	// so if the next interval is zero, set it to some small value.
+	if (!timerisset(&(itimer.it_value)))
+	    itimer.it_value = (struct timeval) { 0, 1 };
+
+	setitimer(ITIMER_REAL, &itimer, NULL);
+	check_timer();
+    } else {
+	TIMERDBG("There are no events in the queue - timer not reset.");
+    }
+
+    unblock_timer();
+}
+
+static int block_count = 0;
+
+void block_timer()
+{
+    sigset_t set;
+
+    if (block_count++ == 0) {
+	sigemptyset(&set);
+	sigaddset(&set, SIGALRM);
+	sigprocmask(SIG_BLOCK, &set, NULL);
+    }
+}
+
+void unblock_timer()
+{
+    sigset_t set;
+
+    if (--block_count == 0) {
+	sigemptyset(&set);
+	sigaddset(&set, SIGALRM);
+	sigprocmask(SIG_UNBLOCK, &set, NULL);
+    }
+}
+
+void timer_cancel_all()
+{
+    struct itimerval timeroff = { { 0, 0 }, { 0, 0} };
+    struct event *event;
+    struct event **ppevent;
+
+    setitimer(ITIMER_REAL, &timeroff, NULL);
+
+    ppevent = &event_queue;
+    while (*ppevent) {
+	event = *ppevent;
+	*ppevent = event->next;
+	event->next = NULL;
+    }
+}
+
+
+
+void timer_cancel(timer_t timerid)
+{
+    struct itimerval itimer;
+    struct itimerval timeroff = { { 0, 0 }, { 0, 0} };
+    struct event *event = (struct event *) timerid;
+    struct event **ppevent;
+
+    if (event->flags & TFLAG_CANCELLED) {
+	TIMERDBG("Cannot cancel a cancelled event");
+    	return;
+    }
+
+    block_timer();
+    
+    ppevent = &event_queue;
+    while (*ppevent) {
+	if ( *ppevent == event ) {
+
+	    /* RACE CONDITION - if the alarm goes off while we are in
+	       this loop, and if the timer we want to cancel is the
+	       next to expire, the alarm will end up firing
+	       after this routine is complete, causing it to go off early. */
+
+	    /* If the cancelled timer is the next to expire, 
+	       we need to do something special to clean up correctly. */
+	    if (event == event_queue && event->next != NULL) {
+		timerclear(&itimer.it_value);
+		getitimer(ITIMER_REAL, &itimer);
+		
+		/* subtract the time that has already passed while waiting for this timer... */
+		timersub(&(event->it_value), &(itimer.it_value), &(event->it_value));
+
+		/* and add any remainder to the next timer in the list */
+		timeradd(&(event->next->it_value), &(event->it_value), &(event->next->it_value));
+	    }
+
+	    *ppevent = event->next;
+	    event->next = NULL;
+
+	    if (event_queue) {
+		timerroundup(&event_queue->it_value, g_granularity);
+		timerclear(&itimer.it_interval);
+		itimer.it_value = event_queue->it_value;
+		
+		/* We want to be sure to never turn off the timer
+		   completely if there are more events on the queue,
+		   so if the next interval is zero, set it to some
+		   small value.  */
+
+		if (!timerisset(&(itimer.it_value)))
+		    itimer.it_value = (struct timeval) { 0, 1 };
+		
+		assert(itimer.it_value.tv_sec > 0 || itimer.it_value.tv_usec >= g_granularity);
+		assert(event_queue->it_value.tv_sec > 0 || event_queue->it_value.tv_usec >= g_granularity);
+		setitimer(ITIMER_REAL, &itimer, NULL);
+		check_timer();
+	    } else {
+		setitimer(ITIMER_REAL, &timeroff, NULL);
+	    }
+	    break;
+	}
+	ppevent = &((*ppevent)->next);
+    }
+
+    event->flags |= TFLAG_CANCELLED;
+
+    unblock_timer();
+}
+
+/*
+* timer related headers
+*/
+#include "bcmtimer.h"
+
+/*
+* locally used global variables and constants
+*/
+
+/*
+* Initialize internal resources used in the timer module. It must be called
+* before any other timer function calls. The param 'timer_entries' is used
+* to pre-allocate fixed number of timer entries.
+*/
+int bcm_timer_module_init(int timer_entries, bcm_timer_module_id *module_id)
+{
+	init_event_queue(timer_entries);
+	*module_id = (bcm_timer_module_id)event_freelist;
+	return 0;
+}
+
+/*
+* Cleanup internal resources used by this timer module. It deletes all
+* pending timer entries from the backend timer system as well.
+*/
+int bcm_timer_module_cleanup(bcm_timer_module_id module_id)
+{
+	module_id = 0;
+	return 0;
+}
+
+/* Enable/Disable timer module */
+int bcm_timer_module_enable(bcm_timer_module_id module_id, int enable)
+{
+	if (enable)
+		unblock_timer();
+	else
+		block_timer();
+	return 0;
+}
+
+int bcm_timer_create(bcm_timer_module_id module_id, bcm_timer_id *timer_id)
+{
+	module_id = 0;
+	return timer_create(CLOCK_REALTIME, NULL, (timer_t *)timer_id);
+}
+
+int bcm_timer_delete(bcm_timer_id timer_id)
+{
+	return timer_delete((timer_t)timer_id);
+}
+
+int bcm_timer_gettime(bcm_timer_id timer_id, struct itimerspec *timer_spec)
+{
+	return -1;
+}
+
+int bcm_timer_settime(bcm_timer_id timer_id, const struct itimerspec *timer_spec)
+{
+	return timer_settime((timer_t)timer_id, 0, timer_spec, NULL);
+}
+
+int bcm_timer_connect(bcm_timer_id timer_id, bcm_timer_cb func, int data)
+{
+	return timer_connect((timer_t)timer_id, (void *)func, data);
+}
+
+int bcm_timer_cancel(bcm_timer_id timer_id)
+{
+	timer_cancel((timer_t)timer_id);
+	return 0;
+}
+int bcm_timer_change_expirytime(bcm_timer_id timer_id, const struct itimerspec *timer_spec)
+{
+	timer_change_settime((timer_t)timer_id, timer_spec);
+	return 1;
+}

Property changes on: src/linux_timer.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/nvram_env.h
===================================================================
--- src/nvram_env.h	(revision 0)
+++ src/nvram_env.h	(revision 7299)
@@ -0,0 +1,13 @@
+#define ENV_BLK_SIZE 0x1000
+
+#ifdef CONFIG_DUAL_IMAGE
+#define ENV_UBOOT_SIZE 0x1000
+#endif
+
+extern		void  nvram_printenv(int index, int argc, char *argv[]);
+extern unsigned char *nvram_getenv  (int index, unsigned char *name);
+extern		int   nvram_setenv  (int index, int argc, char *argv[]);
+extern		int   nvram_buff_setenv  (int index, int argc, char *argv[]);
+extern 		int   do_nvram_commit(int index);
+extern unsigned	long  crc32	 (unsigned long, const unsigned char *, unsigned);
+

Property changes on: src/nvram_env.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/wl_linux.c
===================================================================
--- src/wl_linux.c	(revision 0)
+++ src/wl_linux.c	(revision 7299)
@@ -0,0 +1,77 @@
+/*
+ * Wireless network adapter utilities (linux-specific)
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: wl_linux.c 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include <typedefs.h>
+#include <wlioctl.h>
+#include <wlutils.h>
+
+int
+wl_ioctl(char *name, int cmd, void *buf, int len)
+{
+	struct ifreq ifr;
+	wl_ioctl_t ioc;
+	int ret = 0;
+ 	int s;
+
+	/* open socket to kernel */
+	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+		perror("socket");
+		return errno;
+	}
+
+	/* do it */
+	ioc.cmd = cmd;
+	ioc.buf = buf;
+	ioc.len = len;
+	strncpy(ifr.ifr_name, name, IFNAMSIZ);
+	ifr.ifr_data = (caddr_t) &ioc;
+	if ((ret = ioctl(s, SIOCDEVPRIVATE, &ifr)) < 0)
+		if (cmd != WLC_GET_MAGIC)
+			perror(ifr.ifr_name);
+
+	/* cleanup */
+	close(s);
+	return ret;
+}
+
+int
+wl_hwaddr(char *name, unsigned char *hwaddr)
+{
+	struct ifreq ifr;
+	int ret = 0;
+ 	int s;
+
+	/* open socket to kernel */
+	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+		perror("socket");
+		return errno;
+	}
+
+	/* do it */
+	strncpy(ifr.ifr_name, name, IFNAMSIZ);
+	if ((ret = ioctl(s, SIOCGIFHWADDR, &ifr)) == 0)
+		memcpy(hwaddr, ifr.ifr_hwaddr.sa_data, ETHER_ADDR_LEN);
+
+	/* cleanup */
+	close(s);
+	return ret;
+}	
+

Property changes on: src/wl_linux.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/nvram_linux.c
===================================================================
--- src/nvram_linux.c	(revision 7302)
+++ src/nvram_linux.c	(revision 7299)
@@ -34,8 +34,10 @@
 
 //link to sdk lib
 #include "nvram.h"
-#include <linux/autoconf.h>
 
+//TODO masked by frankzhou
+//#include <linux/autoconf.h>
+
 /* 3G/4G Wireless broadband device definition. */
 #if defined(EZP_PROD_CAT_M) || defined(EZP_PROD_CAT_N) 
 #include "ezpcom-lib.h"
Index: src/nvram_ezpacket6239.h
===================================================================
--- src/nvram_ezpacket6239.h	(revision 0)
+++ src/nvram_ezpacket6239.h	(revision 7299)
@@ -0,0 +1,2631 @@
+/*
+ * EZ Packet product default NVRAM values
+ *
+ * Copyright 2006, 2007 EZ Packet Technologies
+ * All Rights Reserved.
+ */
+
+/*
+ * Router default NVRAM values
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ *
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: defaults.c,v 1.104 2005/05/25 12:31:20 honor Exp $
+ */
+
+#ifndef _NVRAM_EZPACKET_H
+#define _NVRAM_EZPACKET_H
+
+#include <bcmnvram.h>
+
+/* HW dependent definition. */
+#ifdef CONFIG_EZP_ARCH_RT305X
+#include "nvram_ezpacket-rt305x.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_RT3883
+#include "nvram_ezpacket-rt3883.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_AS500
+#include "nvram_ezpacket-as500.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_BRCM
+#include "nvram_ezpacket-brcm.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_OX810
+#include "nvram_ezpacket-ox810.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_RTL865X
+#include "nvram_ezpacket-rtl865x.h"
+#endif /* CONFIG_EZP_ARCH_RTL865X */
+
+#if (LAN_NUM == 1)
+    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^hp.com^custom^^^0^100^200^30"
+    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
+#elif (LAN_NUM == 2)
+    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^hp.com^custom^^^0^100^200^30|default^0^2001:db8:feed:b10::^2001:db8:feed:b10::^2001:db8:feed:b10::^hp.com^custom^^^0^100^200^30"
+    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^|2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^64^^^^^^^^^^"
+#else
+    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^hp.com^custom^^^0^100^200^30"
+    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
+#endif
+#define EZP_PROD_FW_VERSION "V1.00(BWQ.1)C0"
+#define WL_COUNTRY_CODE "US"
+#define WL_REGION_ABAND "7"
+
+#if ( EZP_PROD_SUBCAT == 0 )
+
+#define FL_HWADDR_RULE_MAX "64"
+#define CT_MAX "20000"
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "0"
+#define BW_DBM_RULE_MAX "0"
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define SBM_MAX "0"
+#define DBM_MAX "0"
+#define FL_RULE_NUM "3"
+#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
+#define BW_ENABLE "0"
+#define BW_SBM_RULE_NUM "0"
+#define BW_SBM_RULE ""
+#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "10"
+#define FTPD_USER_RULE_MAX "4"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "4"
+#define ISHOST_RULE_MAX "4"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "0"
+#define SCHED_RULE ""
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "0"
+#define SCHED1_RULE ""
+
+/* VPN comes in. Note: No VPN in this subcat.*/
+#if ( WAN_NUM == 1 )
+
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+
+#elif ( WAN_NUM == 2 )
+
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+#else
+#error "Undefined amount of LAN/WAN interfaces"
+#endif /* VPN */
+
+#elif ( EZP_PROD_SUBCAT == 1 )
+
+#define FL_HWADDR_RULE_MAX "64"
+#define CT_MAX "20000"
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define BW_DBM_RULE_MAX "32"
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define SBM_MAX "8"
+#define DBM_MAX "8"
+#define FL_RULE_NUM "3"
+#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "0"
+#define BW_SBM_RULE ""
+#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "10"
+#define FTPD_USER_RULE_MAX "4"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "4"
+#define ISHOST_RULE_MAX "4"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "0"
+#define SCHED_RULE ""
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "0"
+#define SCHED1_RULE ""
+
+/* VPN comes in. Note: No VPN in this subcat.*/
+#if ( WAN_NUM == 1 ) /* EZP_PROD_CAT: "B" */
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+
+#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+#else
+#error "Undefined amount of LAN/WAN interfaces"
+#endif /* VPN */
+
+#elif ( EZP_PROD_SUBCAT == 2 )
+
+#define FL_HWADDR_RULE_MAX "64"
+
+/* PGP consumes too much memory and leaves less for conntrack. */
+#if defined(EZP_PROD_CAT_C) || defined (EZP_PROD_CAT_T) || defined (EZP_PROD_CAT_D) 
+#define CT_MAX "16000"
+#else
+#define CT_MAX "16000"
+#endif
+
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+
+#if defined(EZP_PROD_SUBSUBCAT_L)
+#define BW_DBM_RULE_MAX "0"
+#define BW_SBM_RULE_MAX "64"
+#define SBM_MAX "64"
+#define DBM_MAX "1"
+#define BW_DBM_RULE_NUM "0"
+#define BW_DBM_RULE "DBM^0^192.168.1.20^192.168.1.27^8^"
+#else
+#define BW_DBM_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define SBM_MAX "8"
+#define DBM_MAX "8"
+#define BW_DBM_RULE_NUM "1"
+#define BW_DBM_RULE "DBM^1^192.168.1.20^192.168.1.27^8^"
+#endif
+
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define FL_RULE_NUM "0"
+#define FL_RULE ""
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "10"
+#define USER_SBM_DEFAULT_IPADDR_START ""
+#define USER_SBM_DEFAULT_IPADDR_END   ""
+#define USER_SBM1 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM2 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM3 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM4 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM5 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM6 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM7 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM8 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define GuestLANtoLAN "GuestLANtoLAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
+#define GuestLANtoWAN "GuestLANtoWAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
+#define BW_SBM_RULE USER_SBM1"|"USER_SBM2"|"USER_SBM3"|"USER_SBM4"|"USER_SBM5"|"USER_SBM6"|"USER_SBM7"|"USER_SBM8"|"GuestLANtoLAN"|"GuestLANtoWAN
+#if (LAN_NUM == 1)
+    #define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#elif (LAN_NUM == 2)
+    #define LAN_DHCPS_GUESTLAN "default^0^33^32^86400^hp.com^^ispdns^^^^^none^opendns^opendns"
+    #define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns|"LAN_DHCPS_GUESTLAN
+#else
+    #define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#endif
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "10"
+#define FTPD_USER_RULE_MAX "8"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "8"
+#define ISHOST_RULE_MAX "8"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "8"
+#define SCHED_RULE "^1^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "8"
+#define SCHED1_RULE "^1^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
+
+/* VPN comes in. Note: No VPN in this subcat except MR-108N.*/
+#if ( WAN_NUM == 1 ) 
+#if defined(EZP_PROD_CAT_M)
+#define PPTPD_SESSION_MAX 5	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "5"
+#else
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#endif
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+
+#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+#else
+#error "Undefined amount of LAN/WAN interfaces"
+#endif /* VPN */
+
+#elif ( EZP_PROD_SUBCAT == 3 )
+
+#define FL_HWADDR_RULE_MAX "64"
+#define CT_MAX "20000"
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define BW_DBM_RULE_MAX "32"
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define SBM_MAX "16"
+#define DBM_MAX "16"
+#define FL_RULE_NUM "3"
+#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "0"
+#define BW_SBM_RULE ""
+#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "15"
+#define FTPD_USER_RULE_MAX "16"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "16"
+#define ISHOST_RULE_MAX "16"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "0"
+#define SCHED_RULE ""
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "0"
+#define SCHED1_RULE ""
+
+/* VPN comes in. */
+#if ( WAN_NUM == 1 ) /* EZP_PROD_CAT: "B" "C", subcat = 3, x116 series */
+#define PPTPD_SESSION_MAX 16	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "16"
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+
+#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
+#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "32"
+#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "32"
+#define IPSEC_RULE_MAX "0"
+#else
+#error "Undefined amount of LAN/WAN interfaces"
+#endif /* VPN */
+
+#elif ( EZP_PROD_SUBCAT == 4 )
+
+#define FL_HWADDR_RULE_MAX "128"
+#define CT_MAX "60000"
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define BW_DBM_RULE_MAX "32"
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define SBM_MAX "16"
+#define DBM_MAX "16"
+#define FL_RULE_NUM "3"
+#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "0"
+#define BW_SBM_RULE ""
+#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "15"
+#define FTPD_USER_RULE_MAX "32"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "32"
+#define ISHOST_RULE_MAX "32"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "0"
+#define SCHED_RULE ""
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "0"
+#define SCHED1_RULE ""
+
+#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "32"
+#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "32"
+#define IPSEC_RULE_MAX "32"
+
+#elif ( EZP_PROD_SUBCAT == 5 )
+
+#define FL_HWADDR_RULE_MAX "64"
+#define CT_MAX "80000"
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define BW_DBM_RULE_MAX "32"
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define SBM_MAX "32"
+#define DBM_MAX "32"
+#define FL_RULE_NUM "3"
+#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "0"
+#define BW_SBM_RULE ""
+#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "15"
+#define FTPD_USER_RULE_MAX "32"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "32"
+#define ISHOST_RULE_MAX "32"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "0"
+#define SCHED_RULE ""
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "0"
+#define SCHED1_RULE ""
+
+#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "32"
+#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "32"
+#define IPSEC_RULE_MAX "32"
+
+#elif ( EZP_PROD_SUBCAT == 6 )
+
+#define FL_HWADDR_RULE_MAX "64"
+#define CT_MAX "100000"
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define BW_DBM_RULE_MAX "32"
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define SBM_MAX "64"
+#define DBM_MAX "64"
+#define FL_RULE_NUM "3"
+#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "0"
+#define BW_SBM_RULE ""
+#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "15"
+#define FTPD_USER_RULE_MAX "32"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "32"
+#define ISHOST_RULE_MAX "32"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "0"
+#define SCHED_RULE ""
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "0"
+#define SCHED1_RULE ""
+
+#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "32"
+#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "32"
+#define IPSEC_RULE_MAX "32"
+
+#elif ( EZP_PROD_SUBCAT == 7 )
+
+#define FL_HWADDR_RULE_MAX "64"
+#define CT_MAX "120000"
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define BW_DBM_RULE_MAX "32"
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define SBM_MAX "64"
+#define DBM_MAX "64"
+#define FL_RULE_NUM "3"
+#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "0"
+#define BW_SBM_RULE ""
+#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "15"
+#define FTPD_USER_RULE_MAX "64"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "64"
+#define ISHOST_RULE_MAX "64"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "0"
+#define SCHED_RULE ""
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "0"
+#define SCHED1_RULE ""
+
+
+#define PPTPD_SESSION_MAX 64	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "64"
+#define L2TPD_SESSION_MAX 64	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "64"
+#define IPSEC_RULE_MAX "32"
+
+#else
+
+#error "Undefined product subcategory"
+
+#endif /* EZP_PROD_SUBCAT */
+
+#define SUBCAT_MAX  7
+#define FW_UPGRADE_RULE "ftpget^192.168.100.178^^^^zyfw_info"
+
+/* WAN amount dependent definition. */
+#if ( WAN_NUM == 1 )
+#define WAN_MAIN_RULE "WAN1^1^1500^1^1^0"
+#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
+#define WAN_DETECT_RULE "^0^ping^^60^8"
+#define WAN_WEIGHT_RULE "1^1"
+#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^"
+#define WAN_DHCP_RULE "^^86400"
+#define WAN_HTC_RULE "^^86400^512^0"
+#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^"
+#define WAN_STATICV6_RULE "2001:db8:feed:b01::2^64^2001:db8:feed:b01::1^^"
+#define WAN_DHCPV6_RULE "^^86400^stateful"
+#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^"
+#define WAN_WWAN_RULE "1^0^0^internet^^auto^chap^^^0^300^20^20^1492^1492^*99***1#^0^0^0^0^0^0^1^0"
+#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap"
+#define WAN_DNS_RULE "ispdns^^ispdns^"
+#define WAN_DNSV6_RULE "ispdns^^ispdns^"
+#define WAN_WWAN_PROBE_RULE "^^^^^^^"
+#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
+#define WAN_BIGPOND_RULE "0^61.9.192.13^^"
+#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^"
+#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^"
+#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^"
+#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
+#define RT_RIP_RULE "none"
+#define NAT_RULE "1"
+#define FR_RULE ""
+#define FR_RULE_NUM "0"
+#define FR_DMZ_RULE "^0^"
+#define PT_RULE "^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0"
+
+#elif ( WAN_NUM == 2 )
+#define WAN_MAIN_RULE "WAN1^1^1500^1^0^0|WAN2^1^1500^1^1^0"
+#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155|A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
+#define WAN_DETECT_RULE "^0^ping^208.67.222.222^60^8|^0^ping^208.67.222.222^60^8"
+#define WAN_WEIGHT_RULE "1^1|1^1"
+#define WAN_FAILOVER_RULE "0^wan0^wan1"
+#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^|10.1.2.25^24^10.1.2.254^10.1.2.254^^"
+#define WAN_DHCP_RULE "^^86400|^^86400"
+#define WAN_HTC_RULE "^^86400^512^0|^^86400^512^0"
+#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^|chap^^^0^300^5^5^1492^1492^isp^^"
+#define WAN_STATICV6_RULE "^^^^|^^^^"
+#define WAN_DHCPV6_RULE "^^86400^stateful|^^86400^stateful"
+#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^|^^^0^300^5^5^1492^1492^isp^"
+#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap|^static^^^^^^1^300^isp^^disabled^chap"
+#define WAN_DNS_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
+#define WAN_DNSV6_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
+#define WAN_WWAN_PROBE_RULE "^^^^^^^|^^^^^^^"
+#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
+#define WAN_BIGPOND_RULE "0^61.9.192.13^^|0^61.9.192.13^^"
+#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^|0^^hwaddr^"
+#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^|WAN2_DDNS^0^dyndns^^^^"
+#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^|WAN2_OPENDNS^0^^^0^"
+#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
+#define RT_RIP_RULE "none"
+#define NAT_RULE "1"
+#define FR_RULE "HTTP^0^wan0^tcp^80^80^192.168.1.20^^|HTTPS^0^wan0^tcp^443^443^192.168.1.20^^|POP3^0^wan0^tcp^110^110^192.168.1.20^^|POP3S^0^wan0^tcp^995^995^192.168.1.20^^|SMTP^0^wan0^tcp^25^25^192.168.1.20^^|SMTPS^0^wan0^tcp^465^465^192.168.1.20^^|SSH^0^wan0^tcp^22^22^192.168.1.21^^|eMule^0^wan1^both^4662^4672^192.168.1.21^^"
+#define FR_RULE_NUM "8"
+#define FR_DMZ_RULE "^0^|^0^"
+
+#else
+#error "Undefined amount of WAN interface(s)"
+#endif
+
+/* LAN amount dependent definition. */
+#if ( LAN_NUM == 1 )
+    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0"
+    #define LAN_STATIC_RULE_DEFAULT "192.168.1.1^24^^192.168.1.1^^0^^^192.168.1.1^24^192.168.1.2^24"
+    #define LAN_HWADDR_CLONE_RULE "0^"
+#elif ( LAN_NUM == 2 )
+    #define LAN_MAIN_GUESTLAN "GuestLAN^0^1500^1^1^0"
+    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0|"LAN_MAIN_GUESTLAN
+    #define LAN_STATIC_GUESTLAN "192.168.100.1^24^^192.168.100.1^^0^^^192.168.100.1^24^192.168.1.2^24"
+    #define LAN_STATIC_RULE_DEFAULT "192.168.1.1^24^^192.168.1.1^^0^^^192.168.1.1^24^192.168.1.2^24|"LAN_STATIC_GUESTLAN
+    #define LAN_HWADDR_CLONE_RULE "0^"
+#else
+#error "Undefined amount of LAN interface(s)"
+#endif
+
+#if (WL_NUM > 0) /* WL_NUM is not zero. */
+
+#if ( WL_NUM == 1 )
+/* XXX: #define WL_BASIC_RULE "1^0^100^6^0" */
+#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
+#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
+#define WL_WDS_RULE "disabled^1"
+#define WL1_WDS_RULE "disabled^1"
+#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
+#define WL_MODE_RULE "normal^2^0"
+#define WL1_MODE_RULE "normal^2^0"
+#define WL_WPS_RULE "7^^0"
+#define WL1_WPS_RULE "7^^0"
+#define WL_WPS_STA_RULE "0^^^^^^"
+#define WL1_WPS_STA_RULE "0^^^^^^"
+#define WL_ACL_MAX "64"
+#define WL_ACL_BASIC_RULE "1^disabled"
+#elif ( WL_NUM == 2 )
+/* #define WL_BASIC_RULE "1^0^100^6^0|1^0^100^6^0" */
+#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
+#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
+#define WL_WDS_RULE "disabled^1|disabled^1"
+#define WL1_WDS_RULE "disabled^1|disabled^1"
+#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128|15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
+#define WL_MODE_RULE "normal^0^0|normal^0^0"
+#define WL1_MODE_RULE "normal^0^0|normal^0^0"
+#define WL_WPS_RULE "0^^0|0^^0"
+#define WL1_WPS_RULE "0^^0|0^^0"
+#define WL_WPS_STA_RULE "0^^^^^^|0^^^^^^"
+#define WL1_WPS_STA_RULE "0^^^^^^|0^^^^^^"
+#define WL_ACL_MAX "64"
+#define WL_ACL_BASIC_RULE "1^disabled"
+#else
+#error "Undefined amount of WLAN interfaces"
+#endif
+
+#if ( WL_NUM == 1 )
+  /* WDS */
+  #define WL0_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
+  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
+  #define WL0_WDS_SEC_WEP_RULE "|||"
+  #define WL0_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
+  /* APCLI */
+  #define WL0_APCLI_RULE "0^^^disabled^0"
+  #define WL1_APCLI_RULE "0^^^disabled^0"
+  #define WL0_APCLI_SEC_WEP_RULE "1^^^^^^open"
+  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
+  #define WL0_APCLI_SEC_WPA_RULE "^tkip"
+  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
+  #define WL0_APCLI_SEC_WPA2_RULE "^aes"
+  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
+  #if (WL0_RULE_MAX == 2)
+    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
+    #define WL0_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
+    #define WL0_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
+  #elif (WL0_RULE_MAX == 4)
+    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
+    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
+    #define WL0_SSID_RULE "WP777_2.4G|WP777_2.4G_SSID1|WP777_2.4G_SSID2|WP777_2.4G_SSID3"
+    #define WL5G_SSID_RULE "WP777_5G|WP777_5G_SSID1|WP777_5G_SSID2|WP777_5G_SSID3"
+    #define WL0_SEC_RULE "disabled|disabled|disabled|disabled"
+    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
+    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_WPA_RULE   "12345678^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
+    #define WL0_SEC_WPA2_RULE   "12345678^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
+    #define WL0_SEC_5G_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_5G_WPA_RULE   "12345678^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
+    #define WL0_SEC_5G_WPA2_RULE   "12345678^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
+  #else
+/* default set visual interface number to 2 */
+    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
+    #define WL0_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
+    #define WL0_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
+  #endif
+#endif
+
+#if ( WL_NUM == 2 )
+  /* WDS */
+  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
+  #define WL1_WDS_SEC_WEP_RULE "|||"
+  #define WL1_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
+  /* APCLI */
+  #define WL1_APCLI_RULE "1^^^disabled"
+  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
+  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
+  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
+  #if (WL1_RULE_MAX == 2)
+    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL1_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
+    #define WL1_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
+  #elif (WL1_RULE_MAX == 4)
+    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6|AXIMCom7|AXIMCom8"
+    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
+    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
+    #define WL1_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
+    #define WL1_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
+  #else
+    /* default set visual interface number to 2 */
+    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL1_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
+    #define WL1_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
+  #endif
+#endif
+#endif /* WL_NUM is not zero. */
+/* 
+ * The following macros are to stringify the macro argument. Please refer to
+ * "C Preprocessor - Stringification".
+ */
+#define xstr(s) str(s)
+#define str(s)  #s 
+
+static struct nvram_tuple nvram_ezpacket_default[] = {
+    { "fw_version", xstr(EZP_PROD_VERSION), 
+        NVRAM_NONE, 
+        0 
+    },   
+    /* Added for different customer's version definition. */
+    { "prod_fw_version", EZP_PROD_FW_VERSION, 
+        NVRAM_NONE, 
+        0 
+    },   
+    { "ifup_types", "lan wan", 
+        NVRAM_NONE, 
+        0 
+    },   
+    { "wan_num", xstr(WAN_NUM),     /* How many WAN interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wan_weight_type", "1", 
+        NVRAM_NONE,
+        0 
+    },   /* WAN weight type [0 (manual) |1 (auto) ] */
+
+#if (WAN_NUM >= 1)
+    /* WAN0 */
+    /* WAN H/W parameters */
+
+    { "wan0_ifname", WAN0_IFNAME, 
+        NVRAM_NONE,
+        0 
+    },    /* WAN interface name */
+    { "wan0_ifnames", WAN0_IFNAMES, 
+        NVRAM_NONE,
+        0 
+    },       /* WAN interface names */
+    { "wan0_hwname", WAN0_HWNAME, 
+        NVRAM_NONE,
+        0 
+    },        /* WAN driver name (e.g. et1) */
+    { "wan0_device", WAN0_DEVICE, 
+        NVRAM_NONE,
+        0 
+    },        /* WAN device name */
+    { "wan0_device_backup", WAN0_DEVICE, 
+        NVRAM_NONE,
+        0 
+    },        /* WAN device name */
+    { "psyslocation", "deskTop", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN driver name (e.g. et1) */
+    { "psyscontact", "everyone@local.com", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN device name */
+    { "psysservices", "sysservices^72", 
+        NVRAM_NONE,
+        0 
+    }, 
+    {"rip_mode","0",
+       NVRAM_NONE,
+       0
+
+    },       /*rip mode: 0 rip,1 ripng, 2 both*/
+ 	{"ripng_config","lan&wan",
+	   NVRAM_NONE,
+       0
+	},/*interface value:lan/wan/lan&wan*/
+    { "snmpd_ro_username", "admin", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_ro_passwd", "12345678", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_rw_username", "user", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_rw_passwd", "12345678", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_ro_community", "private", 
+        NVRAM_NONE,
+        0 
+   },
+   { "snmpd_rw_community", "public", 
+        NVRAM_NONE,
+        0 
+   },
+	/* WAN device name */
+    /* MR routers use wwan as default*/
+#if defined(EZP_PROD_CAT_M) 
+    { "wan0_proto", "dhcp", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN proto */
+#else
+    { "wan0_proto", "dhcp", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN proto */
+#endif
+    { "wan0_protov6", "link-local", 
+        NVRAM_NONE,
+        0 
+    },        /* IPv6 WAN proto */
+    { "wan0_rtmark", "0x10000000", 
+        NVRAM_NONE,
+        0 
+    }, /* WAN device routing mark. */
+    { "wan0_ports", WAN0_PORTS, 
+        NVRAM_NONE,
+        0 
+    }, /* WAN device port assignment. */
+    { "wan0_bw_mode", "auto",
+        NVRAM_NONE,
+        0
+    }, /* WAN DBM mode: auto/expert */
+
+    /* WAN temporary parameters */
+    { "wan0_ipaddr", "",
+       NVRAM_TEMP,
+       0 
+    },        /* WAN IP address */
+    /* WAN temporary parameters */
+    { "wan0_ipaddrv6", "",
+       NVRAM_TEMP,
+       0 
+    },        /* WAN IP address */
+    { "wan0_netmask", "",
+       NVRAM_TEMP,
+       0 
+    },       /* WAN netmask */
+    { "wan0_mask", "", 
+       NVRAM_TEMP,
+       0 
+    },          /* WAN netmask2 */
+    { "wan0_prefixv6", "", 
+       NVRAM_TEMP,
+       0 
+    },          /* WAN netmask2 */
+    { "wan0_maskv6", "", 
+       NVRAM_TEMP,
+       0 
+    },          /* WAN netmask2 */
+    { "wan0_gateway", "",
+       NVRAM_TEMP,
+       0 
+    },       /* WAN gateway */
+    { "wan0_gatewayv6", "",
+       NVRAM_TEMP,
+       0 
+    },       /* WAN gateway */
+    { "wan0_dns", "",
+       NVRAM_TEMP,
+       0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "wan0_dnsv6", "",
+       NVRAM_TEMP,
+       0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "wan0_wins", "",
+       NVRAM_TEMP,
+       0 
+    },          /* x.x.x.x x.x.x.x ... */
+    { "wan0_failcount", "",
+       NVRAM_TEMP,
+       0 
+    },          /* WAN detection failure count */
+    { "wan0_upnp_proto", "",
+       NVRAM_TEMP,
+       0 
+    },          /* WAN UPnP proto */
+    { "wan0_upnp_ifname", "",
+       NVRAM_TEMP,
+       0 
+    },          /* WAN UPnP ifname */
+    /* Because we have v4/v6 on the same device, we have to check both when
+     * trying to bring down an interface */
+    { "wan_up_down_state_rule", "0^0",
+       NVRAM_TEMP,
+       0 
+    },          /* v4^v6 */
+
+#endif
+
+    /* WAN main rules */
+    { "wan_main_rule", WAN_MAIN_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^mtu^stp^upnp */
+    /* WAN proto parameters rules */
+    { "wan_static_rule", WAN_STATIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* ipaddr^mask^gateway^dns1^dns2^wins */
+    { "wan_dhcp_rule", WAN_DHCP_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* hostname^domain^lease*/
+    { "wan_pppoe_rule", WAN_PPPOE_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* auth^username^passwd^demand^idletime^echo_failure^redialperiod^
+         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr^servname
+         */
+    /* V6 WAN proto parameters rules */
+    { "wan_staticv6_rule", WAN_STATICV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* ipaddr^length^gateway^dns1^dns2 */
+    { "wan_dhcpv6_rule", WAN_DHCPV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* hostname^domain^lease^type[0:stateless|1:stateful] */
+    { "wan_pppoev6_rule", WAN_PPPOEV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* username^passwd^servicename^
+         * demand^idletime^echo_failure^redialperiod^
+         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr */
+#define WAN_TUNNEL6_RULE "72.52.104.74^2001:470:1f04:d1c::2/64^2001:470:1f04:d1c::1"
+    { "wan_tunnel6_rule", WAN_TUNNEL6_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* brokerv4addr^v6ipaddr_length^v6gateway */
+    { "wan_wwan_rule", WAN_WWAN_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
+         * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
+         * ctrltty^devname^flag^turbolink
+         */
+    /* wan_pptp_l2tp_rule */
+    { "wan_pptp_l2tp_rule", WAN_PPTP_L2TP_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* serverip^iptype[static|dhcp]^ipaddr^netmask^gateway^username^
+           passwd^nailup^timeout^pppiptype[isp|custom]^custom_ipaddr^
+           encmode[disabled|mppe]^auth[chap|pap|none] */
+    { "wan_wwan_probe_rule", WAN_WWAN_PROBE_RULE, 
+        NVRAM_TEMP,
+        0 
+    },  /* brand^model^signal^numtty^datatty^ctrltty^devname^flag */
+    { "wan_bigpond_rule", WAN_BIGPOND_RULE,
+        NVRAM_NONE,
+        0 
+    },  /* enable^server^username^passwd */
+    { "wan_dns_rule", WAN_DNS_RULE,
+        NVRAM_NONE,
+        0 
+    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
+    { "wan_dnsv6_rule", WAN_DNSV6_RULE,
+        NVRAM_NONE,
+        0 
+    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
+    /* WAN hwaddr */ 
+    { "wan_hwaddr_rule_default", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0
+    },  /* hwaddr */
+    /* WAN hwaddr clone */ 
+    { "wan_hwaddr_clone_rule", WAN_HWADDR_CLONE_RULE, 
+        NVRAM_NONE,
+        0
+    },  /* enable[0|1]^hwaddr^addrtype[ipaddr|hwaddr]^ipaddr */
+    /* DDNS */
+    { "wan_ddns_rule", WAN_DDNS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^type[dyndns|tzo|zoneedit]^username^
+           passwd^hostname */
+    /* OpenDNS */
+    { "wan_opendns_rule", WAN_OPENDNS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^username^passwd^redirect[0|1]^label */
+    /* WAN status rule */
+    { "wan_st_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* WAN status rule */
+    { "wan_stv6_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* LAN status rule */
+    { "lan_st_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* LAN status rule */
+    { "lan_stv6_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* WLAN status rule */
+    { "wlan_st_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    { "lan_num", xstr(LAN_NUM), 
+        NVRAM_NONE,
+        0 
+    },  /* How many LAN interfaces are available.*/
+#if LAN_NUM >= 1
+    /* LAN0 */
+    /* LAN H/W parameters */
+
+    { "lan0_ifname", LAN0_IFNAME, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN interface name */
+    { "lan0_ifnames", LAN0_IFNAMES, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN interface names */
+    { "lan0_hwname", LAN0_HWNAME, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN driver name (e.g. et1) */
+    { "lan0_device", LAN0_DEVICE, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN device name */
+    { "lan0_proto", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN device name */
+    { "lan0_protov6", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN IPv6 device name */
+    { "lan0_ports", LAN0_PORTS, 
+        NVRAM_NONE,
+        0 
+    }, /* LAN device port assignment. */
+
+    /* LAN temporary parameters */
+    { "lan0_ipaddr", "", 
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IP address */
+    /* LAN temporary parameters */
+    { "lan0_ipaddrv6", "2001:db8:feed:b00::1",
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IPv6 address */
+    { "lan0_netmask", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN netmask */
+    { "lan0_mask", "", 
+       NVRAM_TEMP,
+        0 
+    },          /* LAN netmask2 */
+    { "lan0_prefixv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 prefix */
+    { "lan0_maskv6", "64", 
+       NVRAM_TEMP,
+        0 
+    },          /* LAN IPv6 netmask2 */
+    { "lan0_gateway", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN gateway */
+    { "lan0_gatewayv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 gateway */
+    { "lan0_dns", "", 
+       NVRAM_TEMP,
+        0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "lan0_wins", "", 
+       NVRAM_TEMP,
+        0 
+    },          /* x.x.x.x x.x.x.x ... */
+#if LAN_NUM >= 2
+    /* LAN0 */
+
+    { "lan1_ifname", LAN1_IFNAME, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN interface name */
+    { "lan1_proto", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN device name */
+    { "lan1_protov6", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN IPv6 device name */
+    /* LAN temporary parameters */
+    { "lan1_ipaddr", "", 
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IP address */
+    { "lan1_ipaddrv6", "2001:db8:feed:b00::1",
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IPv6 address */
+    { "lan1_netmask", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN netmask */
+    { "lan1_mask", "", 
+       NVRAM_TEMP,
+        0 
+    },          /* LAN netmask2 */
+    { "lan1_prefixv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 prefix */
+    { "lan1_maskv6", "64", 
+       NVRAM_TEMP,
+        0 
+    },          /* LAN IPv6 netmask2 */
+    { "lan1_gateway", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN gateway */
+    { "lan1_gatewayv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 gateway */
+    { "lan1_dns", "", 
+       NVRAM_TEMP,
+        0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "lan1_wins", "", 
+       NVRAM_TEMP,
+        0 
+    },          /* x.x.x.x x.x.x.x ... */
+#endif /* LAN_NUM >= 2*/
+#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
+    { "vlan_rule", VLAN_RULE,
+       NVRAM_NONE,
+        0 
+    },      /* name^enable[0|1]^ifname^vid^portmember^flag */
+    { "vlan_rule_num", xstr(VLAN_RULE_NUM),
+       NVRAM_NONE,
+        0 
+    },      
+    { "vlan_rule_max", xstr(VLAN_RULE_MAX),
+       NVRAM_NONE,
+        0 
+    },
+    { "vlanport_rule", VLANPORT_RULE,
+       NVRAM_NONE,
+        0 
+    },       /* name^portid^pvid^tag^gmemb */
+    { "vlanport_rule_num", xstr(VLANPORT_RULE_NUM),
+       NVRAM_NONE,
+        0 
+    },      
+    { "vlanport_rule_max", xstr(VLANPORT_RULE_MAX),
+       NVRAM_NONE,
+        0 
+    },
+    { "br_rule", BR_RULE,
+       NVRAM_NONE,
+        0
+    },      /* name^enable[0|1]^ifnames^flag */
+    { "br_rule_num", xstr(BR_RULE_NUM),
+       NVRAM_NONE,
+        0
+    },
+    { "br_rule_max", xstr(BR_RULE_MAX),
+       NVRAM_NONE,
+        0
+    },
+#ifdef CONFIG_EZP_ARCH_RT305X
+    NVRAM_EZPACKET_DEFAULT_RT305X_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_2
+#endif
+#elif defined(CONFIG_EZP_ARCH_RT3883)
+    NVRAM_EZPACKET_DEFAULT_RT3883_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_2
+#endif
+#endif
+#endif
+
+#ifdef CONFIG_EZP_ARCH_BRCM
+    NVRAM_EZPACKET_DEFAULT_BRCM_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_2
+#endif
+#endif
+#endif
+
+#ifdef CONFIG_EZP_ARCH_AS500
+    NVRAM_EZPACKET_DEFAULT_AS500_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_2
+#endif
+    NVRAM_EZPACKET_DEFAULT_AS500_SWAP
+    NVRAM_EZPACKET_DEFAULT_AS500_INITD
+#endif
+
+    { "lan_main_rule", LAN_MAIN_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^mtu^stp^weight */
+    { "lan_hwaddr_rule_default", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0
+    },  /* hwaddr */
+    { "lan_static_rule_default", LAN_STATIC_RULE_DEFAULT, 
+        NVRAM_NONE,
+        0 
+    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
+    { "lan_static_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
+    { "lan_staticv6_rule_default", LAN_STATICV6_RULE_DEFAULT, 
+        NVRAM_NONE,
+        0 
+    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
+         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
+    { "lan_staticv6_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
+         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
+    /* DHCP server parameters */
+    { "lan_dhcps_rule", LAN_DHCPS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^start^num^lease^domain^wins^
+           dnstype[ispdns|opendns|custom|none]^dnsaddr1^
+           dnsaddr2^dnsaddr3^dnsaddr4^dnstype2^dnstype3^dnstype4 */
+    /* LAN hwaddr clone */
+    { "lan_dhcpsv6_rule", LAN_DHCPSV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^pppoe_prefix^static_prefix^dhcp_prefix^
+           domain^
+           dnstype[auto|custom]^
+           dnsaddr1^dnsaddr2^type[1|0]^
+           start^end^lifetime" */
+    /* LAN hwaddr clone */
+    { "lan_hwaddr_clone_rule", LAN_HWADDR_CLONE_RULE, 
+        NVRAM_NONE,
+        0
+    },  /* enable[0|1]^hwaddr[XX:XX:XX:XX:XX:XX] */
+    /* Guest lan rule */
+#define GUEST_LAN_RULE "0^rai3^br2^1^192.168.2.1^24^0^0^1^hp_guest.com^33^32"
+    { "guest_lan_rule", GUEST_LAN_RULE,
+        NVRAM_NONE,
+        0
+    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
+         * domain : domain name for this dns group
+         * start : dhcp offering start ip address
+         * count : total count dhcp server can offer
+         * */
+#define GUEST_5G_LAN_RULE "0^ra3^br2^1^192.168.2.1^24^0^0^1^hp_5g_guest.com^33^32"
+    { "guest1_lan_rule", GUEST_5G_LAN_RULE,
+        NVRAM_NONE,
+        0
+    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
+         * domain : domain name for this dns group
+         * start : dhcp offering start ip address
+         * count : total count dhcp server can offer
+         * */
+    /* MASK */
+    { "rt_mask", "0xF0000000", 
+        NVRAM_NONE,
+        0 },      /* Routing mask: 4-bit */
+    { "reserved_mask", "0x0F000000", 
+        NVRAM_NONE,
+        0 },      /* Reserved mask: 4-bit */
+    { "fl_mask", "0x0000FFFF", 
+        NVRAM_NONE,
+        0 },      /* FL mask: 16-bit */
+    { "fl_mark_default", "0x0000FFFF", 
+        NVRAM_NONE,
+        0 },      /* FL mask: 16-bit */
+
+    /* turboNAT */
+    { "turbonat_enable", "0", 
+        NVRAM_NONE,
+        0 
+    },   /* enable [0|1] */
+    /* Session Manager */
+    { "sm_mode", "fast", 
+        NVRAM_NONE,
+        0 
+    },   /* mode [fast|regular|slow] */
+    /* Bandwidth */
+    /*{ "bw_rule", BW_RULE,*/
+    { "bw_rule", "0^32768^32768",
+        NVRAM_NONE,
+        0 
+    },   /* enable^bw_upload^bw_download */
+    { "bw_monitor_rule", "1",
+        NVRAM_NONE,
+        0 
+    },   /* enable */
+    { "bw_tc_mask", "0x00FF0000", 
+        NVRAM_NONE,
+        0 
+    },   /* BW mask */
+    /* SBM */
+    { "bw_sbm_mask", "0x00FF0000", 
+        NVRAM_NONE,
+        0 
+    },   /* BW mask */
+    /*{ "bw_app_rule", BW_APP_RULE, */
+    /* Easy mode */
+    { "bw_ezmodesort_rule", "Game Console|VoIP|Instant Messenger|Web Surfing|P2P/FTP|E-Mail",
+        NVRAM_NONE,
+        0 
+    },   /* catname */
+    { "bw_ezmodesort_rule_num", "6", 
+        NVRAM_NONE,
+        0 
+    },
+    { "bw_ezmodesort_rule_max", "6", 
+        NVRAM_NONE,
+        0 
+    },
+    { "bw_app_rule_num", "11",
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+    { "bw_app_rule_max", "32", 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+#define XBOX_APP "appl^0^1^1^Game Console^XBox Live^3074,3390,3932,5555^88,1900,3074,3776,3777^1^50^1^1^50^1^1^10^1^1^10^1"
+#define PLAYSTATION_APP "appl^0^1^1^Game Console^PlayStation^5223^3478,3479,3658,4658^1^50^1^1^50^1^1^10^1^1^10^1"
+#define MSN_GAME_APP "appl^0^1^1^Game Console^MSN Game Zone^6667,28800:29000^6667,28800:29000^1^50^1^1^50^1^1^10^1^1^10^1"
+#define BATTLENET_APP "appl^0^1^1^Game Console^Battlenet^40,112,6112,4000,6113:9119^^1^50^1^0^50^1^1^10^1^0^10^1"
+#define VOIP_APP "appl^0^1^1^VoIP^VoIP^5060^5060^1^50^1^0^50^1^1^10^1^0^10^1"
+#define IM_APP "appl^0^1^1^Instant Messenger^Instant Messenger^6891:6901,1863^1863,5190,6901^1^50^1^0^50^1^1^10^1^0^10^1"
+#define WEB_APP "appl^0^1^1^Web Surfing^Web Surfing^80,443^^1^50^1^0^50^1^1^10^1^0^10^1"
+#define FTP_APP "appl^0^1^1^P2P/FTP^FTP^21,22^^1^50^1^0^50^1^1^10^1^0^10^1"
+#define EMULE_APP "appl^0^1^1^P2P/FTP^eMule^4662^4672^1^50^1^0^50^1^1^10^1^0^10^1"
+#define BT_APP "appl^0^1^1^P2P/FTP^BitTorrent^tport^uport^1^50^1^1^50^1^1^10^1^1^10^1"
+#define EMAIL_APP "appl^0^1^1^E-Mail^E-Mail^110,995,25,465,587,220,143,993^^1^50^1^0^50^1^1^10^1^0^10^1"
+    { "bw_app_rule", XBOX_APP"|"PLAYSTATION_APP"|"MSN_GAME_APP"|"BATTLENET_APP"|"VOIP_APP"|"IM_APP"|"WEB_APP"|"FTP_APP"|"EMULE_APP"|"BT_APP"|"EMAIL_APP,
+        NVRAM_NONE,
+        0 
+    }, /* name^enable^index^prio^cat^serv^
+          tcp_port[port|port_beg:port_end]^
+          udp_port[port|port_beg:port_end]^
+          lan_tcp_enable^lan_tcp_bw^lan_tcp_min[0:max bw|1:min bw]^
+          lan_udp_enable^lan_udp_bw^lan_udp_min[0:max bw|1:min bw]^
+          wan_tcp_enable^wan_tcp_bw^wan_tcp_min[0:max bw|1:min bw]^
+          wan_udp_enable^wan_udp_bw^wan_udp_min[0:max bw|1:min bw] */
+#define ACCESS1 "access^ROGROUP^\"\"^any^noauth^exact^all^none^none"
+#define ACCESS2 "access^RWGROUP^\"\"^any^noauth^exact^all^all^all"
+    { "snmpd_access_rule", ACCESS1"|"ACCESS2,
+        NVRAM_NONE,
+        0 
+    }, 
+#define GROUP1 "group^RWGROUP^v1^rw"
+#define GROUP2 "group^RWGROUP^v2c^rw"
+#define GROUP3 "group^RWGROUP^usm^rw"    
+#define GROUP4 "group^ROGROUP^v1^ro"
+#define GROUP5 "group^ROGROUP^v2c^ro"
+#define GROUP6 "group^ROGROUP^usm^ro"    
+	{ "snmpd_group_rule", GROUP1"|"GROUP2"|"GROUP3"|"GROUP4"|"GROUP5"|"GROUP6,
+        NVRAM_NONE,
+        0 
+    }, 
+	{ "snmpd_view_rule", "view^all^included^.1^80",
+        NVRAM_NONE,
+        0 
+    }, 
+    { "bw_sbm_rule", BW_SBM_RULE,
+        NVRAM_NONE,
+        0 
+    }, /* name^enable^inipaddr_start^inipaddr_end^proto^extif^
+          bw_towan^bw_tolan^apptype^prio^
+          outipaddr_start^outipaddr_end^inport^outport^reserve_bw */
+    { "bw_sbm_rule_num", BW_SBM_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+    { "bw_sbm_rule_max", BW_SBM_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+    /* Policy-based routing */
+    { "rt_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },   /* Routing [0|1] */
+    //{ "rt_rule", RT_RULE, 
+    { "rt_rule", "",
+        NVRAM_EMPTY,
+        0 
+    }, /* name^enable[0|1]^srcipaddr_start^srcipaddr_end^dstipaddr_start^
+          dstipaddr_end^proto^srcport_start^srcport_end^dstport_start^
+          dstport_end^extif^routing_type[default|static]^gateway_ipaddr^
+          netmask^matric */
+    //{ "rt_rule_num", "1",
+    { "rt_rule_num", "0",
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing RT rules */
+    { "rt_rule_max", RT_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing RT rules */
+
+    /*  routing */
+    { "rt_conn_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },   /* Routing cache [0|1] */
+    { "rt_rip_rule", RT_RIP_RULE, 
+        NVRAM_NONE,
+        0 
+    }, /* rip[v1/v2/none] */
+    { "nat_rule", NAT_RULE, 
+        NVRAM_NONE,
+        0 
+    }, /* enable */
+#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
+    { "hwnat_rule", HWNAT_RULE, 
+        NVRAM_NONE,
+        0 
+    }, /* enable */
+#endif
+    /* web url/content filtering rule */
+    { "wf_enable", "1",
+        NVRAM_NONE,
+        0
+    }, /* web url filtering [0|1] */
+    { "wf_content_rule", "0^0^0^0^0^",
+        NVRAM_NONE,
+        0
+    }, /* activex_enable^java_enable^proxy_enable^cookie_enable^url_enable^trustipaddr */
+    { "wf_rule", "",
+        NVRAM_EMPTY,
+        0
+    }, /* enable^keyword^type^access */
+    { "wf_rule_num", "0",
+        NVRAM_NONE,
+        0
+    },
+    { "wf_rule_max", WF_RULE_MAX,
+        NVRAM_NONE,
+        0
+    },
+    /* IGMP related rule */
+    { "igmp_proxy_rule", IGMP_PROXY_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* enable */
+    { "igmp_snoop_rule", IGMP_SNOOP_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* enable^p1^p2^p3^p4 */
+    /* Schedule rule */
+    { "sched_enable", "0", 
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    { "sched1_enable", "0", // for 5g
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    /* Schedule rule */
+    { "sched_enable_bak", "0", 
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    { "sched1_enable_bak", "0", // for 5g
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    { "sched_rule", SCHED_RULE,
+        NVRAM_NONE,
+        0 
+    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
+         /* cat:   category, which will cause invoking action
+          * month: apply month
+          * date:  apply date of month
+          * wkday: apply day of week
+          * beghr,begmin: begin hour and minute of day
+          * endhr,endmin: end hour and minute of day
+          * wlanstatus: wlan status
+          */
+    { "sched1_rule", SCHED1_RULE,
+        NVRAM_NONE,
+        0 
+    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
+         /* cat:   category, which will cause invoking action
+          * month: apply month
+          * date:  apply date of month
+          * wkday: apply day of week
+          * beghr,begmin: begin hour and minute of day
+          * endhr,endmin: end hour and minute of day
+          * wlanstatus: wlan status
+          */
+    { "sched_rule_num", SCHED_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+    { "sched_rule_max", SCHED_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+    { "sched1_rule_num", SCHED1_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+    { "sched1_rule_max", SCHED1_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+
+    { "fw_upgrade_rule", FW_UPGRADE_RULE,
+        NVRAM_NONE,
+        0 
+    },   /* method^server^path^username^passwd^inf_filename */
+         /* rule set 0 for default online firmware upgrade settings */
+    { "fw_info_rule", "",
+        NVRAM_TEMP,
+        0 
+    },   /* model^version^revision^date^size^filename^release_note^
+            info_ok[1:got fw info | 0:no info]^
+            fw_ok[1:got fw | 0:no fw]^
+            relnote_ok[1:got release note | 0:no release note] */
+         /* rule set 0 for default online firmware upgrade settings */
+    
+    /* RRDCOLLECT */
+    { "rrd_enable", "0", 
+        NVRAM_NONE,
+        0 },    /* RRDcollect client */
+
+    /* Cron */
+    { "cron_rule", "1^1^02 4 * * *", 
+        NVRAM_NONE,
+        0 
+    }, /* enable^ntp_enable[0|1]^ntp_interval */
+
+    /* NTP */
+    //{ "ntp_rule", "^1^pool^pool.ntp.org^^UTC-8^^^^^^^^^^^^^^",
+    { "ntp_rule", "^1^pool^pool.ntp.org^^GMT0BST,M3.5.0/2,M10.5.0/2^0^^^^^^^0^^^^^^^^0^", 
+        NVRAM_NONE,
+        0 
+    }, /* name^enable[0|1]^type^pool^ipaddr^zone^
+          custom_time[0|1]^year^mon^date^hour^min^sec^
+          daylight_saving[0|1]^
+          ds_start_mon^ds_start_day^ds_start_hour^
+          ds_end_mon^ds_end_day^ds_end_hour^customized^
+          custom_server[0|1]^serv_ipaddr */
+
+    /* SSH */
+    { "ssh_rule", "^0^8123", 
+        NVRAM_NONE,
+        0 
+    },       /* name^enable[0|1]^port */
+
+/* Added by Abocom */
+    /* log parameters */
+    { "log_selected_num", "9", 
+        NVRAM_NONE,
+        0 
+    },        /* Log selection number */
+    { "log_index", "show_all", 
+        NVRAM_NONE,
+        0 
+    },
+    /* Log Index */    
+    { "log_rule", LOG_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^ipaddr^ipt_enable^web_mgmt^dns^ppp^
+           upnp^wireless^ntp^sys_warning^dhcp_serv^dhcp_cli^
+           ddns^firewall */
+    /* uPnP */
+    { "upnp_rule", "^1^0^wan0^lan0^5555", 0 },
+    /* name^enable[0|1]^pmp_enable[0|1]^extif^inif^port */
+
+    /* Filters */
+    { "fl_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },    /* fl_enable [0|1] */
+    { "fl_rule", FL_RULE, 
+        NVRAM_EMPTY,
+        0 
+    },    /* name^enable[0|1]^extif^inif^proto^srcip^srcmask^
+                                dstip^dstmask^srcport^dstport^
+                                action[0(DROP)|1(ACCEPT)]^mark^bw_idx^
+                                sched_idx */
+
+    { "fl_rule_num", FL_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },      /* The amount of existing log rules */
+    { "fl_rule_max", FL_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },
+    { "fl_rule_default", "1", 
+        NVRAM_NONE,
+        0 
+    },
+
+    { "fl_hwaddr_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },    /* fl_hwaddr_enable [0|1] */
+    { "fl_hwaddr_rule", "", 
+        NVRAM_EMPTY,
+        0 
+    },    /* name^acl_enable[0|1]^dhcp_enable^arp_enable^hwaddr^
+             action[0(DROP)|1(ACCEPT)]^ipaddr */
+    { "fl_hwaddr_rule_num", "0", 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing fl_hwaddr rules */
+    { "fl_hwaddr_rule_max", FL_HWADDR_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },
+    { "fl_hwaddr_rule_default", "1", 
+        NVRAM_NONE,
+        0 
+    },
+
+    /* Port forwards */
+    { "fr_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },  /* fr_enable [0|1] */
+    { "fr_rule", FR_RULE, 
+        NVRAM_EMPTY,
+        0 
+    },  /* name^enable[0|1]^extif^proto[tcp|udp|both]^extport_start^extport_end^ipaddr^inport_start^inport_end */
+    { "fr_rule_num", FR_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },      /* fr_rule_num */
+    { "fr_rule_max", FR_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },      /* fr_rule_max */
+    { "fr_dmz_rule", FR_DMZ_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable[0|1]^ipaddr */
+
+    /* Port triggle */
+    { "pt_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },  /* pt_enable [0|1] */
+    { "pt_rule", PT_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable^proto[tcp|udp|all]^port_start^port_end^trig_port_start^trig_port_end */
+    { "pt_rule_num", "12", 
+        NVRAM_NONE,
+        0 
+    },  /* pt_rule_num */
+    { "pt_rule_max", PT_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },  /* pt_rule_max */
+
+#if ( WL_NUM > 0 )
+    /* Wireless interface */
+    { "wl_num", xstr(WL_NUM), 
+        NVRAM_NONE,
+        0 
+    },      /* Enable (1) or disable (0) radio */
+    /* Wireless parameters */
+    { "wl_region_default", "0", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },      /* Region code default */
+    { "wl_region", "", 
+        NVRAM_DEFAULT,
+        0 
+    },      /* Region code */
+    { "wl_countrycode_default", WL_COUNTRY_CODE, 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },      /* Region code */
+    { "wl_countrycode", WL_COUNTRY_CODE, 
+        NVRAM_DEFAULT,
+        0 
+    },      /* Region code */
+    { "wl_regionaband_default", WL_REGION_ABAND, 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },      /* Region code */
+    { "wl_regionaband", "", 
+        NVRAM_DEFAULT,
+        0 
+    },      /* Region code */
+    { "wl_ieee80211h", "1", 
+        NVRAM_DEFAULT,
+        0 
+    },      /* IEEE802.11H */
+    /* Physical interface related rules*/
+    { "wl_rule_num", xstr(WL_NUM),     /* How many WLan interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl_rule_max", xstr(WL_NUM),     /* How many WLan interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    /* Virtual interface related rules for wl0/wl1... */
+    { "wlv_rule_num", xstr(WL0_RULE_NUM) ,     /* How many virtual wl0 interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wlv_rule_max", xstr(WL0_RULE_MAX),     /* Max virtual wl0 interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl_enabled_rule", "0", 
+        NVRAM_TEMP,
+        0 
+    },      /* Enable (1) or disable (0) radio */
+    /* This setting reserved the must original wireless setting
+     * such as hardware button status. Some application ,like schedular, 
+     * may change the wifi at run time. We can use this setting to restore
+     * the original setting. 
+     * Currently, only /sbin/ezp-wifionoff may change its value */
+    { "wl_origset_rule", "1",
+        NVRAM_NONE,
+        0 
+    },      /* enable */
+    { "wl1_origset_rule", "1",
+        NVRAM_NONE,
+        0 
+    },      /* enable  for 5g */
+    { "wl_basic_rule", WL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^net_mode^txpower^channel^bisolation */
+    { "wl5g_basic_rule", WL5G_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^net_mode^txpower^channel^bisolation */
+    { "wl_advanced_rule", WL_ADVANCED_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
+               gmode^gmode_protection^afterburner^frameburst^
+               txburst[0:disable|1:enable->1]^
+               pktaggr[0:disable|1:enable->0]^
+               txmode[0:None|1:CCK|2:OFDM->0]^
+
+               rdg[0:disable|1:enablei->0]^
+               linkadapt[0:disable|1:enable->0]^
+               htc[0:disable|1:enable->0]^
+
+               htbw[0:20|1:20/40->1]^
+               gi[0:long|1:short->1]^
+               opmode[0:mixed|1:GreenField->0]^
+               mcs[0~15,32,33=auto->33]^
+               mpdu[0 none, 1~7 -> 5]^
+               amsdu[0:disable|1:enable->0]^
+
+               autoba[0:disable|1:enable->1]^
+               bawinsize[1~64,default=8,iot=64->64]^
+               badecline[0:disable|1:enable->1->0]^
+               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
+               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
+             */
+    { "wl1_advanced_rule", WL1_ADVANCED_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
+               gmode^gmode_protection^afterburner^frameburst^
+               txburst[0:disable|1:enable->1]^
+               pktaggr[0:disable|1:enable->0]^
+               txmode[0:None|1:CCK|2:OFDM->0]^
+
+               rdg[0:disable|1:enablei->0]^
+               linkadapt[0:disable|1:enable->0]^
+               htc[0:disable|1:enable->0]^
+
+               htbw[0:20|1:20/40->1]^
+               gi[0:long|1:short->1]^
+               opmode[0:mixed|1:GreenField->0]^
+               mcs[0~15,32,33=auto->33]^
+               mpdu[0 none, 1~7 -> 5]^
+               amsdu[0:disable|1:enable->0]^
+
+               autoba[0:disable|1:enable->1]^
+               bawinsize[1~64,default=8,iot=64->64]^
+               badecline[0:disable|1:enable->1->0]^
+               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
+               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
+             */
+    { "wl_wds_rule", WL_WDS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
+    { "wl1_wds_rule", WL1_WDS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
+    { "wl_wme_rule", WL_WME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* sta_bk^Sta_be^sta_vi^sta_vo^ap_bk^ap_be^ap_vi^ap_vo^no_ack^max_assoc */
+    { "wl_mode_rule", WL_MODE_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[normal|ap|ur|wisp]^
+             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
+             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
+    { "wl1_mode_rule", WL1_MODE_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[normal|ap|ur|wisp]^
+             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
+             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
+    { "wl_wps_rule", WL_WPS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
+    { "wl1_wps_rule", WL1_WPS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
+    { "wl_wps_sta_rule", WL_WPS_STA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
+    { "wl1_wps_sta_rule", WL1_WPS_STA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
+    { "wl_led_status_rule", "9^9",
+        NVRAM_TEMP,
+        0 
+    },      /* wl^wps */
+    { "wl0_basic_rule", WL0_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^hidden^rate^wme^isolation */
+    { "wl1_basic_rule", WL1_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^hidden^rate^wme^isolation */
+    { "wl0_ifname_rule", WL0_IFNAME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl0_ssid_rule", WL0_SSID_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl1_ssid_rule", WL5G_SSID_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl0_sec_rule", WL0_SEC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* secmode */
+    { "wl0_sec_wep_rule", WL0_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^
+               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl0_sec_wpa_rule", WL0_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^session_timeout */
+    { "wl0_sec_wpa2_rule", WL0_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
+    { "wl1_sec_rule", WL1_SEC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* secmode */
+    { "wl1_sec_wep_rule", WL0_SEC_5G_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^
+               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl1_sec_wpa_rule", WL0_SEC_5G_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^session_timeout */
+    { "wl1_sec_wpa2_rule", WL0_SEC_5G_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
+/* acl policy can apply to each ssid, we add rule according to ssid number */
+#if (WL0_RULE_MAX >= 1)
+    { "wl00_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl00_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl00_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl00_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 2)
+    { "wl01_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl01_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl01_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl01_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 4)
+    { "wl02_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl02_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl02_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl02_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+    { "wl03_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl03_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl03_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl03_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#endif /* WL0_RULE_MAX >= 4 */
+#endif /* WL0_RULE_MAX >= 2 */
+#endif /* WL0_RULE_MAX >= 1 */
+/*  5g acl policy can apply to each ssid, we add rule according to ssid number */
+#if (WL0_RULE_MAX >= 1)
+    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl10_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl10_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl10_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 2)
+    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl11_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl11_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl11_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 4)
+    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl12_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl12_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl12_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl13_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl13_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl13_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#endif /* WL0_RULE_MAX >= 4 */
+#endif /* WL0_RULE_MAX >= 2 */
+#endif /* WL0_RULE_MAX >= 1 */
+#if 0
+#if ( WL_NUM >= 2 )
+    { "wl1_basic_rule", WL1_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^hidden^rate^wme^isolation */
+    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ifname */
+    { "wl1_ssid_rule", WL1_SSID_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl1_sec_rule", WL1_SEC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* secmode */
+    { "wl1_sec_wep_rule", WL1_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^
+               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl1_sec_wpa_rule", WL1_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^session_timeout */
+    { "wl1_sec_wpa2_rule", WL1_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
+/* acl policy can apply to each ssid, we add rule according to ssid number */
+#if (WL0_RULE_MAX >= 1)
+    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl10_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl10_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl10_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 2)
+    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl11_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl11_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl11_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 4)
+    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl12_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl12_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl12_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl13_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl13_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl13_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#endif /* WL0_RULE_MAX >= 4 */
+#endif /* WL0_RULE_MAX >= 2 */
+#endif /* WL0_RULE_MAX >= 1 */
+#endif /* WL_NUM >= 2 */
+#endif
+    /* wds related rules */
+    { "wl0_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_wds_basic_rule", WL0_WDS_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* hwaddr^secmode */
+    { "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },  
+    { "wl1_wds_basic_rule", WL1_WDS_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* hwaddr^secmode */
+    { "wl0_wds_sec_wep_rule", "|||", 
+        NVRAM_NONE,
+        0 
+    },      /* key */
+    { "wl0_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl1_wds_sec_wep_rule", "|||", 
+        NVRAM_NONE,
+        0 
+    },      /* key */
+    { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    /* apcli related rules */
+    { "wl0_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_apcli_rule", WL0_APCLI_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^ssid^bssid^secmode */
+    { "wl0_apcli_sec_wep_rule", WL0_APCLI_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl0_apcli_sec_wpa_rule", WL0_APCLI_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl0_apcli_sec_wpa2_rule", WL0_APCLI_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl1_apcli_rule", WL1_APCLI_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^ssid^bssid^secmode */
+    { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
+    { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    }, 
+#if ( WL_NUM >= 2 )
+    //{ "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
+     //   NVRAM_NONE,
+     //   0 
+    //},   
+   // { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
+   //     NVRAM_NONE,
+   //     0 
+  //  },   
+    //{ "wl1_wds_basic_rule", "^disabled|^disabled|^disabled|^disabled", 
+    //    NVRAM_NONE,
+    //    0 
+    //},      /* mac^secmode */
+    //{ "wl1_wds_sec_wep_rule", "|||", 
+    //    NVRAM_NONE,
+    //    0 
+    //},      /* key */
+   // { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
+   //     NVRAM_NONE,
+   //     0 
+   // },      /* key^crypto */
+    /* apcli related rules */
+    //{ "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
+     //   NVRAM_NONE,
+     //   0 
+   // },   
+    //{ "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
+    //    NVRAM_NONE,
+    //    0 
+    //},   
+   // { "wl1_apcli_rule", WL1_APCLI_RULE, 
+   //     NVRAM_NONE,
+  //      0 
+  //  },      /* enable^ssid^bssid^secmode */
+  //  { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
+  //      NVRAM_NONE,
+  //      0 
+  //  },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
+  //  { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
+   //     NVRAM_NONE,
+  //      0 
+  //  },      /* key^crypto */
+  //  { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
+  //      NVRAM_NONE,
+  //      0 
+  //  },      /* key^crypto */
+#endif
+#endif
+    /* for firewall */
+    { "fw_rule", "1^1^1^1^1^0^1^0", 
+        NVRAM_NONE,
+        0 
+    },  /* enable^syn_enable^icmp_enable^icmp_redir_enable
+           ^icmp_ping_enable^rpfilter_enable^state_enable^
+           wantolan_enable[0:drop non-DNAT wan-to-lan connection request|1:otherwise] */
+    { "nat_pass_rule", "1^1^1^1^1^1^1", 
+        NVRAM_NONE,
+        0 
+    },  /* enable^ipsec_enable^pptp_enable^l2tp_enable^
+           h323_enable^rtsp_enable^mms_enable */
+    /* TTL */
+    { "ttl_rule", "^0^64", 
+        NVRAM_NONE,
+        0 
+    },        /* TTL name^enable[1|0]^value */
+    /* TOS */
+    { "tos_rule", "1^1^1^1^1^1^1", 
+        NVRAM_NONE,
+        0 
+    },   /* TOS enable^icmp_enable^dns_enable^ssh_enable^
+            telnet_enable^check_enable^ack_enable */
+    /* MSS */
+    { "mss_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },        /* TOS [1|0] */
+
+    /* SNAT */
+    { "snat_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },        /* SNAT [1|0] */
+
+    /* Conntrack max amount */
+    { "ct_max", CT_MAX, 
+        NVRAM_NONE,
+        0 
+    },        /* SNAT [1|0] */
+    /* Web server parameters */
+    { "http_rule_default", "^1^0^admin^1234^80^^5", 
+        NVRAM_NONE,
+        0 
+    }, /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
+    { "http_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    },  /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
+    {"rip_conf_rule_default", "0^0^0^0^0^0^0^0",
+      NVRAM_NONE,
+      0
+    },
+   {"rip_conf_rule", "",
+      NVRAM_DEFAULT,
+      0
+    },
+    { "snmpd_user_rule_default", "1^1^1^1", 
+        NVRAM_NONE,
+        0 
+    }, /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
+    { "snmpd_user_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    }, 
+    { "snmpd_com2sec_rule_default", "com2sec^ro^default""|""com2sec^rw^default", 
+        NVRAM_NONE,
+        0 
+    }, 
+    { "snmpd_com2sec_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    }, /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
+    { "adtool_rule", "any^^4^any^^4^any^^4",
+        NVRAM_NONE,
+        0
+    }, /* pingiface^pinghost^pingcnt^arpingiface^arpinghost^arpingcnt^tracerouteiface^traceroutehost^traceroutecnt */
+    { "stats_rule", STATS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^stime^ifnames */
+    { "stats_type", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_ifname */
+    { "stats_ifname", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_ifname */
+    { "stats_proto", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_ifname */
+    { "stats_interval", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_time hourly:60, daily:600, weekly: 3600, monthly: 3600*6 */
+    { "no_root_swap", "1", 
+        NVRAM_NONE,
+        0 
+	}, /* no_root_swap */ 
+    /* enable^pptp_enable^ipsec_enable^l2tp_enable */
+    { "smb_vpn_passthrough_rule", "1^1^1", 
+        NVRAM_NONE,
+        0 
+    }, 
+    /* IPsec */
+	{ "ipsec_enable", "0",
+		NVRAM_NONE,
+		0    
+	},   
+#ifdef IPSEC_RULE_MAX
+#undef IPSEC_RULE_MAX
+#define IPSEC_RULE_MAX "32"
+#else 
+#define IPSEC_RULE_MAX "32"
+#endif
+	{ "ipsec_rule_max", IPSEC_RULE_MAX,
+		NVRAM_NONE,
+		0    
+	}, /* value */
+	{ "ipsec_rule_num", "0", 
+		NVRAM_NONE,
+		0    
+	}, /* value */
+	{ "ipsec_rule", "",  
+		NVRAM_NONE,
+		0    
+	},
+	/*
+ name^enable^mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init^ike_keymode^psk^rsa^ca^adv^phase1_mode^phase1_auth^phase1_encrypt^phase1_group^phase1_id^phase2_auth^phase2_encrypt^phase2_group^phase1_lifetime^phase2_lifetime^dpd_enable^dpd_interval^dpd_timeout
+
+	 */
+	{ "ipsec_status_rule", "",
+		NVRAM_TEMP,
+		0
+	}, /* phase1[none|established]^phase2[none|established] */
+
+#undef PPTPD_SESSION_MAX
+#undef PPTPD_USER_RULE_MAX
+#undef L2TPD_SESSION_MAX
+#undef L2TPD_USER_RULE_MAX
+#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "32"
+#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "32"
+	/*pptpd*/
+    { "pptpd_rule", "0^pptp-server^60^1460^1482^192.168.38.1^" xstr(PPTPD_SESSION_MAX) "^192.168.39.1^" xstr(PPTPD_SESSION_MAX) "^1^^0^0^1^0^0^1^0^1",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^name^redialperiod^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable[0|1]^dns^chap_enable[0|1]^mschap_enable[0|1]^mschapv2_enable[0|1]^eap_enable[0|1]^pap_enable[0|1]^mppe128_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
+
+    { "pptpd_user_rule", "",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^username^provider^passwd^ipaddr */
+    { "pptpd_user_rule_num", "0",
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+    { "pptpd_user_rule_max", PPTPD_USER_RULE_MAX,
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+    { "pptpd_session_max", xstr(PPTPD_SESSION_MAX), 
+        NVRAM_NONE,
+        0 
+    },  /* value */
+    /*l2tpd*/
+    { "l2tpd_rule", "0^l2tp-server^1400^1400^192.168.48.1^" xstr(L2TPD_SESSION_MAX) "^192.168.49.1^" xstr(L2TPD_SESSION_MAX) "^1^^1^0^1^1",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^name^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable^dns^chap_enable[0|1]^pap_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
+    { "l2tpd_user_rule", "",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^username^provider^passwd^ipaddr */
+    { "l2tpd_user_rule_num", "0",
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+    { "l2tpd_user_rule_max", L2TPD_USER_RULE_MAX,
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+
+	{ "wol_rule", "",
+		NVRAM_NONE,
+		0 
+	},  /* name^enable^bcast^hwaddr^iface^passwd */
+	{ "lang_default", "EN", 
+		NVRAM_NONE,
+		0 
+	},  /* Default web language support */
+	{ "lang", "", 
+		NVRAM_DEFAULT,
+		0 
+	},  /* Web language support */
+	{ "brand", "HPn", 
+		NVRAM_NONE,
+		0 
+	},  /* Brand name - CSS style and SSID. */
+#define UPNP_FRIENDLYNAME   "HPn WP777 Internet Sharing Gateway"
+#define MANUFACTURER        "HPn Communications Corp."
+#define MANUFACTURERURL     "http://www.hp.com"
+#define MODELDESCRIPTION    "HPn WP777 Internet Sharing Gateway"
+#define MODELNAME           "HPn Internet Sharing Gateway"
+#define MODELNUMBER         "WP777"
+#define MODELURL            ""
+#define SERIALNUMBER        "A19003848"
+#define UDN                 "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e"
+#define PRESENTATIONURL     ""
+    { "upnpxml_rule", UPNP_FRIENDLYNAME"^"MANUFACTURER"^"MANUFACTURERURL"^"MODELDESCRIPTION"^"MODELNAME"^"MODELNUMBER"^"MODELURL"^"SERIALNUMBER"^"UDN"^"PRESENTATIONURL, 
+        NVRAM_NONE,
+        0 
+    },  /* friendlyName^manufacturer^manufacturerURL^modelDescription^
+         * modelName^modelNumber^modelURL^serialNumber^UDN^presentationURL */
+    { "igd", "WP777 IGD Version 1.00", 
+        NVRAM_NONE,
+        0 
+    },  /* Brand name - CSS style and SSID. */
+    { "udn", "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e", 
+        NVRAM_NONE,
+        0 
+    },  /* Brand name - CSS style and SSID. */
+    { "model", "WP777 Internet Gateway Device", 
+        NVRAM_NONE,
+        0 
+    },              /* Product model */
+    { "license_key", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },              /* Product model */
+    { "hostname", "WP777",
+        NVRAM_NONE,
+        0 
+    },           /* Hostname */
+    { "prod_cat", xstr(EZP_PROD_CAT), 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },           /* Product category */
+    { "prod_subcat", xstr(EZP_PROD_SUBCAT), 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* Product subcategory */
+    { "prod_subsubcat", xstr(EZP_PROD_SUBSUBCAT), 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* Product sub-subcategory */
+    { "machine_id", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* Machine id */
+    { "arch", ARCH, 
+        NVRAM_PROTECTED,
+        0 
+    },        /* Arch */
+    { "license_invalid", "",
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* License status */
+    { "bootcount", "",
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* License bootcount */
+/* Added by Abocom */
+    { "weather_rule", "1^UKXX1428^c", 
+        NVRAM_NONE,
+        0 
+    },        /* enable^city^degree */
+    { "wl_easy_mode_rule", "0", 
+        NVRAM_NONE,
+        0 
+    },        /* mode 0->2.4g  1->5g */
+    { "FirstConfig", "1", 
+        NVRAM_NONE,
+        0 
+    },        /* FirstConfig for web server */
+     { "zyfw_fw_file", "", 
+        NVRAM_NONE,
+        0 
+    },        /* file name for online FW upgrade */
+    { "zyfw_size", "", 
+        NVRAM_NONE,
+        0 
+    },        /* file size for online FW upgrade */
+    { "WISP_Channel", "0", 
+        NVRAM_NONE,
+        0 
+    },        /* Save WISP's wireless Channel */	
+    { "WISP1_Channel", "0", 
+        NVRAM_NONE,
+        0 
+    },        /* Save WISP's wireless 5g Channel */	
+    { "AP_Channel", "0", 
+        NVRAM_NONE,
+        0 
+    },		/* Save AP's wireless Channel */
+    { "AP1_Channel", "36", 
+        NVRAM_NONE,
+        0 
+    },		/* Save AP's wireless Channel */
+    { "wl_wisp_mode_rule", "wisp^ap", 
+        NVRAM_NONE,
+        0 
+    }, /*wifi 2.4g as wisp,wifi 5g as 
+       ap mode when choose wisp mode*/
+    /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
+    { 0, 0, 0 ,0 }
+};
+
+#endif /*_NVRAM_EZPACKET_H */
Index: src/files.c
===================================================================
--- src/files.c	(revision 0)
+++ src/files.c	(revision 7299)
@@ -0,0 +1,108 @@
+/*
+
+	Tomato Firmware
+	Copyright (C) 2006 Jonathan Zarate
+
+*/
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+
+#include <bcmnvram.h>
+#include "shutils.h"
+#include "shared.h"
+
+
+int f_exists(const char *path)	// note: anything but a directory
+{
+	struct stat st;
+	return (stat(path, &st) == 0) && (!S_ISDIR(st.st_mode));
+}
+
+unsigned long f_size(const char *path)	// 4GB-1	-1 = error
+{
+	struct stat st;
+	if (stat(path, &st) == 0) return st.st_size;
+	return (unsigned long)-1;
+}
+
+int f_read(const char *path, void *buffer, int max)
+{
+	int f;
+	int n;
+	
+	if ((f = open(path, O_RDONLY)) < 0) return -1;
+	n = read(f, buffer, max);
+	close(f);
+	return n;
+}
+
+int f_write(const char *path, const void *buffer, int len, unsigned flags, unsigned cmode)
+{
+	static const char nl = '\n';
+	int f;
+	int r = -1;
+	mode_t m;
+	
+	m = umask(0);
+	if (cmode == 0) cmode = 0666;
+	if ((f = open(path, (flags & FW_APPEND) ? (O_WRONLY|O_CREAT|O_APPEND) : (O_WRONLY|O_CREAT|O_TRUNC), cmode)) >= 0) {
+		if ((buffer == NULL) || ((r = write(f, buffer, len)) == len)) {
+			if (flags & FW_NEWLINE) {
+				if (write(f, &nl, 1) == 1) ++r;
+			}
+		}
+		close(f);
+	}
+	umask(m);
+	return r;
+}
+
+int f_read_string(const char *path, char *buffer, int max)
+{
+	if (max <= 0) return -1;
+	int n = f_read(path, buffer, max - 1);
+	buffer[(n > 0) ? n : 0] = 0;
+	return n;
+}
+
+int f_write_string(const char *path, const char *buffer, unsigned flags, unsigned cmode)
+{
+	return f_write(path, buffer, strlen(buffer), flags, cmode);
+}
+
+static int _f_read_alloc(const char *path, char **buffer, int max, int z)
+{
+	unsigned long n;
+
+	*buffer = NULL;
+	if (max >= 0) {
+		if ((n = f_size(path)) != (unsigned long)-1) {
+			if (n < max) max = n;
+			if ((!z) && (max == 0)) return 0;
+			if ((*buffer = malloc(max + z)) != NULL) {
+				if ((max = f_read(path, *buffer, max)) >= 0) {
+					if (z) *(*buffer + max) = 0;
+					return max;
+				}
+				free(buffer);
+			}
+		}
+	}
+	return -1;
+}
+
+int f_read_alloc(const char *path, char **buffer, int max)
+{
+	return _f_read_alloc(path, buffer, max, 0);
+}
+
+int f_read_alloc_string(const char *path, char **buffer, int max)
+{
+	return _f_read_alloc(path, buffer, max, 1);
+}

Property changes on: src/files.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/include/nvram_ezpacket.h
===================================================================
--- src/include/nvram_ezpacket.h	(revision 7302)
+++ src/include/nvram_ezpacket.h	(revision 7299)
@@ -1,2598 +0,0 @@
-/*
- * EZ Packet product default NVRAM values
- *
- * Copyright 2006, 2007 EZ Packet Technologies
- * All Rights Reserved.
- */
-
-/*
- * Router default NVRAM values
- *
- * Copyright 2005, Broadcom Corporation
- * All Rights Reserved.
- *
- * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
- *
- * $Id: defaults.c,v 1.104 2005/05/25 12:31:20 honor Exp $
- */
-
-#ifndef _NVRAM_EZPACKET_H
-#define _NVRAM_EZPACKET_H
-
-#include <bcmnvram.h>
-
-/* HW dependent definition. */
-#ifdef CONFIG_EZP_ARCH_RT305X
-#include "nvram_ezpacket-rt305x.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_RT3883
-#include "nvram_ezpacket-rt3883.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_AS500
-#include "nvram_ezpacket-as500.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_BRCM
-#include "nvram_ezpacket-brcm.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_OX810
-#include "nvram_ezpacket-ox810.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_RTL865X
-#include "nvram_ezpacket-rtl865x.h"
-#endif /* CONFIG_EZP_ARCH_RTL865X */
-
-#if (LAN_NUM == 1)
-    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^liteon.com^custom^^^0^100^200^30"
-    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
-#elif (LAN_NUM == 2)
-    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^liteon.com^custom^^^0^100^200^30|default^0^2001:db8:feed:b10::^2001:db8:feed:b10::^2001:db8:feed:b10::^liteon.com^custom^^^0^100^200^30"
-    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^|2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^64^^^^^^^^^^"
-#else
-    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^liteon.com^custom^^^0^100^200^30"
-    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
-#endif
-#define EZP_PROD_FW_VERSION "V1.00(BWQ.1)C0"
-#define WL_COUNTRY_CODE "US"
-#define WL_REGION_ABAND "7"
-
-/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
-#define FL_HWADDR_RULE_MAX "64"
-
-/* PGP consumes too much memory and leaves less for conntrack. */
-#if defined(EZP_PROD_CAT_C) || defined (EZP_PROD_CAT_T) || defined (EZP_PROD_CAT_D) 
-#define CT_MAX "16000"
-#else
-#define CT_MAX "16000"
-#endif
-
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-
-#if defined(EZP_PROD_SUBSUBCAT_L)
-#define BW_DBM_RULE_MAX "0"
-#define BW_SBM_RULE_MAX "64"
-#define SBM_MAX "64"
-#define DBM_MAX "1"
-#define BW_DBM_RULE_NUM "0"
-#define BW_DBM_RULE "DBM^0^192.168.1.20^192.168.1.27^8^"
-#else
-#define BW_DBM_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define SBM_MAX "8"
-#define DBM_MAX "8"
-#define BW_DBM_RULE_NUM "1"
-#define BW_DBM_RULE "DBM^1^192.168.1.20^192.168.1.27^8^"
-#endif
-
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define FL_RULE_NUM "0"
-#define FL_RULE ""
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "10"
-#define USER_SBM_DEFAULT_IPADDR_START ""
-#define USER_SBM_DEFAULT_IPADDR_END   ""
-#define USER_SBM1 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM2 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM3 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM4 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM5 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM6 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM7 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM8 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define GuestLANtoLAN "GuestLANtoLAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
-#define GuestLANtoWAN "GuestLANtoWAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
-#define BW_SBM_RULE USER_SBM1"|"USER_SBM2"|"USER_SBM3"|"USER_SBM4"|"USER_SBM5"|"USER_SBM6"|"USER_SBM7"|"USER_SBM8"|"GuestLANtoLAN"|"GuestLANtoWAN
-#if (LAN_NUM == 1)
-    #define LAN_DHCPS_RULE "default^1^33^32^86400^liteon.com^^dnsrelay^^^^^none^opendns^opendns^192.168.1.10^24^60"
-#elif (LAN_NUM == 2)
-    #define LAN_DHCPS_GUESTLAN "default^0^33^32^86400^liteon.com^^ispdns^^^^^none^opendns^opendns^192.168.1.10^24^60"
-    #define LAN_DHCPS_RULE "default^1^33^32^86400^liteon.com^^dnsrelay^^^^^none^opendns^opendns^192.168.1.10^24^60|"LAN_DHCPS_GUESTLAN
-#else
-    #define LAN_DHCPS_RULE "default^1^33^32^86400^liteon.com^^dnsrelay^^^^^none^opendns^opendns^192.168.1.10^24^60"
-#endif
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "10"
-#define FTPD_USER_RULE_MAX "8"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "8"
-#define ISHOST_RULE_MAX "8"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "8"
-#define SCHED_RULE "^0^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "8"
-#define SCHED1_RULE "^0^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
-
-/* VPN comes in. Note: No VPN in this subcat except MR-108N.*/
-#if ( WAN_NUM == 1 ) 
-#if defined(EZP_PROD_CAT_M)
-#define PPTPD_SESSION_MAX 5	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "5"
-#else
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#endif
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-
-#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-#else
-#error "Undefined amount of LAN/WAN interfaces"
-#endif /* VPN */
-/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
-
-
-#define SUBCAT_MAX  7
-#define FW_UPGRADE_RULE "ftpget^192.168.100.178^^^^zyfw_info"
-
-/* WAN amount dependent definition. */
-#if ( WAN_NUM == 1 )
-#define WAN_MAIN_RULE "WAN1^1^1500^1^1^0"
-#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
-#define WAN_DETECT_RULE "^0^ping^^60^8"
-#define WAN_WEIGHT_RULE "1^1"
-#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^"
-#define WAN_DHCP_RULE "^^86400"
-#define WAN_HTC_RULE "^^86400^512^0"
-#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^"
-#define WAN_STATICV6_RULE "2001:db8:feed:b01::2^64^2001:db8:feed:b01::1^^"
-#define WAN_DHCPV6_RULE "^^86400^stateful"
-#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^"
-#define WAN_WWAN_RULE "1^0^0^internet^^auto^chap^^^0^300^20^20^1492^1492^*99***1#^0^0^0^0^0^0^1^0"
-#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap"
-#define WAN_DNS_RULE "ispdns^^ispdns^"
-#define WAN_DNSV6_RULE "ispdns^^ispdns^"
-#define WAN_WWAN_PROBE_RULE "^^^^^^^"
-#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
-#define WAN_BIGPOND_RULE "0^61.9.192.13^^"
-#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^"
-#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^"
-#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^"
-#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
-#define RT_RIP_RULE "none"
-#define NAT_RULE "1"
-#define FR_RULE ""
-#define FR_RULE_NUM "0"
-#define FR_DMZ_RULE "^0^"
-#define PT_RULE "^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0"
-
-#elif ( WAN_NUM == 2 )
-#define WAN_MAIN_RULE "WAN1^1^1500^1^0^0|WAN2^1^1500^1^1^0"
-#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155|A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
-#define WAN_DETECT_RULE "^0^ping^208.67.222.222^60^8|^0^ping^208.67.222.222^60^8"
-#define WAN_WEIGHT_RULE "1^1|1^1"
-#define WAN_FAILOVER_RULE "0^wan0^wan1"
-#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^|10.1.2.25^24^10.1.2.254^10.1.2.254^^"
-#define WAN_DHCP_RULE "^^86400|^^86400"
-#define WAN_HTC_RULE "^^86400^512^0|^^86400^512^0"
-#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^|chap^^^0^300^5^5^1492^1492^isp^^"
-#define WAN_STATICV6_RULE "^^^^|^^^^"
-#define WAN_DHCPV6_RULE "^^86400^stateful|^^86400^stateful"
-#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^|^^^0^300^5^5^1492^1492^isp^"
-#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap|^static^^^^^^1^300^isp^^disabled^chap"
-#define WAN_DNS_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
-#define WAN_DNSV6_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
-#define WAN_WWAN_PROBE_RULE "^^^^^^^|^^^^^^^"
-#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
-#define WAN_BIGPOND_RULE "0^61.9.192.13^^|0^61.9.192.13^^"
-#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^|0^^hwaddr^"
-#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^|WAN2_DDNS^0^dyndns^^^^"
-#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^|WAN2_OPENDNS^0^^^0^"
-#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
-#define RT_RIP_RULE "none"
-#define NAT_RULE "1"
-#define FR_RULE "HTTP^0^wan0^tcp^80^80^192.168.1.20^^|HTTPS^0^wan0^tcp^443^443^192.168.1.20^^|POP3^0^wan0^tcp^110^110^192.168.1.20^^|POP3S^0^wan0^tcp^995^995^192.168.1.20^^|SMTP^0^wan0^tcp^25^25^192.168.1.20^^|SMTPS^0^wan0^tcp^465^465^192.168.1.20^^|SSH^0^wan0^tcp^22^22^192.168.1.21^^|eMule^0^wan1^both^4662^4672^192.168.1.21^^"
-#define FR_RULE_NUM "8"
-#define FR_DMZ_RULE "^0^|^0^"
-
-#else
-#error "Undefined amount of WAN interface(s)"
-#endif
-
-/* LAN amount dependent definition. */
-#if ( LAN_NUM == 1 )
-    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0"
-    #define LAN_STATIC_RULE_DEFAULT "192.168.1.10^24^^192.168.1.10^^0^^^192.168.1.10^24^192.168.1.10^24"
-    #define LAN_HWADDR_CLONE_RULE "0^"
-#elif ( LAN_NUM == 2 )
-    #define LAN_MAIN_GUESTLAN "GuestLAN^0^1500^1^1^0"
-    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0|"LAN_MAIN_GUESTLAN
-    #define LAN_STATIC_GUESTLAN "192.168.100.1^24^^192.168.100.1^^0^^^192.168.100.1^24^192.168.1.2^24"
-    #define LAN_STATIC_RULE_DEFAULT "192.168.1.10^24^^192.168.1.10^^0^^^192.168.1.10^24^192.168.1.10^24|"LAN_STATIC_GUESTLAN
-    #define LAN_HWADDR_CLONE_RULE "0^"
-#else
-#error "Undefined amount of LAN interface(s)"
-#endif
-
-#if (WL_NUM > 0) /* WL_NUM is not zero. */
-
-#if ( WL_NUM == 1 )
-/* XXX: #define WL_BASIC_RULE "1^0^100^6^0" */
-#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
-#define WL_AP_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
-
-#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
-#define WL_WDS_RULE "disabled^1"
-#define WL1_WDS_RULE "disabled^1"
-#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
-#define WL_MODE_RULE "ur^2^0"
-#define WL1_MODE_RULE "ur^2^0"
-#define WL_WPS_RULE "0^^0"
-#define WL1_WPS_RULE "0^^0"
-#define WL_WPS_STA_RULE "0^^^^^^"
-#define WL1_WPS_STA_RULE "0^^^^^^"
-#define WL_ACL_MAX "64"
-#define WL_ACL_BASIC_RULE "1^disabled"
-#elif ( WL_NUM == 2 )
-/* #define WL_BASIC_RULE "1^0^100^6^0|1^0^100^6^0" */
-#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
-#define WL_AP_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
-
-#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
-#define WL_WDS_RULE "disabled^1|disabled^1"
-#define WL1_WDS_RULE "disabled^1|disabled^1"
-#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128|15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
-#define WL_MODE_RULE "ur^0^0|ur^0^0"
-#define WL1_MODE_RULE "ur^0^0|ur^0^0"
-#define WL_WPS_RULE "0^^0|0^^0"
-#define WL1_WPS_RULE "0^^0|0^^0"
-#define WL_WPS_STA_RULE "0^^^^^^|0^^^^^^"
-#define WL1_WPS_STA_RULE "0^^^^^^|0^^^^^^"
-#define WL_ACL_MAX "64"
-#define WL_ACL_BASIC_RULE "1^disabled"
-#else
-#error "Undefined amount of WLAN interfaces"
-#endif
-
-#if ( WL_NUM == 1 )
-  /* WDS */
-  #define WL0_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
-  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
-  #define WL0_WDS_SEC_WEP_RULE "|||"
-  #define WL0_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
-  /* APCLI */
-  #define WL0_APCLI_RULE "1^CPE_2.4G^^disabled^0^0^0"
-  #define WL1_APCLI_RULE "1^CPE_5G^^disabled^0^0"
-  #define WL0_APCLI_SEC_WEP_RULE "1^^^^^^open"
-  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
-  #define WL0_APCLI_SEC_WPA_RULE "^tkip"
-  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
-  #define WL0_APCLI_SEC_WPA2_RULE "^aes"
-  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
-  #if (WL0_RULE_MAX == 2)
-    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
-    #define WL0_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
-    #define WL0_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
-  #elif (WL0_RULE_MAX == 4)
-    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
-    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
-    #define WL0_SSID_RULE "CPE_2.4G|CPE_2.4G_SSID1|CPE_2.4G_SSID2|CPE_2.4G_SSID3"
-    #define WL5G_SSID_RULE "CPE_5G|CPE_5G_SSID1|CPE_5G_SSID2|CPE_5G_SSID3"
-    #define WL0_SEC_RULE "disabled|disabled|disabled|disabled"
-    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
-    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_WPA_RULE   "12345678^mixed^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
-    #define WL0_SEC_WPA2_RULE   "12345678^mixed^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
-    #define WL0_SEC_5G_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_5G_WPA_RULE   "12345678^mixed^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
-    #define WL0_SEC_5G_WPA2_RULE   "12345678^mixed^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
-  #else
-/* default set visual interface number to 2 */
-    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
-    #define WL0_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
-    #define WL0_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
-  #endif
-#endif
-
-#if ( WL_NUM == 2 )
-  /* WDS */
-  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
-  #define WL1_WDS_SEC_WEP_RULE "|||"
-  #define WL1_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
-  /* APCLI */
-  #define WL1_APCLI_RULE "1^^^disabled"
-  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
-  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
-  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
-  #if (WL1_RULE_MAX == 2)
-    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL1_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
-    #define WL1_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
-  #elif (WL1_RULE_MAX == 4)
-    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6|AXIMCom7|AXIMCom8"
-    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
-    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
-    #define WL1_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
-    #define WL1_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
-  #else
-    /* default set visual interface number to 2 */
-    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL1_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
-    #define WL1_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
-  #endif
-#endif
-#endif /* WL_NUM is not zero. */
-/* 
- * The following macros are to stringify the macro argument. Please refer to
- * "C Preprocessor - Stringification".
- */
-#define xstr(s) str(s)
-#define str(s)  #s 
-
-#define QOS_CONFIG
-
-#ifdef QOS_CONFIG
-/*direct_multicast_status*/
-#define DIRECT_MULTICAST_STATUS_VALUE "1|1|1|1|1|1|1|1"
-/*direct_multicast_maxnum*/
-#define DIRECT_MULTICAST_MAXNUM_VALUE "10"
-/*cos_classification_status*/
-#define COS_CLASSIFICATION_STATUS_VALUE "0|0|0|0|0|0|0|0|0"
-/*tos_classification_status*/
-#define TOS_CLASSIFICATION_STATUS_VALUE "1|1|1|1|1|1|1|1|1|1|1|1"
-/*heuristics_classification_status*/
-#define HEURISTICS_CLASSIFICATION_STATUS_VALUE "1|1|1|1|1|1|1|1|1"
-/*bwm_level_dl_index*/
-#define BWM_LEVEL_DL_INDEX_VALUE "0|0|0|0|0|0|0|0"
-/*bwm_level_up_index*/
-#define BWM_LEVEL_UP_INDEX_VALUE "0|0|0|0|0|0|0|0"
-/*qos_rule_status*/
-#define QOS_RULE_STATUS_VALUE "0|0|0|0|0|0|0|0|0"
-/*qos_rule_active*/
-#define QOS_RULE_ACTIVE_DEFAULT_VALUE "0^0^0^0^0^0^0^0^0"
-#define QOS_RULE_ACTIVE_VALUE \
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
-	QOS_RULE_ACTIVE_DEFAULT_VALUE
-/*bwm_level*/
-#define BWM_LEVEL_1 "512,512,1500,60,102,102,1500,10,256,461,1500,25,154,512,1500,25,1,1,1500,1"
-#define BWM_LEVEL_2 "1024,1024,2560,110,256,256,1500,10,512,922,1500,50,256,1024,1500,50,1,1,1500,1"
-#define BWM_LEVEL_3 "2048,2048,5120,110,256,256,1500,10,1536,1843,3840,50,256,2048,1500,50,1,1,1500,1"
-#define BWM_LEVEL_4 "2458,4096,6144,110,256,256,1500,10,1843,4096,4608,50,358,4096,1500,50,1,1,1500,1"
-#define BWM_LEVEL_5 "3686,6144,9216,110,256,256,1500,10,2765,6144,6912,50,666,6144,1664,50,1,1,1500,1"
-#define BWM_LEVEL_6 "4915,8192,12288,110,256,256,1500,10,3686,8192,9216,50,973,8192,2432,50,1,1,1500,1"
-#define BWM_LEVEL_7 "5120,10240,12800,110,256,256,1500,10,3840,10240,9600,50,1024,10240,2560,50,1,1,1500,1"
-#define BWM_LEVEL_8 "10240,20480,25600,110,512,512,1500,10,7168,20480,17920,50,2560,20480,6400,50,1,1,1500,1"
-#define BWM_LEVEL_9 "15360,30720,38400,110,512,512,1500,10,11520,30720,28800,50,3328,30720,8320,50,1,1,1500,1"
-#define BWM_LEVEL_10 "15565,40960,38912,110,512,512,1500,10,11674,40960,29184,50,3379,40960,8448,50,1,1,1500,1"
-#define BWM_LEVEL_11 "23347,61440,58368,110,512,512,1500,10,17510,61440,43776,50,5325,61440,13312,50,1,1,1500,1"
-#define BWM_LEVEL_12 "31130,81920,77824,110,512,512,1500,10,23347,81920,58368,50,7270,81920,18176,50,1,1,1500,1"
-#define BWM_LEVEL_13 "30720,102400,76800,110,1024,1024,1500,10,23040,102400,57600,50,6656,102400,16640,50,1,1,1500,1"
-#define BWM_LEVEL_14 "46080,153600,115200,110,1024,1024,1500,10,34560,153600,86400,50,10496,153600,26240,50,1,1,1500,1"
-#define BWM_LEVEL_15 "61440,204800,153600,110,1024,1024,1500,10,46080,204800,115200,50,14336,204800,35840,50,1,1,1500,1"
-#define BWM_LEVEL_16 ",,,,,,,,,,,,,,,,,,,"
-#define BWM_LEVEL_VALUE	\
-	BWM_LEVEL_1"|"\
-	BWM_LEVEL_2"|"\
-	BWM_LEVEL_3"|"\
-	BWM_LEVEL_4"|"\
-	BWM_LEVEL_5"|"\
-	BWM_LEVEL_6"|"\
-	BWM_LEVEL_7"|"\
-	BWM_LEVEL_8"|"\
-	BWM_LEVEL_9"|"\
-	BWM_LEVEL_10"|"\
-	BWM_LEVEL_11"|"\
-	BWM_LEVEL_12"|"\
-	BWM_LEVEL_13"|"\
-	BWM_LEVEL_14"|"\
-	BWM_LEVEL_15"|"\
-	BWM_LEVEL_16
-
-/*stream_priority*/
-/*voice^video^data^background*/
-#define STREAM_PRIORITY_VALUE "4^5^6^7"
-/*sta_priority*/
-#define STA_PRIORITY_DEFAULT_VALUE "none,1"
-#define STA_PRIORITY_VALUE \
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE"|"\
-	STA_PRIORITY_DEFAULT_VALUE
-
-/*qos_rule_record*/
-#define QOS_RULE_RECORD_DEFAULT_VALUE \
-    "none,none,none,none,none,none,none,none,none"
-#define QOS_RULE_RECORD_VALUE \
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
-	QOS_RULE_RECORD_DEFAULT_VALUE
-
-/*igmp_snooping*/
-/*status^age*/
-#define IGMP_SNOOPING_VALUE "1^260"
-/*tos_classify*/
-/*voice^video^data^background*/
-#define TOS_CLASSIFY_VALUE "0xE0,0xC0,0xB8^0xA0,0x80^none^none^0^0"
-/*cos_classify*/
-/*voice^video^data^background*/
-#define COS_CLASSIFY_VALUE "none^none^none^none"
-/*heuristics_classify*/
-/*(d_count^b_count^ipg_min^ipg_max^pl_min^pl_max)*/
-#define VOICE_HEURISTICS_CLASSIFY	"600,10000,15,275,70,400"
-#define VIDEO_HEURISTICS_CLASSIFY	"50000,500000,0,65,1000,1518"
-#define DATA_HEURISTICS_CLASSIFY	"0,0,0,0,0,0"
-#define BACKGROUND_HEURISTICS_CLASSIFY	"0,0,0,0,0,0"
-#define HEURISTICS_CLASSIFY_VALUE	\
-	VOICE_HEURISTICS_CLASSIFY"^"\
-	VIDEO_HEURISTICS_CLASSIFY"^"\
-	DATA_HEURISTICS_CLASSIFY"^"\
-	BACKGROUND_HEURISTICS_CLASSIFY
-/*tos_mark*/
-#define TOS_MARK_VALUE "1^0x8^0x5^0x0^0x0"
-
-/*root_bw*/
-#define ROOT_BW_VALUE "307200^307200^307200"
-
-#endif
-
-static struct nvram_tuple nvram_ezpacket_default[] = {
-    { "fw_version", xstr(EZP_PROD_VERSION), 
-        NVRAM_NONE, 
-        0 
-    },   
-    /* Added for different customer's version definition. */
-    { "prod_fw_version", EZP_PROD_FW_VERSION, 
-        NVRAM_NONE, 
-        0 
-    },   
-    { "ifup_types", "lan wan", 
-        NVRAM_NONE, 
-        0 
-    },   
-    { "wan_num", xstr(WAN_NUM),     /* How many WAN interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wan_weight_type", "1", 
-        NVRAM_NONE,
-        0 
-    },   /* WAN weight type [0 (manual) |1 (auto) ] */
-
-#if (WAN_NUM >= 1)
-    /* WAN0 */
-    /* WAN H/W parameters */
-
-    { "wan0_ifname", WAN0_IFNAME, 
-        NVRAM_NONE,
-        0 
-    },    /* WAN interface name */
-    { "wan0_ifnames", WAN0_IFNAMES, 
-        NVRAM_NONE,
-        0 
-    },       /* WAN interface names */
-    { "wan0_hwname", WAN0_HWNAME, 
-        NVRAM_NONE,
-        0 
-    },        /* WAN driver name (e.g. et1) */
-    { "wan0_device", WAN0_DEVICE, 
-        NVRAM_NONE,
-        0 
-    },        /* WAN device name */
-    { "wan0_device_backup", WAN0_DEVICE, 
-        NVRAM_NONE,
-        0 
-    },        /* WAN device name */
-    { "psyslocation", "deskTop", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN driver name (e.g. et1) */
-    { "psyscontact", "everyone@local.com", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN device name */
-    { "psysservices", "sysservices^72", 
-        NVRAM_NONE,
-        0 
-    }, 
-    {"rip_mode","0",
-       NVRAM_NONE,
-       0
-
-    },       /*rip mode: 0 rip,1 ripng, 2 both*/
- 	{"ripng_config","lan&wan",
-	   NVRAM_NONE,
-       0
-	},/*interface value:lan/wan/lan&wan*/
-    { "telnet_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },
-    { "telnet_port", "23", 
-        NVRAM_NONE,
-        0 
-    },
-    { "https_enable", "0", 
-        NVRAM_NONE,
-        0 
-    },
-    { "https_port", "443", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_ro_username", "admin", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_ro_passwd", "12345678", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_rw_username", "user", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_rw_passwd", "12345678", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_ro_community", "private", 
-        NVRAM_NONE,
-        0 
-   },
-   { "snmpd_rw_community", "public", 
-        NVRAM_NONE,
-        0 
-   },
-   { "snmpd_trap_ipadress", "192.168.1.10", 
-        NVRAM_NONE,
-        0 
-   },
-	/* WAN device name */
-    /* MR routers use wwan as default*/
-#if defined(EZP_PROD_CAT_M) 
-    { "wan0_proto", "dhcp", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN proto */
-#else
-    { "wan0_proto", "dhcp", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN proto */
-#endif
-    { "wan0_protov6", "link-local", 
-        NVRAM_NONE,
-        0 
-    },        /* IPv6 WAN proto */
-    { "wan0_rtmark", "0x10000000", 
-        NVRAM_NONE,
-        0 
-    }, /* WAN device routing mark. */
-    { "wan0_ports", WAN0_PORTS, 
-        NVRAM_NONE,
-        0 
-    }, /* WAN device port assignment. */
-    { "wan0_bw_mode", "auto",
-        NVRAM_NONE,
-        0
-    }, /* WAN DBM mode: auto/expert */
-
-    /* WAN temporary parameters */
-    { "wan0_ipaddr", "",
-       NVRAM_TEMP,
-       0 
-    },        /* WAN IP address */
-    /* WAN temporary parameters */
-    { "wan0_ipaddrv6", "",
-       NVRAM_TEMP,
-       0 
-    },        /* WAN IP address */
-    { "wan0_netmask", "",
-       NVRAM_TEMP,
-       0 
-    },       /* WAN netmask */
-    { "wan0_mask", "", 
-       NVRAM_TEMP,
-       0 
-    },          /* WAN netmask2 */
-    { "wan0_prefixv6", "", 
-       NVRAM_TEMP,
-       0 
-    },          /* WAN netmask2 */
-    { "wan0_maskv6", "", 
-       NVRAM_TEMP,
-       0 
-    },          /* WAN netmask2 */
-    { "wan0_gateway", "",
-       NVRAM_TEMP,
-       0 
-    },       /* WAN gateway */
-    { "wan0_gatewayv6", "",
-       NVRAM_TEMP,
-       0 
-    },       /* WAN gateway */
-    { "wan0_dns", "",
-       NVRAM_TEMP,
-       0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "wan0_dnsv6", "",
-       NVRAM_TEMP,
-       0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "wan0_wins", "",
-       NVRAM_TEMP,
-       0 
-    },          /* x.x.x.x x.x.x.x ... */
-    { "wan0_failcount", "",
-       NVRAM_TEMP,
-       0 
-    },          /* WAN detection failure count */
-    { "wan0_upnp_proto", "",
-       NVRAM_TEMP,
-       0 
-    },          /* WAN UPnP proto */
-    { "wan0_upnp_ifname", "",
-       NVRAM_TEMP,
-       0 
-    },          /* WAN UPnP ifname */
-    /* Because we have v4/v6 on the same device, we have to check both when
-     * trying to bring down an interface */
-    { "wan_up_down_state_rule", "0^0",
-       NVRAM_TEMP,
-       0 
-    },          /* v4^v6 */
-
-#endif
-
-    /* WAN main rules */
-    { "wan_main_rule", WAN_MAIN_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^mtu^stp^upnp */
-    /* WAN proto parameters rules */
-    { "wan_static_rule", WAN_STATIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* ipaddr^mask^gateway^dns1^dns2^wins */
-    { "wan_dhcp_rule", WAN_DHCP_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* hostname^domain^lease*/
-    { "wan_pppoe_rule", WAN_PPPOE_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* auth^username^passwd^demand^idletime^echo_failure^redialperiod^
-         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr^servname
-         */
-    /* V6 WAN proto parameters rules */
-    { "wan_staticv6_rule", WAN_STATICV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* ipaddr^length^gateway^dns1^dns2 */
-    { "wan_dhcpv6_rule", WAN_DHCPV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* hostname^domain^lease^type[0:stateless|1:stateful] */
-    { "wan_pppoev6_rule", WAN_PPPOEV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* username^passwd^servicename^
-         * demand^idletime^echo_failure^redialperiod^
-         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr */
-#define WAN_TUNNEL6_RULE "72.52.104.74^2001:470:1f04:d1c::2/64^2001:470:1f04:d1c::1"
-    { "wan_tunnel6_rule", WAN_TUNNEL6_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* brokerv4addr^v6ipaddr_length^v6gateway */
-    { "wan_wwan_rule", WAN_WWAN_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
-         * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
-         * ctrltty^devname^flag^turbolink
-         */
-    /* wan_pptp_l2tp_rule */
-    { "wan_pptp_l2tp_rule", WAN_PPTP_L2TP_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* serverip^iptype[static|dhcp]^ipaddr^netmask^gateway^username^
-           passwd^nailup^timeout^pppiptype[isp|custom]^custom_ipaddr^
-           encmode[disabled|mppe]^auth[chap|pap|none] */
-    { "wan_wwan_probe_rule", WAN_WWAN_PROBE_RULE, 
-        NVRAM_TEMP,
-        0 
-    },  /* brand^model^signal^numtty^datatty^ctrltty^devname^flag */
-    { "wan_bigpond_rule", WAN_BIGPOND_RULE,
-        NVRAM_NONE,
-        0 
-    },  /* enable^server^username^passwd */
-    { "wan_dns_rule", WAN_DNS_RULE,
-        NVRAM_NONE,
-        0 
-    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
-    { "wan_dnsv6_rule", WAN_DNSV6_RULE,
-        NVRAM_NONE,
-        0 
-    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
-    /* WAN hwaddr */ 
-    { "wan_hwaddr_rule_default", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0
-    },  /* hwaddr */
-    /* WAN hwaddr clone */ 
-    { "wan_hwaddr_clone_rule", WAN_HWADDR_CLONE_RULE, 
-        NVRAM_NONE,
-        0
-    },  /* enable[0|1]^hwaddr^addrtype[ipaddr|hwaddr]^ipaddr */
-    /* DDNS */
-    { "wan_ddns_rule", WAN_DDNS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^type[dyndns|tzo|zoneedit]^username^
-           passwd^hostname */
-    /* OpenDNS */
-    { "wan_opendns_rule", WAN_OPENDNS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^username^passwd^redirect[0|1]^label */
-    /* WAN status rule */
-    { "wan_st_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* WAN status rule */
-    { "wan_stv6_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* LAN status rule */
-    { "lan_st_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* LAN status rule */
-    { "lan_stv6_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* WLAN status rule */
-    { "wlan_st_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    { "lan_num", xstr(LAN_NUM), 
-        NVRAM_NONE,
-        0 
-    },  /* How many LAN interfaces are available.*/
-#if LAN_NUM >= 1
-    /* LAN0 */
-    /* LAN H/W parameters */
-
-    { "lan0_ifname", LAN0_IFNAME, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN interface name */
-    { "lan0_ifnames", LAN0_IFNAMES, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN interface names */
-    { "lan0_hwname", LAN0_HWNAME, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN driver name (e.g. et1) */
-    { "lan0_device", LAN0_DEVICE, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN device name */
-    { "lan0_proto", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN device name */
-    { "lan0_protov6", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN IPv6 device name */
-    { "lan0_ports", LAN0_PORTS, 
-        NVRAM_NONE,
-        0 
-    }, /* LAN device port assignment. */
-
-    /* LAN temporary parameters */
-    { "lan0_ipaddr", "", 
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IP address */
-    /* LAN temporary parameters */
-    { "lan0_ipaddrv6", "2001:db8:feed:b00::1",
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IPv6 address */
-    { "lan0_netmask", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN netmask */
-    { "lan0_mask", "", 
-       NVRAM_TEMP,
-        0 
-    },
-    /* LAN netmask2 */
-    { "lan0_prefixv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 prefix */
-    { "lan0_maskv6", "64", 
-       NVRAM_TEMP,
-        0 
-    },          /* LAN IPv6 netmask2 */
-    { "lan0_gateway", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN gateway */
-    { "lan0_gatewayv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 gateway */
-    { "lan0_dns", "", 
-       NVRAM_TEMP,
-        0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "lan0_wins", "", 
-       NVRAM_TEMP,
-        0 
-    },          /* x.x.x.x x.x.x.x ... */
-#if LAN_NUM >= 2
-    /* LAN0 */
-
-    { "lan1_ifname", LAN1_IFNAME, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN interface name */
-    { "lan1_proto", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN device name */
-    { "lan1_protov6", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN IPv6 device name */
-    /* LAN temporary parameters */
-    { "lan1_ipaddr", "", 
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IP address */
-    { "lan1_ipaddrv6", "2001:db8:feed:b00::1",
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IPv6 address */
-    { "lan1_netmask", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN netmask */
-    { "lan1_mask", "", 
-       NVRAM_TEMP,
-        0 
-    },          /* LAN netmask2 */
-    { "lan1_prefixv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 prefix */
-    { "lan1_maskv6", "64", 
-       NVRAM_TEMP,
-        0 
-    },          /* LAN IPv6 netmask2 */
-    { "lan1_gateway", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN gateway */
-    { "lan1_gatewayv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 gateway */
-    { "lan1_dns", "", 
-       NVRAM_TEMP,
-        0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "lan1_wins", "", 
-       NVRAM_TEMP,
-        0 
-    },          /* x.x.x.x x.x.x.x ... */
-#endif /* LAN_NUM >= 2*/
-#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
-    { "vlan_rule", VLAN_RULE,
-       NVRAM_NONE,
-        0 
-    },      /* name^enable[0|1]^ifname^vid^portmember^flag */
-    { "vlan_rule_num", xstr(VLAN_RULE_NUM),
-       NVRAM_NONE,
-        0 
-    },      
-    { "vlan_rule_max", xstr(VLAN_RULE_MAX),
-       NVRAM_NONE,
-        0 
-    },
-    { "vlanport_rule", VLANPORT_RULE,
-       NVRAM_NONE,
-        0 
-    },       /* name^portid^pvid^tag^gmemb */
-    { "vlanport_rule_num", xstr(VLANPORT_RULE_NUM),
-       NVRAM_NONE,
-        0 
-    },      
-    { "vlanport_rule_max", xstr(VLANPORT_RULE_MAX),
-       NVRAM_NONE,
-        0 
-    },
-    { "br_rule", BR_RULE,
-       NVRAM_NONE,
-        0
-    },      /* name^enable[0|1]^ifnames^flag */
-    { "br_rule_num", xstr(BR_RULE_NUM),
-       NVRAM_NONE,
-        0
-    },
-    { "br_rule_max", xstr(BR_RULE_MAX),
-       NVRAM_NONE,
-        0
-    },
-#ifdef CONFIG_EZP_ARCH_RT305X
-    NVRAM_EZPACKET_DEFAULT_RT305X_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_2
-#endif
-#elif defined(CONFIG_EZP_ARCH_RT3883)
-    NVRAM_EZPACKET_DEFAULT_RT3883_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_2
-#endif
-#endif
-#endif
-
-#ifdef CONFIG_EZP_ARCH_BRCM
-    NVRAM_EZPACKET_DEFAULT_BRCM_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_2
-#endif
-#endif
-#endif
-
-#ifdef CONFIG_EZP_ARCH_AS500
-    NVRAM_EZPACKET_DEFAULT_AS500_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_2
-#endif
-    NVRAM_EZPACKET_DEFAULT_AS500_SWAP
-    NVRAM_EZPACKET_DEFAULT_AS500_INITD
-#endif
-
-    { "lan_main_rule", LAN_MAIN_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^mtu^stp^weight */
-    { "lan_hwaddr_rule_default", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0
-    },  /* hwaddr */
-    { "lan_static_rule_default", LAN_STATIC_RULE_DEFAULT, 
-        NVRAM_NONE,
-        0 
-    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
-    { "lan_static_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
-    { "lan_staticv6_rule_default", LAN_STATICV6_RULE_DEFAULT, 
-        NVRAM_NONE,
-        0 
-    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
-         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
-    { "lan_staticv6_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
-         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
-    /* DHCP server parameters */
-    { "lan_dhcps_rule", LAN_DHCPS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^start^num^lease^domain^wins^
-           dnstype[ispdns|opendns|custom|none]^dnsaddr1^
-           dnsaddr2^dnsaddr3^dnsaddr4^dnstype2^dnstype3^dnstype4 */
-    /* LAN hwaddr clone */
-    { "lan_dhcpsv6_rule", LAN_DHCPSV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^pppoe_prefix^static_prefix^dhcp_prefix^
-           domain^
-           dnstype[auto|custom]^
-           dnsaddr1^dnsaddr2^type[1|0]^
-           start^end^lifetime" */
-    /* LAN hwaddr clone */
-    { "lan_hwaddr_clone_rule", LAN_HWADDR_CLONE_RULE, 
-        NVRAM_NONE,
-        0
-    },  /* enable[0|1]^hwaddr[XX:XX:XX:XX:XX:XX] */
-    /* Guest lan rule */
-#define GUEST_LAN_RULE "0^rai3^br2^1^192.168.2.1^24^0^0^1^liteon_guest.com^33^32"
-    { "guest_lan_rule", GUEST_LAN_RULE,
-        NVRAM_NONE,
-        0
-    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
-         * domain : domain name for this dns group
-         * start : dhcp offering start ip address
-         * count : total count dhcp server can offer
-         * */
-#define GUEST_5G_LAN_RULE "0^ra3^br2^1^192.168.2.1^24^0^0^1^liteon_5g_guest.com^33^32"
-    { "guest1_lan_rule", GUEST_5G_LAN_RULE,
-        NVRAM_NONE,
-        0
-    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
-         * domain : domain name for this dns group
-         * start : dhcp offering start ip address
-         * count : total count dhcp server can offer
-         * */
-    /* MASK */
-    { "rt_mask", "0xF0000000", 
-        NVRAM_NONE,
-        0 },      /* Routing mask: 4-bit */
-    { "reserved_mask", "0x0F000000", 
-        NVRAM_NONE,
-        0 },      /* Reserved mask: 4-bit */
-    { "fl_mask", "0x0000FFFF", 
-        NVRAM_NONE,
-        0 },      /* FL mask: 16-bit */
-    { "fl_mark_default", "0x0000FFFF", 
-        NVRAM_NONE,
-        0 },      /* FL mask: 16-bit */
-
-    /* turboNAT */
-    { "turbonat_enable", "0", 
-        NVRAM_NONE,
-        0 
-    },   /* enable [0|1] */
-    /* Session Manager */
-    { "sm_mode", "fast", 
-        NVRAM_NONE,
-        0 
-    },   /* mode [fast|regular|slow] */
-    /* Bandwidth */
-    /*{ "bw_rule", BW_RULE,*/
-    { "bw_rule", "0^32768^32768",
-        NVRAM_NONE,
-        0 
-    },   /* enable^bw_upload^bw_download */
-    { "bw_monitor_rule", "1",
-        NVRAM_NONE,
-        0 
-    },   /* enable */
-    { "bw_tc_mask", "0x00FF0000", 
-        NVRAM_NONE,
-        0 
-    },   /* BW mask */
-    /* SBM */
-    { "bw_sbm_mask", "0x00FF0000", 
-        NVRAM_NONE,
-        0 
-    },   /* BW mask */
-    /*{ "bw_app_rule", BW_APP_RULE, */
-    /* Easy mode */
-    { "bw_ezmodesort_rule", "Game Console|VoIP|Instant Messenger|Web Surfing|P2P/FTP|E-Mail",
-        NVRAM_NONE,
-        0 
-    },   /* catname */
-    { "bw_ezmodesort_rule_num", "6", 
-        NVRAM_NONE,
-        0 
-    },
-    { "bw_ezmodesort_rule_max", "6", 
-        NVRAM_NONE,
-        0 
-    },
-    { "bw_app_rule_num", "11",
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-    { "bw_app_rule_max", "32", 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-#define XBOX_APP "appl^0^1^1^Game Console^XBox Live^3074,3390,3932,5555^88,1900,3074,3776,3777^1^50^1^1^50^1^1^10^1^1^10^1"
-#define PLAYSTATION_APP "appl^0^1^1^Game Console^PlayStation^5223^3478,3479,3658,4658^1^50^1^1^50^1^1^10^1^1^10^1"
-#define MSN_GAME_APP "appl^0^1^1^Game Console^MSN Game Zone^6667,28800:29000^6667,28800:29000^1^50^1^1^50^1^1^10^1^1^10^1"
-#define BATTLENET_APP "appl^0^1^1^Game Console^Battlenet^40,112,6112,4000,6113:9119^^1^50^1^0^50^1^1^10^1^0^10^1"
-#define VOIP_APP "appl^0^1^1^VoIP^VoIP^5060^5060^1^50^1^0^50^1^1^10^1^0^10^1"
-#define IM_APP "appl^0^1^1^Instant Messenger^Instant Messenger^6891:6901,1863^1863,5190,6901^1^50^1^0^50^1^1^10^1^0^10^1"
-#define WEB_APP "appl^0^1^1^Web Surfing^Web Surfing^80,443^^1^50^1^0^50^1^1^10^1^0^10^1"
-#define FTP_APP "appl^0^1^1^P2P/FTP^FTP^21,22^^1^50^1^0^50^1^1^10^1^0^10^1"
-#define EMULE_APP "appl^0^1^1^P2P/FTP^eMule^4662^4672^1^50^1^0^50^1^1^10^1^0^10^1"
-#define BT_APP "appl^0^1^1^P2P/FTP^BitTorrent^tport^uport^1^50^1^1^50^1^1^10^1^1^10^1"
-#define EMAIL_APP "appl^0^1^1^E-Mail^E-Mail^110,995,25,465,587,220,143,993^^1^50^1^0^50^1^1^10^1^0^10^1"
-    { "bw_app_rule", XBOX_APP"|"PLAYSTATION_APP"|"MSN_GAME_APP"|"BATTLENET_APP"|"VOIP_APP"|"IM_APP"|"WEB_APP"|"FTP_APP"|"EMULE_APP"|"BT_APP"|"EMAIL_APP,
-        NVRAM_NONE,
-        0 
-    }, /* name^enable^index^prio^cat^serv^
-          tcp_port[port|port_beg:port_end]^
-          udp_port[port|port_beg:port_end]^
-          lan_tcp_enable^lan_tcp_bw^lan_tcp_min[0:max bw|1:min bw]^
-          lan_udp_enable^lan_udp_bw^lan_udp_min[0:max bw|1:min bw]^
-          wan_tcp_enable^wan_tcp_bw^wan_tcp_min[0:max bw|1:min bw]^
-          wan_udp_enable^wan_udp_bw^wan_udp_min[0:max bw|1:min bw] */
-#define ACCESS1 "access^ROGROUP^\"\"^any^noauth^exact^all^none^none"
-#define ACCESS2 "access^RWGROUP^\"\"^any^noauth^exact^all^all^all"
-    { "snmpd_access_rule", ACCESS1"|"ACCESS2,
-        NVRAM_NONE,
-        0 
-    }, 
-#define GROUP1 "group^RWGROUP^v1^rw"
-#define GROUP2 "group^RWGROUP^v2c^rw"
-#define GROUP3 "group^RWGROUP^usm^rw"    
-#define GROUP4 "group^ROGROUP^v1^ro"
-#define GROUP5 "group^ROGROUP^v2c^ro"
-#define GROUP6 "group^ROGROUP^usm^ro"    
-	{ "snmpd_group_rule", GROUP1"|"GROUP2"|"GROUP3"|"GROUP4"|"GROUP5"|"GROUP6,
-        NVRAM_NONE,
-        0 
-    }, 
-	{ "snmpd_view_rule", "view^all^included^.1^80",
-        NVRAM_NONE,
-        0 
-    }, 
-    { "bw_sbm_rule", BW_SBM_RULE,
-        NVRAM_NONE,
-        0 
-    }, /* name^enable^inipaddr_start^inipaddr_end^proto^extif^
-          bw_towan^bw_tolan^apptype^prio^
-          outipaddr_start^outipaddr_end^inport^outport^reserve_bw */
-    { "bw_sbm_rule_num", BW_SBM_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-    { "bw_sbm_rule_max", BW_SBM_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-    /* Policy-based routing */
-    { "rt_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },   /* Routing [0|1] */
-    //{ "rt_rule", RT_RULE, 
-    { "rt_rule", "",
-        NVRAM_EMPTY,
-        0 
-    }, /* name^enable[0|1]^srcipaddr_start^srcipaddr_end^dstipaddr_start^
-          dstipaddr_end^proto^srcport_start^srcport_end^dstport_start^
-          dstport_end^extif^routing_type[default|static]^gateway_ipaddr^
-          netmask^matric */
-    //{ "rt_rule_num", "1",
-    { "rt_rule_num", "0",
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing RT rules */
-    { "rt_rule_max", RT_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing RT rules */
-
-    /*  routing */
-    { "rt_conn_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },   /* Routing cache [0|1] */
-    { "rt_rip_rule", RT_RIP_RULE, 
-        NVRAM_NONE,
-        0 
-    }, /* rip[v1/v2/none] */
-    { "nat_rule", NAT_RULE, 
-        NVRAM_NONE,
-        0 
-    }, /* enable */
-#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
-    { "hwnat_rule", HWNAT_RULE, 
-        NVRAM_NONE,
-        0 
-    }, /* enable */
-#endif
-    /* web url/content filtering rule */
-    { "wf_enable", "1",
-        NVRAM_NONE,
-        0
-    }, /* web url filtering [0|1] */
-    { "wf_content_rule", "0^0^0^0^0^",
-        NVRAM_NONE,
-        0
-    }, /* activex_enable^java_enable^proxy_enable^cookie_enable^url_enable^trustipaddr */
-    { "wf_rule", "",
-        NVRAM_EMPTY,
-        0
-    }, /* enable^keyword^type^access */
-    { "wf_rule_num", "0",
-        NVRAM_NONE,
-        0
-    },
-    { "wf_rule_max", WF_RULE_MAX,
-        NVRAM_NONE,
-        0
-    },
-    /* IGMP related rule */
-    { "igmp_proxy_rule", IGMP_PROXY_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* enable */
-    { "igmp_snoop_rule", IGMP_SNOOP_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* enable^p1^p2^p3^p4 */
-    /* Schedule rule */
-    { "sched_enable", "0", 
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    { "sched1_enable", "0", // for 5g
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    /* Schedule rule */
-    { "sched_enable_bak", "0", 
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    { "sched1_enable_bak", "0", // for 5g
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    { "sched_rule", SCHED_RULE,
-        NVRAM_NONE,
-        0 
-    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
-         /* cat:   category, which will cause invoking action
-          * month: apply month
-          * date:  apply date of month
-          * wkday: apply day of week
-          * beghr,begmin: begin hour and minute of day
-          * endhr,endmin: end hour and minute of day
-          * wlanstatus: wlan status
-          */
-    { "sched1_rule", SCHED1_RULE,
-        NVRAM_NONE,
-        0 
-    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
-         /* cat:   category, which will cause invoking action
-          * month: apply month
-          * date:  apply date of month
-          * wkday: apply day of week
-          * beghr,begmin: begin hour and minute of day
-          * endhr,endmin: end hour and minute of day
-          * wlanstatus: wlan status
-          */
-    { "sched_rule_num", SCHED_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-    { "sched_rule_max", SCHED_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-    { "sched1_rule_num", SCHED1_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-    { "sched1_rule_max", SCHED1_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-
-    { "fw_upgrade_rule", FW_UPGRADE_RULE,
-        NVRAM_NONE,
-        0 
-    },   /* method^server^path^username^passwd^inf_filename */
-         /* rule set 0 for default online firmware upgrade settings */
-    { "fw_info_rule", "",
-        NVRAM_TEMP,
-        0 
-    },   /* model^version^revision^date^size^filename^release_note^
-            info_ok[1:got fw info | 0:no info]^
-            fw_ok[1:got fw | 0:no fw]^
-            relnote_ok[1:got release note | 0:no release note] */
-         /* rule set 0 for default online firmware upgrade settings */
-    
-    /* RRDCOLLECT */
-    { "rrd_enable", "0", 
-        NVRAM_NONE,
-        0 },    /* RRDcollect client */
-
-    /* Cron */
-    { "cron_rule", "1^1^02 4 * * *", 
-        NVRAM_NONE,
-        0 
-    }, /* enable^ntp_enable[0|1]^ntp_interval */
-
-    /* NTP */
-    //{ "ntp_rule", "^1^pool^pool.ntp.org^^UTC-8^^^^^^^^^^^^^^",
-    { "ntp_rule", "^1^pool^pool.ntp.org^^GMT0BST,M3.5.0/2,M10.5.0/2^0^^^^^^^0^^^^^^^^0^", 
-        NVRAM_NONE,
-        0 
-    }, /* name^enable[0|1]^type^pool^ipaddr^zone^
-          custom_time[0|1]^year^mon^date^hour^min^sec^
-          daylight_saving[0|1]^
-          ds_start_mon^ds_start_day^ds_start_hour^
-          ds_end_mon^ds_end_day^ds_end_hour^customized^
-          custom_server[0|1]^serv_ipaddr */
-
-    /* SSH */
-    { "ssh_rule", "^1^8123", 
-        NVRAM_NONE,
-        0 
-    },       /* name^enable[0|1]^port */
-
-/* Added by Abocom */
-    /* log parameters */
-    { "log_selected_num", "9", 
-        NVRAM_NONE,
-        0 
-    },        /* Log selection number */
-    { "log_index", "show_all", 
-        NVRAM_NONE,
-        0 
-    },
-    /* Log Index */    
-    { "log_rule", LOG_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^ipaddr^ipt_enable^web_mgmt^dns^ppp^
-           upnp^wireless^ntp^sys_warning^dhcp_serv^dhcp_cli^
-           ddns^firewall */
-    /* uPnP */
-    { "upnp_rule", "^1^0^wan0^lan0^5555", 0 },
-    /* name^enable[0|1]^pmp_enable[0|1]^extif^inif^port */
-
-    /* Filters */
-    { "fl_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },    /* fl_enable [0|1] */
-    { "fl_rule", FL_RULE, 
-        NVRAM_EMPTY,
-        0 
-    },    /* name^enable[0|1]^extif^inif^proto^srcip^srcmask^
-                                dstip^dstmask^srcport^dstport^
-                                action[0(DROP)|1(ACCEPT)]^mark^bw_idx^
-                                sched_idx */
-
-    { "fl_rule_num", FL_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },      /* The amount of existing log rules */
-    { "fl_rule_max", FL_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },
-    { "fl_rule_default", "1", 
-        NVRAM_NONE,
-        0 
-    },
-
-    { "fl_hwaddr_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },    /* fl_hwaddr_enable [0|1] */
-    { "fl_hwaddr_rule", "", 
-        NVRAM_EMPTY,
-        0 
-    },    /* name^acl_enable[0|1]^dhcp_enable^arp_enable^hwaddr^
-             action[0(DROP)|1(ACCEPT)]^ipaddr */
-    { "fl_hwaddr_rule_num", "0", 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing fl_hwaddr rules */
-    { "fl_hwaddr_rule_max", FL_HWADDR_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },
-    { "fl_hwaddr_rule_default", "1", 
-        NVRAM_NONE,
-        0 
-    },
-
-    /* Port forwards */
-    { "fr_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },  /* fr_enable [0|1] */
-    { "fr_rule", FR_RULE, 
-        NVRAM_EMPTY,
-        0 
-    },  /* name^enable[0|1]^extif^proto[tcp|udp|both]^extport_start^extport_end^ipaddr^inport_start^inport_end */
-    { "fr_rule_num", FR_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },      /* fr_rule_num */
-    { "fr_rule_max", FR_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },      /* fr_rule_max */
-    { "fr_dmz_rule", FR_DMZ_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable[0|1]^ipaddr */
-
-    /* Port triggle */
-    { "pt_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },  /* pt_enable [0|1] */
-    { "pt_rule", PT_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable^proto[tcp|udp|all]^port_start^port_end^trig_port_start^trig_port_end */
-    { "pt_rule_num", "12", 
-        NVRAM_NONE,
-        0 
-    },  /* pt_rule_num */
-    { "pt_rule_max", PT_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },  /* pt_rule_max */
-
-#if ( WL_NUM > 0 )
-    /* Wireless interface */
-    { "wl_num", xstr(WL_NUM), 
-        NVRAM_NONE,
-        0 
-    },      /* Enable (1) or disable (0) radio */
-    /* Wireless parameters */
-    { "wl_region_default", "0", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },      /* Region code default */
-    { "wl_region", "", 
-        NVRAM_DEFAULT,
-        0 
-    },      /* Region code */
-    { "wl_countrycode_default", WL_COUNTRY_CODE, 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },      /* Region code */
-    { "wl_countrycode", WL_COUNTRY_CODE, 
-        NVRAM_DEFAULT,
-        0 
-    },      /* Region code */
-    { "wl_regionaband_default", WL_REGION_ABAND, 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },      /* Region code */
-    { "wl_regionaband", "", 
-        NVRAM_DEFAULT,
-        0 
-    },      /* Region code */
-    { "wl_ieee80211h", "1", 
-        NVRAM_DEFAULT,
-        0 
-    },      /* IEEE802.11H */
-    /* Physical interface related rules*/
-    { "wl_rule_num", xstr(WL_NUM),     /* How many WLan interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl_rule_max", xstr(WL_NUM),     /* How many WLan interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    /* Virtual interface related rules for wl0/wl1... */
-    { "wlv_rule_num", xstr(WL0_RULE_NUM) ,     /* How many virtual wl0 interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wlv_rule_max", xstr(WL0_RULE_MAX),     /* Max virtual wl0 interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl_enabled_rule", "0", 
-        NVRAM_TEMP,
-        0 
-    },      /* Enable (1) or disable (0) radio */
-    /* This setting reserved the must original wireless setting
-     * such as hardware button status. Some application ,like schedular, 
-     * may change the wifi at run time. We can use this setting to restore
-     * the original setting. 
-     * Currently, only /sbin/ezp-wifionoff may change its value */
-    { "wl_origset_rule", "1",
-        NVRAM_NONE,
-        0 
-    },      /* enable */
-    { "wl1_origset_rule", "1",
-        NVRAM_NONE,
-        0 
-    },      /* enable  for 5g */
-    { "wl_basic_rule", WL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^net_mode^txpower^channel^bisolation */
-    { "wl_ap_basic_rule", WL_AP_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^net_mode^txpower^channel^bisolation */
-    { "wl5g_basic_rule", WL5G_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^net_mode^txpower^channel^bisolation */
-	{ "wl_ap_advanced_rule", WL_AP_ADVANCED_RULE, 
-        NVRAM_NONE,
-        0 
-    },
-	{ "wl_advanced_rule", WL_ADVANCED_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
-               gmode^gmode_protection^afterburner^frameburst^
-               txburst[0:disable|1:enable->1]^
-               pktaggr[0:disable|1:enable->0]^
-               txmode[0:None|1:CCK|2:OFDM->0]^
-
-               rdg[0:disable|1:enablei->0]^
-               linkadapt[0:disable|1:enable->0]^
-               htc[0:disable|1:enable->0]^
-
-               htbw[0:20|1:20/40->1]^
-               gi[0:long|1:short->1]^
-               opmode[0:mixed|1:GreenField->0]^
-               mcs[0~15,32,33=auto->33]^
-               mpdu[0 none, 1~7 -> 5]^
-               amsdu[0:disable|1:enable->0]^
-
-               autoba[0:disable|1:enable->1]^
-               bawinsize[1~64,default=8,iot=64->64]^
-               badecline[0:disable|1:enable->1->0]^
-               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
-               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
-             */
-    { "wl1_advanced_rule", WL1_ADVANCED_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
-               gmode^gmode_protection^afterburner^frameburst^
-               txburst[0:disable|1:enable->1]^
-               pktaggr[0:disable|1:enable->0]^
-               txmode[0:None|1:CCK|2:OFDM->0]^
-
-               rdg[0:disable|1:enablei->0]^
-               linkadapt[0:disable|1:enable->0]^
-               htc[0:disable|1:enable->0]^
-
-               htbw[0:20|1:20/40->1]^
-               gi[0:long|1:short->1]^
-               opmode[0:mixed|1:GreenField->0]^
-               mcs[0~15,32,33=auto->33]^
-               mpdu[0 none, 1~7 -> 5]^
-               amsdu[0:disable|1:enable->0]^
-
-               autoba[0:disable|1:enable->1]^
-               bawinsize[1~64,default=8,iot=64->64]^
-               badecline[0:disable|1:enable->1->0]^
-               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
-               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
-             */
-    { "wl_wds_rule", WL_WDS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
-    { "wl1_wds_rule", WL1_WDS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
-    { "wl_wme_rule", WL_WME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* sta_bk^Sta_be^sta_vi^sta_vo^ap_bk^ap_be^ap_vi^ap_vo^no_ack^max_assoc */
-    { "wl_mode_rule", WL_MODE_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[normal|ap|ur|wisp]^
-             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
-             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
-    { "wl1_mode_rule", WL1_MODE_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[normal|ap|ur|wisp]^
-             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
-             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
-    { "wl_wps_rule", WL_WPS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
-    { "wl1_wps_rule", WL1_WPS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
-    { "wl_wps_sta_rule", WL_WPS_STA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
-    { "wl1_wps_sta_rule", WL1_WPS_STA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
-    { "wl_led_status_rule", "9^9",
-        NVRAM_TEMP,
-        0 
-    },      /* wl^wps */
-    { "wl0_basic_rule", WL0_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^hidden^rate^wme^isolation */
-    { "wl1_basic_rule", WL1_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^hidden^rate^wme^isolation */
-    { "wl0_ifname_rule", WL0_IFNAME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl0_ssid_rule", WL0_SSID_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl1_ssid_rule", WL5G_SSID_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl0_sec_rule", WL0_SEC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* secmode */
-    { "wl0_sec_wep_rule", WL0_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^
-               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl0_sec_wpa_rule", WL0_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^session_timeout */
-    { "wl0_sec_wpa2_rule", WL0_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
-    { "wl1_sec_rule", WL1_SEC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* secmode */
-    { "wl1_sec_wep_rule", WL0_SEC_5G_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^
-               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl1_sec_wpa_rule", WL0_SEC_5G_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^session_timeout */
-    { "wl1_sec_wpa2_rule", WL0_SEC_5G_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
-/* acl policy can apply to each ssid, we add rule according to ssid number */
-#if (WL0_RULE_MAX >= 1)
-    { "wl00_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl00_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl00_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl00_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 2)
-    { "wl01_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl01_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl01_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl01_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 4)
-    { "wl02_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl02_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl02_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl02_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-    { "wl03_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl03_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl03_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl03_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#endif /* WL0_RULE_MAX >= 4 */
-#endif /* WL0_RULE_MAX >= 2 */
-#endif /* WL0_RULE_MAX >= 1 */
-/*  5g acl policy can apply to each ssid, we add rule according to ssid number */
-#if (WL0_RULE_MAX >= 1)
-    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl10_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl10_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl10_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 2)
-    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl11_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl11_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl11_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 4)
-    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl12_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl12_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl12_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl13_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl13_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl13_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#endif /* WL0_RULE_MAX >= 4 */
-#endif /* WL0_RULE_MAX >= 2 */
-#endif /* WL0_RULE_MAX >= 1 */
-#if 0
-#if ( WL_NUM >= 2 )
-    { "wl1_basic_rule", WL1_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^hidden^rate^wme^isolation */
-    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ifname */
-    { "wl1_ssid_rule", WL1_SSID_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl1_sec_rule", WL1_SEC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* secmode */
-    { "wl1_sec_wep_rule", WL1_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^
-               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl1_sec_wpa_rule", WL1_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^session_timeout */
-    { "wl1_sec_wpa2_rule", WL1_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
-/* acl policy can apply to each ssid, we add rule according to ssid number */
-#if (WL0_RULE_MAX >= 1)
-    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl10_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl10_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl10_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 2)
-    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl11_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl11_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl11_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 4)
-    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl12_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl12_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl12_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl13_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl13_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl13_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#endif /* WL0_RULE_MAX >= 4 */
-#endif /* WL0_RULE_MAX >= 2 */
-#endif /* WL0_RULE_MAX >= 1 */
-#endif /* WL_NUM >= 2 */
-#endif
-    /* wds related rules */
-    { "wl0_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_wds_basic_rule", WL0_WDS_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* hwaddr^secmode */
-    { "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },  
-    { "wl1_wds_basic_rule", WL1_WDS_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* hwaddr^secmode */
-    { "wl0_wds_sec_wep_rule", "|||", 
-        NVRAM_NONE,
-        0 
-    },      /* key */
-    { "wl0_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl1_wds_sec_wep_rule", "|||", 
-        NVRAM_NONE,
-        0 
-    },      /* key */
-    { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    /* apcli related rules */
-    { "wl0_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_apcli_rule", WL0_APCLI_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^ssid^bssid^secmode */
-    { "wl0_apcli_sec_wep_rule", WL0_APCLI_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl0_apcli_sec_wpa_rule", WL0_APCLI_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl0_apcli_sec_wpa2_rule", WL0_APCLI_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl1_apcli_rule", WL1_APCLI_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^ssid^bssid^secmode */
-    { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
-    { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    }, 
-#if ( WL_NUM >= 2 )
-    //{ "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
-     //   NVRAM_NONE,
-     //   0 
-    //},   
-   // { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
-   //     NVRAM_NONE,
-   //     0 
-  //  },   
-    //{ "wl1_wds_basic_rule", "^disabled|^disabled|^disabled|^disabled", 
-    //    NVRAM_NONE,
-    //    0 
-    //},      /* mac^secmode */
-    //{ "wl1_wds_sec_wep_rule", "|||", 
-    //    NVRAM_NONE,
-    //    0 
-    //},      /* key */
-   // { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
-   //     NVRAM_NONE,
-   //     0 
-   // },      /* key^crypto */
-    /* apcli related rules */
-    //{ "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
-     //   NVRAM_NONE,
-     //   0 
-   // },   
-    //{ "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
-    //    NVRAM_NONE,
-    //    0 
-    //},   
-   // { "wl1_apcli_rule", WL1_APCLI_RULE, 
-   //     NVRAM_NONE,
-  //      0 
-  //  },      /* enable^ssid^bssid^secmode */
-  //  { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
-  //      NVRAM_NONE,
-  //      0 
-  //  },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
-  //  { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
-   //     NVRAM_NONE,
-  //      0 
-  //  },      /* key^crypto */
-  //  { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
-  //      NVRAM_NONE,
-  //      0 
-  //  },      /* key^crypto */
-#endif
-#endif
-    /* for firewall */
-    { "fw_rule", "1^1^1^1^1^0^1^0", 
-        NVRAM_NONE,
-        0 
-    },  /* enable^syn_enable^icmp_enable^icmp_redir_enable
-           ^icmp_ping_enable^rpfilter_enable^state_enable^
-           wantolan_enable[0:drop non-DNAT wan-to-lan connection request|1:otherwise] */
-    { "nat_pass_rule", "1^1^1^1^1^1^1", 
-        NVRAM_NONE,
-        0 
-    },  /* enable^ipsec_enable^pptp_enable^l2tp_enable^
-           h323_enable^rtsp_enable^mms_enable */
-    /* TTL */
-    { "ttl_rule", "^0^64", 
-        NVRAM_NONE,
-        0 
-    },        /* TTL name^enable[1|0]^value */
-    /* TOS */
-    { "tos_rule", "1^1^1^1^1^1^1", 
-        NVRAM_NONE,
-        0 
-    },   /* TOS enable^icmp_enable^dns_enable^ssh_enable^
-            telnet_enable^check_enable^ack_enable */
-    /* MSS */
-    { "mss_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },        /* TOS [1|0] */
-
-    /* SNAT */
-    { "snat_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },        /* SNAT [1|0] */
-
-    /* Conntrack max amount */
-    { "ct_max", CT_MAX, 
-        NVRAM_NONE,
-        0 
-    },        /* SNAT [1|0] */
-    /* Web server parameters */
-    { "http_rule_default", "^1^0^admin^1234^guest^1234^admin^80^^5", 
-        NVRAM_NONE,
-        0 
-    }, /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
-    { "http_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    },  /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
-    {"rip_conf_rule_default", "0^0^0^0^0^0^0^0",
-      NVRAM_NONE,
-      0
-    },
-   {"rip_conf_rule", "",
-      NVRAM_DEFAULT,
-      0
-    },
-    {"bridge_rule", "",
-      NVRAM_DEFAULT,
-      0
-    },
-    {"bridge_rule_default", "0",
-      NVRAM_DEFAULT,
-      0
-    },
-    {"wl0_wpa_auth_rule", "^^^",
-      NVRAM_NONE,
-      0
-    },
-    {"wl0_wpa_auth_rule_default", "1^^",
-      NVRAM_DEFAULT,
-      0
-    },
-    {"wl1_wpa_auth_rule", "^^^",
-      NVRAM_NONE,
-      0
-    },
-    {"wl1_wpa_auth_rule_default", "1^^",
-      NVRAM_DEFAULT,
-      0
-    },
-    {"board_model_rule", "",
-      NVRAM_DEFAULT,
-      0
-    },
-    {"board_model_rule_default", "0",
-      NVRAM_DEFAULT,
-      0
-    },
-    { "snmpd_user_rule_default", "1^1^1^0", 
-        NVRAM_NONE,
-        0 
-    }, /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
-    { "snmpd_user_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    }, 
-    { "snmpd_com2sec_rule_default", "com2sec^ro^default""|""com2sec^rw^default", 
-        NVRAM_NONE,
-        0 
-    }, 
-    { "snmpd_com2sec_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    },/*system status^filename^ipaddr^protocol^server username^server password*/
-    { "snmpd_upgrade_rule", "1^^^1^^", 
-        NVRAM_DEFAULT,
-        0 
-    },/* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
-    { "adtool_rule", "any^^4^any^^4^any^^4",
-        NVRAM_NONE,
-        0
-    }, /* pingiface^pinghost^pingcnt^arpingiface^arpinghost^arpingcnt^tracerouteiface^traceroutehost^traceroutecnt */
-    { "stats_rule", STATS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^stime^ifnames */
-    { "stats_type", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_ifname */
-    { "stats_ifname", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_ifname */
-    { "stats_proto", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_ifname */
-    { "stats_interval", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_time hourly:60, daily:600, weekly: 3600, monthly: 3600*6 */
-    { "no_root_swap", "1", 
-        NVRAM_NONE,
-        0 
-	}, /* no_root_swap */ 
-    /* enable^pptp_enable^ipsec_enable^l2tp_enable */
-    { "smb_vpn_passthrough_rule", "1^1^1", 
-        NVRAM_NONE,
-        0 
-    }, 
-    /* IPsec */
-	{ "ipsec_enable", "0",
-		NVRAM_NONE,
-		0    
-	},   
-#ifdef IPSEC_RULE_MAX
-#undef IPSEC_RULE_MAX
-#define IPSEC_RULE_MAX "32"
-#else 
-#define IPSEC_RULE_MAX "32"
-#endif
-	{ "ipsec_rule_max", IPSEC_RULE_MAX,
-		NVRAM_NONE,
-		0    
-	}, /* value */
-	{ "ipsec_rule_num", "0", 
-		NVRAM_NONE,
-		0    
-	}, /* value */
-	{ "ipsec_rule", "",  
-		NVRAM_NONE,
-		0    
-	},
-	/*
- name^enable^mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init^ike_keymode^psk^rsa^ca^adv^phase1_mode^phase1_auth^phase1_encrypt^phase1_group^phase1_id^phase2_auth^phase2_encrypt^phase2_group^phase1_lifetime^phase2_lifetime^dpd_enable^dpd_interval^dpd_timeout
-
-	 */
-	{ "ipsec_status_rule", "",
-		NVRAM_TEMP,
-		0
-	}, /* phase1[none|established]^phase2[none|established] */
-
-#undef PPTPD_SESSION_MAX
-#undef PPTPD_USER_RULE_MAX
-#undef L2TPD_SESSION_MAX
-#undef L2TPD_USER_RULE_MAX
-#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "32"
-#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "32"
-	/*pptpd*/
-    { "pptpd_rule", "0^pptp-server^60^1460^1482^192.168.38.1^" xstr(PPTPD_SESSION_MAX) "^192.168.39.1^" xstr(PPTPD_SESSION_MAX) "^1^^0^0^1^0^0^1^0^1",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^name^redialperiod^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable[0|1]^dns^chap_enable[0|1]^mschap_enable[0|1]^mschapv2_enable[0|1]^eap_enable[0|1]^pap_enable[0|1]^mppe128_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
-
-    { "pptpd_user_rule", "",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^username^provider^passwd^ipaddr */
-    { "pptpd_user_rule_num", "0",
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-    { "pptpd_user_rule_max", PPTPD_USER_RULE_MAX,
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-    { "pptpd_session_max", xstr(PPTPD_SESSION_MAX), 
-        NVRAM_NONE,
-        0 
-    },  /* value */
-    /*l2tpd*/
-    { "l2tpd_rule", "0^l2tp-server^1400^1400^192.168.48.1^" xstr(L2TPD_SESSION_MAX) "^192.168.49.1^" xstr(L2TPD_SESSION_MAX) "^1^^1^0^1^1",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^name^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable^dns^chap_enable[0|1]^pap_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
-    { "l2tpd_user_rule", "",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^username^provider^passwd^ipaddr */
-    { "l2tpd_user_rule_num", "0",
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-    { "l2tpd_user_rule_max", L2TPD_USER_RULE_MAX,
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-
-	{ "wol_rule", "",
-		NVRAM_NONE,
-		0 
-	},  /* name^enable^bcast^hwaddr^iface^passwd */
-	{ "lang_default", "EN", 
-		NVRAM_NONE,
-		0 
-	},  /* Default web language support */
-	{ "lang", "", 
-		NVRAM_DEFAULT,
-		0 
-	},  /* Web language support */
-	{ "brand", "LITEON", 
-		NVRAM_NONE,
-		0 
-	},  /* Brand name - CSS style and SSID. */
-#define UPNP_FRIENDLYNAME   "LITEON CPE Internet Sharing Gateway"
-#define MANUFACTURER        "LITEON Communications Corp."
-#define MANUFACTURERURL     "http://www.liteon.com"
-#define MODELDESCRIPTION    "LITEON CPE Internet Sharing Gateway"
-#define MODELNAME           "LITEON Internet Sharing Gateway"
-#define MODELNUMBER         "CPE"
-#define MODELURL            ""
-#define SERIALNUMBER        "A19003848"
-#define UDN                 "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e"
-#define PRESENTATIONURL     ""
-    { "upnpxml_rule", UPNP_FRIENDLYNAME"^"MANUFACTURER"^"MANUFACTURERURL"^"MODELDESCRIPTION"^"MODELNAME"^"MODELNUMBER"^"MODELURL"^"SERIALNUMBER"^"UDN"^"PRESENTATIONURL, 
-        NVRAM_NONE,
-        0 
-    },  /* friendlyName^manufacturer^manufacturerURL^modelDescription^
-         * modelName^modelNumber^modelURL^serialNumber^UDN^presentationURL */
-    { "igd", "CPE IGD Version 1.00", 
-        NVRAM_NONE,
-        0 
-    },  /* Brand name - CSS style and SSID. */
-    { "udn", "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e", 
-        NVRAM_NONE,
-        0 
-    },  /* Brand name - CSS style and SSID. */
-    { "model", "CPE Internet Gateway Device", 
-        NVRAM_NONE,
-        0 
-    },              /* Product model */
-    { "license_key", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },              /* Product model */
-    { "hostname", "WP688",
-        NVRAM_NONE,
-        0 
-    },           /* Hostname */
-    { "prod_cat", xstr(EZP_PROD_CAT), 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },           /* Product category */
-    { "prod_subcat", xstr(EZP_PROD_SUBCAT), 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* Product subcategory */
-    { "prod_subsubcat", xstr(EZP_PROD_SUBSUBCAT), 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* Product sub-subcategory */
-    { "machine_id", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* Machine id */
-    { "arch", ARCH, 
-        NVRAM_PROTECTED,
-        0 
-    },        /* Arch */
-    { "license_invalid", "0",
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* License status */
-    { "bootcount", "",
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* License bootcount */
-/* Added by Abocom */
-    { "weather_rule", "1^UKXX1428^c", 
-        NVRAM_NONE,
-        0 
-    },        /* enable^city^degree */
-    { "wl_easy_mode_rule", "0", 
-        NVRAM_NONE,
-        0 
-    },        /* mode 0->2.4g  1->5g */
-    { "FirstConfig", "1", 
-        NVRAM_NONE,
-        0 
-    },        /* FirstConfig for web server */
-     { "zyfw_fw_file", "", 
-        NVRAM_NONE,
-        0 
-    },        /* file name for online FW upgrade */
-    { "zyfw_size", "", 
-        NVRAM_NONE,
-        0 
-    },        /* file size for online FW upgrade */
-    { "WISP_Channel", "0", 
-        NVRAM_NONE,
-        0 
-    },        /* Save WISP's wireless Channel */	
-    { "WISP1_Channel", "0", 
-        NVRAM_NONE,
-        0 
-    },        /* Save WISP's wireless 5g Channel */	
-    { "AP_Channel", "0", 
-        NVRAM_NONE,
-        0 
-    },		/* Save AP's wireless Channel */
-    { "AP1_Channel", "36", 
-        NVRAM_NONE,
-        0 
-    },		/* Save AP's wireless Channel */
-    { "wl_wisp_mode_rule", "wisp^ap", 
-        NVRAM_NONE,
-        0 
-    }, /*wifi 2.4g as wisp,wifi 5g as 
-       ap mode when choose wisp mode*/
-    /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
-#ifdef QOS_CONFIG
-
-    /*port_status*/
-    { "direct_multicast_status", DIRECT_MULTICAST_STATUS_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*maxnum*/
-    { "direct_multicast_maxnum", DIRECT_MULTICAST_MAXNUM_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*port_status*/
-    { "tos_classification_status", TOS_CLASSIFICATION_STATUS_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*port_status*/
-    { "cos_classification_status", COS_CLASSIFICATION_STATUS_VALUE, 
-        NVRAM_NONE,
-        0 
-    },    
-    /*port_status*/
-    { "heuristics_classification_status", HEURISTICS_CLASSIFICATION_STATUS_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*level*/
-    { "bwm_level_dl_index", BWM_LEVEL_DL_INDEX_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*level*/
-    { "bwm_level_up_index", BWM_LEVEL_UP_INDEX_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*port_status*/
-    { "qos_rule_status", QOS_RULE_STATUS_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*x*/
-    { "qos_rule_active", QOS_RULE_ACTIVE_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-	/*rule*/
-    { "bwm_level", BWM_LEVEL_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-	/*rule*/
-    { "stream_priority", STREAM_PRIORITY_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-	/*level*/
-    { "sta_priority", STA_PRIORITY_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-	/*rule*/
-    { "qos_rule_record", QOS_RULE_RECORD_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-	/*status^age*/
-    { "igmp_snooping", IGMP_SNOOPING_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*voice^video^data^background*/
-    { "tos_classify", TOS_CLASSIFY_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*voice^video^data^background*/
-    { "cos_classify", COS_CLASSIFY_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-    /*(d_count^b_count^ipg_min^ipg_max^pl_min^pl_max)*/
-    { "heuristics_classify", HEURISTICS_CLASSIFY_VALUE, 
-        NVRAM_NONE,
-        0 
-    },
-/* (status^voice^video^data^background) */
-    { "tos_mark", TOS_MARK_VALUE,        
-        NVRAM_NONE,
-        0 
-    },
-/* (wlantolan^lanto2.4Gwlan^lanto5Gwlan) */
-    { "root_bw", ROOT_BW_VALUE,        
-        NVRAM_NONE,
-        0 
-    },
-#endif
-    { 0, 0, 0 ,0 }
-};
-
-#endif /*_NVRAM_EZPACKET_H */
Index: src/include/nvram_env.h
===================================================================
--- src/include/nvram_env.h	(revision 7302)
+++ src/include/nvram_env.h	(revision 7299)
@@ -1,13 +0,0 @@
-#define ENV_BLK_SIZE 0x1000
-
-#ifdef CONFIG_DUAL_IMAGE
-#define ENV_UBOOT_SIZE 0x1000
-#endif
-
-extern		void  nvram_printenv(int index, int argc, char *argv[]);
-extern unsigned char *nvram_getenv  (int index, unsigned char *name);
-extern		int   nvram_setenv  (int index, int argc, char *argv[]);
-extern		int   nvram_buff_setenv  (int index, int argc, char *argv[]);
-extern 		int   do_nvram_commit(int index);
-extern unsigned	long  crc32	 (unsigned long, const unsigned char *, unsigned);
-
Index: src/include/nvram_ezpacket-rt305x.h
===================================================================
--- src/include/nvram_ezpacket-rt305x.h	(revision 7302)
+++ src/include/nvram_ezpacket-rt305x.h	(revision 7299)
@@ -1,295 +0,0 @@
-#ifdef CONFIG_EZP_ARCH_RT305X
-#define ARCH "RT305X"
-
-#ifndef WL_NUM
-#define WL_NUM 1
-#endif
-
-#ifndef WL_VIRTUAL_NUM
-#define WL_VIRTUAL_NUM 4
-#endif
-
-#ifndef WL_WDS_NUM
-#define WL_WDS_NUM 4
-#endif
-
-#ifndef WL_APCLI_NUM
-#define WL_APCLI_NUM 1
-#endif
-
-#if ( WL_NUM == 1 )
-#define WL_BASIC_RULE "1^9^100^6^1"
-#define WL5G_BASIC_RULE "1^8^100^0^1"
-#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE*/
-#define WL0_IFNAME_RULE "rai0"
-#define WL1_IFNAME_RULE "ra0"
-#elif ( WL_VIRTUAL_NUM == 2 )
-#define WL0_IFNAME_RULE "ra0|ra1"
-#define WL1_IFNAME_RULE "rai0|rai1"
-#elif ( WL_VIRTUAL_NUM == 4 )
-#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
-#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
-#endif /* WL0_IFNAME_RULE*/
-#define WL0_RULE_NUM WL_VIRTUAL_NUM
-#define WL0_RULE_MAX WL_VIRTUAL_NUM
-#if (WL0_RULE_NUM == 2)
-#warning "WL0_RULE_NUM 2"
-#warning "WL0_RULE_MAX 2"
-#elif (WL0_RULE_NUM == 4)
-#warning "WL0_RULE_NUM 4"
-#warning "WL0_RULE_MAX 4"
-#endif
-#define WDS_RULE_MAX WL_WDS_NUM
-#define APCLI_RULE_MAX WL_APCLI_NUM
-#elif ( WL_NUM == 2 )
-#define WL_BASIC_RULE "1^9^100^6^1|1^9^100^6^1"
-#define WL5G_BASIC_RULE "1^8^100^6^1|1^8^100^6^1"
-#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE/WL1_IFNAME_RULE*/
-#define WL0_IFNAME_RULE "rai0"
-#define WL1_IFNAME_RULE "ra0"
-#elif ( WL_VIRTUAL_NUM == 2 )
-#define WL1_IFNAME_RULE "ra0|ra2"
-#define WL0_IFNAME_RULE "rai0|rai2"
-#elif ( WL_VIRTUAL_NUM == 4 )
-#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
-#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
-#endif /* WL0_IFNAME_RULE/WL1_RULE_NUM */
-#define WL0_RULE_NUM WL_VIRTUAL_NUM
-#define WL0_RULE_MAX WL_VIRTUAL_NUM
-#define WL1_RULE_NUM WL_VIRTUAL_NUM
-#define WL1_RULE_MAX WL_VIRTUAL_NUM
-#define WDS_RULE_MAX WL_WDS_NUM
-#define APCLI_RULE_MAX WL_APCLI_NUM
-#elif (WL_NUM == 0 )
-#else
-#error "Undefined amount of WLAN interfaces"
-#endif
-
-#if ( WAN_NUM >= 1 )
-
-/* 3G/4G WAN default interface should be ppp0. */
-#if defined(EZP_PROD_CAT_M)
-#define WAN0_IFNAME "vlan2"
-#else
-#define WAN0_IFNAME "vlan2"
-#endif
-
-#define WAN0_IFNAMES ""
-#define WAN0_HWNAME ""
-#define WAN0_DEVICE "vlan2"
-#define WAN0_PORTS "4"
-#if ( LAN_NUM >= 1 )
-    #define LAN0_IFNAME "br0"
-    #define LAN0_IFNAMES "vlan1 ra0 ra1 apcli0"
-    #define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 apcli0 wds0 wds1 wds2 wds3"
-    #define LAN0_HWNAME ""
-    #define LAN0_DEVICE "vlan1"
-#endif
-#if (LAN_NUM >= 2)
-    #define LAN1_IFNAME "br2"
-    #define LAN1_DEVICE "br2"
-#endif
-
-#if (LAN_NUM == 1)
-    #if (WL_VIRTUAL_NUM == 2)
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
-    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
-    #else
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
-    #endif
-    #define BR_RULE_NUM 2
-    #define BR_RULE_MAX 8
-#elif (LAN_NUM == 2)
-    #define BR_RULE_GUESTLAN "GuestLAN^0^ra1^"
-    #if (WL_VIRTUAL_NUM == 2)
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
-    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
-    #else
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
-    #endif
-    #define BR_RULE_NUM 3
-    #define BR_RULE_MAX 8
-#else
-    #if (WL_VIRTUAL_NUM == 2)
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
-    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
-    #else
-        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
-    #endif
-    #define BR_RULE_NUM 2
-    #define BR_RULE_MAX 8
-#endif
-
-#define STATS_RULE "^1^60^vlan1 vlan2 ppp0 br0 rai0 usb0 eth0"
-#define VLAN_RULE_NUM 2
-#define VLAN_RULE_MAX 8
-#ifdef CONFIG_RAETH_RT3052_P5
-    #warning "P5 enabled, vlan set to 1111011"
-    #define VLAN_RULE "LAN1^1^eth2^1^1111011^|WAN1^1^eth2^2^0000111^"
-#else
-    #warning "P5 disabled, vlan set to 1111001"
-    #define VLAN_RULE "LAN1^1^eth2^1^1111011^|WAN1^1^eth2^2^0000111^"
-#endif /* CONFIG_RAETH_RT3052_P5 : support for GMAC port when using external giga switch. */
-#define VLANPORT_RULE_NUM 5
-#define VLANPORT_RULE_MAX 7
-#define VLANPORT_RULE "PORT1^0^1^0^011101|PORT2^1^1^0^011011|PORT3^2^1^0^010111|PORT4^3^1^0^001111|PORT5^4^2^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
-/* EZP: Old VLAN definition should be Obsolete! */
-#define LAN0_PORTS "0 1 2 3"
-/* WAN0 uses vlan2. XXX: No effect! */
-#define VLAN2_PORTS "4 5"
-/* LAN0 uses vlan1. XXX: No effect! */
-#define VLAN1_PORTS "0 1 2 3 5*"
-#define VLAN_HWNAME "eth2"
-
-#elif ( WAN_NUM == 2 ) 
-
-#define WAN0_IFNAME "vlan2"
-#define WAN0_IFNAMES ""
-#define WAN0_HWNAME ""
-#define WAN0_DEVICE "vlan2"
-#define WAN0_PORTS "4"
-
-/* 3G/4G 2nd WAN default interface should be ppp0. */
-#if defined(EZP_PROD_CAT_N)
-#define WAN1_IFNAME "ppp1"
-#else
-#define WAN1_IFNAME "vlan3"
-#endif
-
-#define WAN1_IFNAMES ""
-#define WAN1_HWNAME ""
-#define WAN1_DEVICE "vlan3"
-#define WAN1_PORTS "3"
-
-#define LAN0_IFNAME "br0"
-#define LAN0_IFNAMES "vlan1 ra0 ra1 apcli0"
-#define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 apcli0 wds0 wds1 wds2 wds3"
-#define LAN0_HWNAME ""
-#define LAN0_DEVICE "vlan1"
-#define LAN0_PORTS "0 1 2"
-
-#define VLAN_RULE_NUM 3
-#define VLAN_RULE_MAX 16 
-#ifdef CONFIG_RAETH_RT3052_P5
-    #define VLAN_RULE "LAN1^1^eth2^1^1110011^|WAN1^1^eth2^2^0000111^|WAN2^1^eth2^3^0001011^"
-#else
-    #define VLAN_RULE "LAN1^1^eth2^1^1110001^|WAN1^1^eth2^2^0000101^|WAN2^1^eth2^3^0001001^"
-#endif /* CONFIG_RAETH_RT3052_P5 : support for GMAC port when using external giga switch. */
-#define VLANPORT_RULE_NUM 5
-#define VLANPORT_RULE_MAX 7
-#define VLANPORT_RULE "PORT1^0^1^0^001101|PORT2^1^1^0^001011|PORT3^2^1^0^000111|PORT4^3^2^0^000001|PORT5^4^3^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
-/* WAN0 uses vlan2. */
-#define VLAN2_PORTS "4 5"
-/* WAN1 uses vlan3. */
-#define VLAN3_PORTS "3 5"
-/* LAN0 uses vlan1. */
-#define VLAN1_PORTS "0 1 2 5"
-
-#define VLAN_HWNAME "eth2"
-
-#if (WL_VIRTUAL_NUM == 2)
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#else
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#endif
-
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#define BR_RULE_NUM 3
-#define BR_RULE_MAX 16
-
-#define STATS_RULE "^1^60^vlan3 vlan1 vlan2 ppp0 ppp1 br0 ra0 usb0 eth0 eth1"
-
-#else
-
-#error "Undefined amount of LAN/WAN interfaces"
-
-#endif
-
-#define HWNAT_RULE "1"
-
-#define BW_TYPE \
-        "A1M64K", "A1.5M640K", "A2M256K", "A2M512K", "A3M640K", "A4M1M", \
-        "A6M256K", "A6M640K", "A8M256K", "A8M640K", "A8M800K", "A10M2M", \
-        "A12M1M", "C1M128K", "C2M128K", "C2M384K", "C3M384K", "C6M640K", \
-        "C8M640K", "C10M1M", "V2M2M", "V4M4M", "V10M10M", "V25M25M", \
-        "V50M50M", "V100M100M","Custom"
-#if ( EZP_PROD_SUBCAT == 0 )
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-#elif ( EZP_PROD_SUBCAT == 1 )
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-#elif ( EZP_PROD_SUBCAT == 2 )
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-#elif ( EZP_PROD_SUBCAT == 3 )
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-#elif ( EZP_PROD_SUBCAT == 4 )
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-#elif ( EZP_PROD_SUBCAT == 5 )
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-#elif ( EZP_PROD_SUBCAT == 6 )
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-#endif /* EZP_PROD_SUBCAT */
-
-#define NVRAM_EZPACKET_DEFAULT_RT305X_LAN_NUM_1   \
-    /* WAN1 uses vlan1. */              \
-    { "vlan1ports", VLAN1_PORTS,        \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 port. */                \
-    { "vlan1hwname", VLAN_HWNAME,       \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 device hwname. */       \
-
-#define NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_1   \
-    /* WAN1 uses vlan2. */              \
-    { "vlan2ports", VLAN2_PORTS,        \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 port. */                \
-    { "vlan2hwname", VLAN_HWNAME,       \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 device hwname. */       \
-
-
-#define NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_2   \
-    /* WAN3 uses vlan3. */              \
-    { "vlan2ports", VLAN3_PORTS,        \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN3 port. */                \
-    { "vlan3hwname", VLAN_HWNAME,       \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN3 device hwname. */       \
-
-
-
-#endif /* CONFIG_EZP_ARCH_RT305X */
-
Index: src/include/nvram_ezpacket6239.h
===================================================================
--- src/include/nvram_ezpacket6239.h	(revision 7302)
+++ src/include/nvram_ezpacket6239.h	(revision 7299)
@@ -1,2631 +0,0 @@
-/*
- * EZ Packet product default NVRAM values
- *
- * Copyright 2006, 2007 EZ Packet Technologies
- * All Rights Reserved.
- */
-
-/*
- * Router default NVRAM values
- *
- * Copyright 2005, Broadcom Corporation
- * All Rights Reserved.
- *
- * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
- *
- * $Id: defaults.c,v 1.104 2005/05/25 12:31:20 honor Exp $
- */
-
-#ifndef _NVRAM_EZPACKET_H
-#define _NVRAM_EZPACKET_H
-
-#include <bcmnvram.h>
-
-/* HW dependent definition. */
-#ifdef CONFIG_EZP_ARCH_RT305X
-#include "nvram_ezpacket-rt305x.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_RT3883
-#include "nvram_ezpacket-rt3883.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_AS500
-#include "nvram_ezpacket-as500.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_BRCM
-#include "nvram_ezpacket-brcm.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_OX810
-#include "nvram_ezpacket-ox810.h"
-#endif
-#ifdef CONFIG_EZP_ARCH_RTL865X
-#include "nvram_ezpacket-rtl865x.h"
-#endif /* CONFIG_EZP_ARCH_RTL865X */
-
-#if (LAN_NUM == 1)
-    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^hp.com^custom^^^0^100^200^30"
-    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
-#elif (LAN_NUM == 2)
-    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^hp.com^custom^^^0^100^200^30|default^0^2001:db8:feed:b10::^2001:db8:feed:b10::^2001:db8:feed:b10::^hp.com^custom^^^0^100^200^30"
-    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^|2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^64^^^^^^^^^^"
-#else
-    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^hp.com^custom^^^0^100^200^30"
-    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
-#endif
-#define EZP_PROD_FW_VERSION "V1.00(BWQ.1)C0"
-#define WL_COUNTRY_CODE "US"
-#define WL_REGION_ABAND "7"
-
-#if ( EZP_PROD_SUBCAT == 0 )
-
-#define FL_HWADDR_RULE_MAX "64"
-#define CT_MAX "20000"
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "0"
-#define BW_DBM_RULE_MAX "0"
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define SBM_MAX "0"
-#define DBM_MAX "0"
-#define FL_RULE_NUM "3"
-#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
-#define BW_ENABLE "0"
-#define BW_SBM_RULE_NUM "0"
-#define BW_SBM_RULE ""
-#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "10"
-#define FTPD_USER_RULE_MAX "4"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "4"
-#define ISHOST_RULE_MAX "4"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "0"
-#define SCHED_RULE ""
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "0"
-#define SCHED1_RULE ""
-
-/* VPN comes in. Note: No VPN in this subcat.*/
-#if ( WAN_NUM == 1 )
-
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-
-#elif ( WAN_NUM == 2 )
-
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-#else
-#error "Undefined amount of LAN/WAN interfaces"
-#endif /* VPN */
-
-#elif ( EZP_PROD_SUBCAT == 1 )
-
-#define FL_HWADDR_RULE_MAX "64"
-#define CT_MAX "20000"
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define BW_DBM_RULE_MAX "32"
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define SBM_MAX "8"
-#define DBM_MAX "8"
-#define FL_RULE_NUM "3"
-#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "0"
-#define BW_SBM_RULE ""
-#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "10"
-#define FTPD_USER_RULE_MAX "4"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "4"
-#define ISHOST_RULE_MAX "4"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "0"
-#define SCHED_RULE ""
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "0"
-#define SCHED1_RULE ""
-
-/* VPN comes in. Note: No VPN in this subcat.*/
-#if ( WAN_NUM == 1 ) /* EZP_PROD_CAT: "B" */
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-
-#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-#else
-#error "Undefined amount of LAN/WAN interfaces"
-#endif /* VPN */
-
-#elif ( EZP_PROD_SUBCAT == 2 )
-
-#define FL_HWADDR_RULE_MAX "64"
-
-/* PGP consumes too much memory and leaves less for conntrack. */
-#if defined(EZP_PROD_CAT_C) || defined (EZP_PROD_CAT_T) || defined (EZP_PROD_CAT_D) 
-#define CT_MAX "16000"
-#else
-#define CT_MAX "16000"
-#endif
-
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-
-#if defined(EZP_PROD_SUBSUBCAT_L)
-#define BW_DBM_RULE_MAX "0"
-#define BW_SBM_RULE_MAX "64"
-#define SBM_MAX "64"
-#define DBM_MAX "1"
-#define BW_DBM_RULE_NUM "0"
-#define BW_DBM_RULE "DBM^0^192.168.1.20^192.168.1.27^8^"
-#else
-#define BW_DBM_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define SBM_MAX "8"
-#define DBM_MAX "8"
-#define BW_DBM_RULE_NUM "1"
-#define BW_DBM_RULE "DBM^1^192.168.1.20^192.168.1.27^8^"
-#endif
-
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define FL_RULE_NUM "0"
-#define FL_RULE ""
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "10"
-#define USER_SBM_DEFAULT_IPADDR_START ""
-#define USER_SBM_DEFAULT_IPADDR_END   ""
-#define USER_SBM1 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM2 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM3 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM4 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM5 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM6 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM7 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define USER_SBM8 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
-#define GuestLANtoLAN "GuestLANtoLAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
-#define GuestLANtoWAN "GuestLANtoWAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
-#define BW_SBM_RULE USER_SBM1"|"USER_SBM2"|"USER_SBM3"|"USER_SBM4"|"USER_SBM5"|"USER_SBM6"|"USER_SBM7"|"USER_SBM8"|"GuestLANtoLAN"|"GuestLANtoWAN
-#if (LAN_NUM == 1)
-    #define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#elif (LAN_NUM == 2)
-    #define LAN_DHCPS_GUESTLAN "default^0^33^32^86400^hp.com^^ispdns^^^^^none^opendns^opendns"
-    #define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns|"LAN_DHCPS_GUESTLAN
-#else
-    #define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#endif
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "10"
-#define FTPD_USER_RULE_MAX "8"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "8"
-#define ISHOST_RULE_MAX "8"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "8"
-#define SCHED_RULE "^1^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "8"
-#define SCHED1_RULE "^1^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
-
-/* VPN comes in. Note: No VPN in this subcat except MR-108N.*/
-#if ( WAN_NUM == 1 ) 
-#if defined(EZP_PROD_CAT_M)
-#define PPTPD_SESSION_MAX 5	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "5"
-#else
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#endif
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-
-#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
-#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "0"
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-#else
-#error "Undefined amount of LAN/WAN interfaces"
-#endif /* VPN */
-
-#elif ( EZP_PROD_SUBCAT == 3 )
-
-#define FL_HWADDR_RULE_MAX "64"
-#define CT_MAX "20000"
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define BW_DBM_RULE_MAX "32"
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define SBM_MAX "16"
-#define DBM_MAX "16"
-#define FL_RULE_NUM "3"
-#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "0"
-#define BW_SBM_RULE ""
-#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "15"
-#define FTPD_USER_RULE_MAX "16"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "16"
-#define ISHOST_RULE_MAX "16"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "0"
-#define SCHED_RULE ""
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "0"
-#define SCHED1_RULE ""
-
-/* VPN comes in. */
-#if ( WAN_NUM == 1 ) /* EZP_PROD_CAT: "B" "C", subcat = 3, x116 series */
-#define PPTPD_SESSION_MAX 16	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "16"
-#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "0"
-#define IPSEC_RULE_MAX "0"
-
-#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
-#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "32"
-#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "32"
-#define IPSEC_RULE_MAX "0"
-#else
-#error "Undefined amount of LAN/WAN interfaces"
-#endif /* VPN */
-
-#elif ( EZP_PROD_SUBCAT == 4 )
-
-#define FL_HWADDR_RULE_MAX "128"
-#define CT_MAX "60000"
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define BW_DBM_RULE_MAX "32"
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define SBM_MAX "16"
-#define DBM_MAX "16"
-#define FL_RULE_NUM "3"
-#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "0"
-#define BW_SBM_RULE ""
-#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "15"
-#define FTPD_USER_RULE_MAX "32"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "32"
-#define ISHOST_RULE_MAX "32"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "0"
-#define SCHED_RULE ""
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "0"
-#define SCHED1_RULE ""
-
-#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "32"
-#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "32"
-#define IPSEC_RULE_MAX "32"
-
-#elif ( EZP_PROD_SUBCAT == 5 )
-
-#define FL_HWADDR_RULE_MAX "64"
-#define CT_MAX "80000"
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define BW_DBM_RULE_MAX "32"
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define SBM_MAX "32"
-#define DBM_MAX "32"
-#define FL_RULE_NUM "3"
-#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "0"
-#define BW_SBM_RULE ""
-#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "15"
-#define FTPD_USER_RULE_MAX "32"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "32"
-#define ISHOST_RULE_MAX "32"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "0"
-#define SCHED_RULE ""
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "0"
-#define SCHED1_RULE ""
-
-#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "32"
-#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "32"
-#define IPSEC_RULE_MAX "32"
-
-#elif ( EZP_PROD_SUBCAT == 6 )
-
-#define FL_HWADDR_RULE_MAX "64"
-#define CT_MAX "100000"
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define BW_DBM_RULE_MAX "32"
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define SBM_MAX "64"
-#define DBM_MAX "64"
-#define FL_RULE_NUM "3"
-#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "0"
-#define BW_SBM_RULE ""
-#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "15"
-#define FTPD_USER_RULE_MAX "32"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "32"
-#define ISHOST_RULE_MAX "32"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "0"
-#define SCHED_RULE ""
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "0"
-#define SCHED1_RULE ""
-
-#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "32"
-#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "32"
-#define IPSEC_RULE_MAX "32"
-
-#elif ( EZP_PROD_SUBCAT == 7 )
-
-#define FL_HWADDR_RULE_MAX "64"
-#define CT_MAX "120000"
-#define RT_RULE_MAX "32"
-#define BW_RULE_MAX "32"
-#define BW_SBM_RULE_MAX "32"
-#define BW_DBM_RULE_MAX "32"
-#define FL_RULE_MAX "64"
-#define FR_RULE_MAX "64"
-#define PT_RULE_MAX "64"
-#define WF_RULE_MAX "16"
-#define IGMP_PROXY_RULE "0"
-#define IGMP_SNOOP_RULE "0^0^0^0^0"
-#define SBM_MAX "64"
-#define DBM_MAX "64"
-#define FL_RULE_NUM "3"
-#define FL_RULE "MSN Messenger^0^^^^^207.46.1.1^207.46.255.255^^^^^^0^0001^0^0|MSN Messenger^0^^^^^65.54.1.1^65.54.255.255^^^^^^0^0002^1^1|Yahoo! Messenger^0^^^^^216.155.1.1^216.155.255.255^^^^^^0^0003^2^2"
-#define BW_ENABLE "1"
-#define BW_SBM_RULE_NUM "0"
-#define BW_SBM_RULE ""
-#define LAN_DHCPS_RULE "default^1^33^32^86400^hp.com^^dnsrelay^^^^^none^opendns^opendns"
-#define VNC_SESSION_MAX "16"
-
-#define BT_TORRENT_MAX "15"
-#define FTPD_USER_RULE_MAX "64"
-#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
-#define ISUSER_RULE_MAX "64"
-#define ISHOST_RULE_MAX "64"
-#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
-#define SCHED_RULE_MAX "16"
-#define SCHED_RULE_NUM "0"
-#define SCHED_RULE ""
-#define SCHED1_RULE_MAX "16"
-#define SCHED1_RULE_NUM "0"
-#define SCHED1_RULE ""
-
-
-#define PPTPD_SESSION_MAX 64	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "64"
-#define L2TPD_SESSION_MAX 64	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "64"
-#define IPSEC_RULE_MAX "32"
-
-#else
-
-#error "Undefined product subcategory"
-
-#endif /* EZP_PROD_SUBCAT */
-
-#define SUBCAT_MAX  7
-#define FW_UPGRADE_RULE "ftpget^192.168.100.178^^^^zyfw_info"
-
-/* WAN amount dependent definition. */
-#if ( WAN_NUM == 1 )
-#define WAN_MAIN_RULE "WAN1^1^1500^1^1^0"
-#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
-#define WAN_DETECT_RULE "^0^ping^^60^8"
-#define WAN_WEIGHT_RULE "1^1"
-#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^"
-#define WAN_DHCP_RULE "^^86400"
-#define WAN_HTC_RULE "^^86400^512^0"
-#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^"
-#define WAN_STATICV6_RULE "2001:db8:feed:b01::2^64^2001:db8:feed:b01::1^^"
-#define WAN_DHCPV6_RULE "^^86400^stateful"
-#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^"
-#define WAN_WWAN_RULE "1^0^0^internet^^auto^chap^^^0^300^20^20^1492^1492^*99***1#^0^0^0^0^0^0^1^0"
-#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap"
-#define WAN_DNS_RULE "ispdns^^ispdns^"
-#define WAN_DNSV6_RULE "ispdns^^ispdns^"
-#define WAN_WWAN_PROBE_RULE "^^^^^^^"
-#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
-#define WAN_BIGPOND_RULE "0^61.9.192.13^^"
-#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^"
-#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^"
-#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^"
-#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
-#define RT_RIP_RULE "none"
-#define NAT_RULE "1"
-#define FR_RULE ""
-#define FR_RULE_NUM "0"
-#define FR_DMZ_RULE "^0^"
-#define PT_RULE "^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0"
-
-#elif ( WAN_NUM == 2 )
-#define WAN_MAIN_RULE "WAN1^1^1500^1^0^0|WAN2^1^1500^1^1^0"
-#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155|A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
-#define WAN_DETECT_RULE "^0^ping^208.67.222.222^60^8|^0^ping^208.67.222.222^60^8"
-#define WAN_WEIGHT_RULE "1^1|1^1"
-#define WAN_FAILOVER_RULE "0^wan0^wan1"
-#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^|10.1.2.25^24^10.1.2.254^10.1.2.254^^"
-#define WAN_DHCP_RULE "^^86400|^^86400"
-#define WAN_HTC_RULE "^^86400^512^0|^^86400^512^0"
-#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^|chap^^^0^300^5^5^1492^1492^isp^^"
-#define WAN_STATICV6_RULE "^^^^|^^^^"
-#define WAN_DHCPV6_RULE "^^86400^stateful|^^86400^stateful"
-#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^|^^^0^300^5^5^1492^1492^isp^"
-#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap|^static^^^^^^1^300^isp^^disabled^chap"
-#define WAN_DNS_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
-#define WAN_DNSV6_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
-#define WAN_WWAN_PROBE_RULE "^^^^^^^|^^^^^^^"
-#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
-#define WAN_BIGPOND_RULE "0^61.9.192.13^^|0^61.9.192.13^^"
-#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^|0^^hwaddr^"
-#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^|WAN2_DDNS^0^dyndns^^^^"
-#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^|WAN2_OPENDNS^0^^^0^"
-#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
-#define RT_RIP_RULE "none"
-#define NAT_RULE "1"
-#define FR_RULE "HTTP^0^wan0^tcp^80^80^192.168.1.20^^|HTTPS^0^wan0^tcp^443^443^192.168.1.20^^|POP3^0^wan0^tcp^110^110^192.168.1.20^^|POP3S^0^wan0^tcp^995^995^192.168.1.20^^|SMTP^0^wan0^tcp^25^25^192.168.1.20^^|SMTPS^0^wan0^tcp^465^465^192.168.1.20^^|SSH^0^wan0^tcp^22^22^192.168.1.21^^|eMule^0^wan1^both^4662^4672^192.168.1.21^^"
-#define FR_RULE_NUM "8"
-#define FR_DMZ_RULE "^0^|^0^"
-
-#else
-#error "Undefined amount of WAN interface(s)"
-#endif
-
-/* LAN amount dependent definition. */
-#if ( LAN_NUM == 1 )
-    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0"
-    #define LAN_STATIC_RULE_DEFAULT "192.168.1.1^24^^192.168.1.1^^0^^^192.168.1.1^24^192.168.1.2^24"
-    #define LAN_HWADDR_CLONE_RULE "0^"
-#elif ( LAN_NUM == 2 )
-    #define LAN_MAIN_GUESTLAN "GuestLAN^0^1500^1^1^0"
-    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0|"LAN_MAIN_GUESTLAN
-    #define LAN_STATIC_GUESTLAN "192.168.100.1^24^^192.168.100.1^^0^^^192.168.100.1^24^192.168.1.2^24"
-    #define LAN_STATIC_RULE_DEFAULT "192.168.1.1^24^^192.168.1.1^^0^^^192.168.1.1^24^192.168.1.2^24|"LAN_STATIC_GUESTLAN
-    #define LAN_HWADDR_CLONE_RULE "0^"
-#else
-#error "Undefined amount of LAN interface(s)"
-#endif
-
-#if (WL_NUM > 0) /* WL_NUM is not zero. */
-
-#if ( WL_NUM == 1 )
-/* XXX: #define WL_BASIC_RULE "1^0^100^6^0" */
-#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
-#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
-#define WL_WDS_RULE "disabled^1"
-#define WL1_WDS_RULE "disabled^1"
-#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
-#define WL_MODE_RULE "normal^2^0"
-#define WL1_MODE_RULE "normal^2^0"
-#define WL_WPS_RULE "7^^0"
-#define WL1_WPS_RULE "7^^0"
-#define WL_WPS_STA_RULE "0^^^^^^"
-#define WL1_WPS_STA_RULE "0^^^^^^"
-#define WL_ACL_MAX "64"
-#define WL_ACL_BASIC_RULE "1^disabled"
-#elif ( WL_NUM == 2 )
-/* #define WL_BASIC_RULE "1^0^100^6^0|1^0^100^6^0" */
-#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
-#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
-#define WL_WDS_RULE "disabled^1|disabled^1"
-#define WL1_WDS_RULE "disabled^1|disabled^1"
-#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128|15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
-#define WL_MODE_RULE "normal^0^0|normal^0^0"
-#define WL1_MODE_RULE "normal^0^0|normal^0^0"
-#define WL_WPS_RULE "0^^0|0^^0"
-#define WL1_WPS_RULE "0^^0|0^^0"
-#define WL_WPS_STA_RULE "0^^^^^^|0^^^^^^"
-#define WL1_WPS_STA_RULE "0^^^^^^|0^^^^^^"
-#define WL_ACL_MAX "64"
-#define WL_ACL_BASIC_RULE "1^disabled"
-#else
-#error "Undefined amount of WLAN interfaces"
-#endif
-
-#if ( WL_NUM == 1 )
-  /* WDS */
-  #define WL0_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
-  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
-  #define WL0_WDS_SEC_WEP_RULE "|||"
-  #define WL0_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
-  /* APCLI */
-  #define WL0_APCLI_RULE "0^^^disabled^0"
-  #define WL1_APCLI_RULE "0^^^disabled^0"
-  #define WL0_APCLI_SEC_WEP_RULE "1^^^^^^open"
-  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
-  #define WL0_APCLI_SEC_WPA_RULE "^tkip"
-  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
-  #define WL0_APCLI_SEC_WPA2_RULE "^aes"
-  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
-  #if (WL0_RULE_MAX == 2)
-    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
-    #define WL0_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
-    #define WL0_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
-  #elif (WL0_RULE_MAX == 4)
-    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
-    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
-    #define WL0_SSID_RULE "WP777_2.4G|WP777_2.4G_SSID1|WP777_2.4G_SSID2|WP777_2.4G_SSID3"
-    #define WL5G_SSID_RULE "WP777_5G|WP777_5G_SSID1|WP777_5G_SSID2|WP777_5G_SSID3"
-    #define WL0_SEC_RULE "disabled|disabled|disabled|disabled"
-    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
-    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_WPA_RULE   "12345678^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
-    #define WL0_SEC_WPA2_RULE   "12345678^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
-    #define WL0_SEC_5G_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_5G_WPA_RULE   "12345678^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
-    #define WL0_SEC_5G_WPA2_RULE   "12345678^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
-  #else
-/* default set visual interface number to 2 */
-    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
-    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
-    #define WL0_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL0_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
-    #define WL0_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
-  #endif
-#endif
-
-#if ( WL_NUM == 2 )
-  /* WDS */
-  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
-  #define WL1_WDS_SEC_WEP_RULE "|||"
-  #define WL1_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
-  /* APCLI */
-  #define WL1_APCLI_RULE "1^^^disabled"
-  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
-  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
-  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
-  #if (WL1_RULE_MAX == 2)
-    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL1_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
-    #define WL1_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
-  #elif (WL1_RULE_MAX == 4)
-    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6|AXIMCom7|AXIMCom8"
-    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
-    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
-    #define WL1_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
-    #define WL1_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
-  #else
-    /* default set visual interface number to 2 */
-    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
-    #define WL1_SEC_RULE "disabled|disabled"
-    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
-    #define WL1_SEC_WPA_RULE   "^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
-    #define WL1_SEC_WPA2_RULE   "^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
-  #endif
-#endif
-#endif /* WL_NUM is not zero. */
-/* 
- * The following macros are to stringify the macro argument. Please refer to
- * "C Preprocessor - Stringification".
- */
-#define xstr(s) str(s)
-#define str(s)  #s 
-
-static struct nvram_tuple nvram_ezpacket_default[] = {
-    { "fw_version", xstr(EZP_PROD_VERSION), 
-        NVRAM_NONE, 
-        0 
-    },   
-    /* Added for different customer's version definition. */
-    { "prod_fw_version", EZP_PROD_FW_VERSION, 
-        NVRAM_NONE, 
-        0 
-    },   
-    { "ifup_types", "lan wan", 
-        NVRAM_NONE, 
-        0 
-    },   
-    { "wan_num", xstr(WAN_NUM),     /* How many WAN interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wan_weight_type", "1", 
-        NVRAM_NONE,
-        0 
-    },   /* WAN weight type [0 (manual) |1 (auto) ] */
-
-#if (WAN_NUM >= 1)
-    /* WAN0 */
-    /* WAN H/W parameters */
-
-    { "wan0_ifname", WAN0_IFNAME, 
-        NVRAM_NONE,
-        0 
-    },    /* WAN interface name */
-    { "wan0_ifnames", WAN0_IFNAMES, 
-        NVRAM_NONE,
-        0 
-    },       /* WAN interface names */
-    { "wan0_hwname", WAN0_HWNAME, 
-        NVRAM_NONE,
-        0 
-    },        /* WAN driver name (e.g. et1) */
-    { "wan0_device", WAN0_DEVICE, 
-        NVRAM_NONE,
-        0 
-    },        /* WAN device name */
-    { "wan0_device_backup", WAN0_DEVICE, 
-        NVRAM_NONE,
-        0 
-    },        /* WAN device name */
-    { "psyslocation", "deskTop", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN driver name (e.g. et1) */
-    { "psyscontact", "everyone@local.com", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN device name */
-    { "psysservices", "sysservices^72", 
-        NVRAM_NONE,
-        0 
-    }, 
-    {"rip_mode","0",
-       NVRAM_NONE,
-       0
-
-    },       /*rip mode: 0 rip,1 ripng, 2 both*/
- 	{"ripng_config","lan&wan",
-	   NVRAM_NONE,
-       0
-	},/*interface value:lan/wan/lan&wan*/
-    { "snmpd_ro_username", "admin", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_ro_passwd", "12345678", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_rw_username", "user", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_rw_passwd", "12345678", 
-        NVRAM_NONE,
-        0 
-    },
-    { "snmpd_ro_community", "private", 
-        NVRAM_NONE,
-        0 
-   },
-   { "snmpd_rw_community", "public", 
-        NVRAM_NONE,
-        0 
-   },
-	/* WAN device name */
-    /* MR routers use wwan as default*/
-#if defined(EZP_PROD_CAT_M) 
-    { "wan0_proto", "dhcp", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN proto */
-#else
-    { "wan0_proto", "dhcp", 
-        NVRAM_NONE,
-        0 
-    },        /* WAN proto */
-#endif
-    { "wan0_protov6", "link-local", 
-        NVRAM_NONE,
-        0 
-    },        /* IPv6 WAN proto */
-    { "wan0_rtmark", "0x10000000", 
-        NVRAM_NONE,
-        0 
-    }, /* WAN device routing mark. */
-    { "wan0_ports", WAN0_PORTS, 
-        NVRAM_NONE,
-        0 
-    }, /* WAN device port assignment. */
-    { "wan0_bw_mode", "auto",
-        NVRAM_NONE,
-        0
-    }, /* WAN DBM mode: auto/expert */
-
-    /* WAN temporary parameters */
-    { "wan0_ipaddr", "",
-       NVRAM_TEMP,
-       0 
-    },        /* WAN IP address */
-    /* WAN temporary parameters */
-    { "wan0_ipaddrv6", "",
-       NVRAM_TEMP,
-       0 
-    },        /* WAN IP address */
-    { "wan0_netmask", "",
-       NVRAM_TEMP,
-       0 
-    },       /* WAN netmask */
-    { "wan0_mask", "", 
-       NVRAM_TEMP,
-       0 
-    },          /* WAN netmask2 */
-    { "wan0_prefixv6", "", 
-       NVRAM_TEMP,
-       0 
-    },          /* WAN netmask2 */
-    { "wan0_maskv6", "", 
-       NVRAM_TEMP,
-       0 
-    },          /* WAN netmask2 */
-    { "wan0_gateway", "",
-       NVRAM_TEMP,
-       0 
-    },       /* WAN gateway */
-    { "wan0_gatewayv6", "",
-       NVRAM_TEMP,
-       0 
-    },       /* WAN gateway */
-    { "wan0_dns", "",
-       NVRAM_TEMP,
-       0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "wan0_dnsv6", "",
-       NVRAM_TEMP,
-       0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "wan0_wins", "",
-       NVRAM_TEMP,
-       0 
-    },          /* x.x.x.x x.x.x.x ... */
-    { "wan0_failcount", "",
-       NVRAM_TEMP,
-       0 
-    },          /* WAN detection failure count */
-    { "wan0_upnp_proto", "",
-       NVRAM_TEMP,
-       0 
-    },          /* WAN UPnP proto */
-    { "wan0_upnp_ifname", "",
-       NVRAM_TEMP,
-       0 
-    },          /* WAN UPnP ifname */
-    /* Because we have v4/v6 on the same device, we have to check both when
-     * trying to bring down an interface */
-    { "wan_up_down_state_rule", "0^0",
-       NVRAM_TEMP,
-       0 
-    },          /* v4^v6 */
-
-#endif
-
-    /* WAN main rules */
-    { "wan_main_rule", WAN_MAIN_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^mtu^stp^upnp */
-    /* WAN proto parameters rules */
-    { "wan_static_rule", WAN_STATIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* ipaddr^mask^gateway^dns1^dns2^wins */
-    { "wan_dhcp_rule", WAN_DHCP_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* hostname^domain^lease*/
-    { "wan_pppoe_rule", WAN_PPPOE_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* auth^username^passwd^demand^idletime^echo_failure^redialperiod^
-         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr^servname
-         */
-    /* V6 WAN proto parameters rules */
-    { "wan_staticv6_rule", WAN_STATICV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* ipaddr^length^gateway^dns1^dns2 */
-    { "wan_dhcpv6_rule", WAN_DHCPV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* hostname^domain^lease^type[0:stateless|1:stateful] */
-    { "wan_pppoev6_rule", WAN_PPPOEV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* username^passwd^servicename^
-         * demand^idletime^echo_failure^redialperiod^
-         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr */
-#define WAN_TUNNEL6_RULE "72.52.104.74^2001:470:1f04:d1c::2/64^2001:470:1f04:d1c::1"
-    { "wan_tunnel6_rule", WAN_TUNNEL6_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* brokerv4addr^v6ipaddr_length^v6gateway */
-    { "wan_wwan_rule", WAN_WWAN_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
-         * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
-         * ctrltty^devname^flag^turbolink
-         */
-    /* wan_pptp_l2tp_rule */
-    { "wan_pptp_l2tp_rule", WAN_PPTP_L2TP_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* serverip^iptype[static|dhcp]^ipaddr^netmask^gateway^username^
-           passwd^nailup^timeout^pppiptype[isp|custom]^custom_ipaddr^
-           encmode[disabled|mppe]^auth[chap|pap|none] */
-    { "wan_wwan_probe_rule", WAN_WWAN_PROBE_RULE, 
-        NVRAM_TEMP,
-        0 
-    },  /* brand^model^signal^numtty^datatty^ctrltty^devname^flag */
-    { "wan_bigpond_rule", WAN_BIGPOND_RULE,
-        NVRAM_NONE,
-        0 
-    },  /* enable^server^username^passwd */
-    { "wan_dns_rule", WAN_DNS_RULE,
-        NVRAM_NONE,
-        0 
-    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
-    { "wan_dnsv6_rule", WAN_DNSV6_RULE,
-        NVRAM_NONE,
-        0 
-    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
-    /* WAN hwaddr */ 
-    { "wan_hwaddr_rule_default", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0
-    },  /* hwaddr */
-    /* WAN hwaddr clone */ 
-    { "wan_hwaddr_clone_rule", WAN_HWADDR_CLONE_RULE, 
-        NVRAM_NONE,
-        0
-    },  /* enable[0|1]^hwaddr^addrtype[ipaddr|hwaddr]^ipaddr */
-    /* DDNS */
-    { "wan_ddns_rule", WAN_DDNS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^type[dyndns|tzo|zoneedit]^username^
-           passwd^hostname */
-    /* OpenDNS */
-    { "wan_opendns_rule", WAN_OPENDNS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^username^passwd^redirect[0|1]^label */
-    /* WAN status rule */
-    { "wan_st_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* WAN status rule */
-    { "wan_stv6_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* LAN status rule */
-    { "lan_st_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* LAN status rule */
-    { "lan_stv6_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    /* WLAN status rule */
-    { "wlan_st_rule", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* uptime */
-    { "lan_num", xstr(LAN_NUM), 
-        NVRAM_NONE,
-        0 
-    },  /* How many LAN interfaces are available.*/
-#if LAN_NUM >= 1
-    /* LAN0 */
-    /* LAN H/W parameters */
-
-    { "lan0_ifname", LAN0_IFNAME, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN interface name */
-    { "lan0_ifnames", LAN0_IFNAMES, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN interface names */
-    { "lan0_hwname", LAN0_HWNAME, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN driver name (e.g. et1) */
-    { "lan0_device", LAN0_DEVICE, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN device name */
-    { "lan0_proto", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN device name */
-    { "lan0_protov6", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN IPv6 device name */
-    { "lan0_ports", LAN0_PORTS, 
-        NVRAM_NONE,
-        0 
-    }, /* LAN device port assignment. */
-
-    /* LAN temporary parameters */
-    { "lan0_ipaddr", "", 
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IP address */
-    /* LAN temporary parameters */
-    { "lan0_ipaddrv6", "2001:db8:feed:b00::1",
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IPv6 address */
-    { "lan0_netmask", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN netmask */
-    { "lan0_mask", "", 
-       NVRAM_TEMP,
-        0 
-    },          /* LAN netmask2 */
-    { "lan0_prefixv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 prefix */
-    { "lan0_maskv6", "64", 
-       NVRAM_TEMP,
-        0 
-    },          /* LAN IPv6 netmask2 */
-    { "lan0_gateway", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN gateway */
-    { "lan0_gatewayv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 gateway */
-    { "lan0_dns", "", 
-       NVRAM_TEMP,
-        0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "lan0_wins", "", 
-       NVRAM_TEMP,
-        0 
-    },          /* x.x.x.x x.x.x.x ... */
-#if LAN_NUM >= 2
-    /* LAN0 */
-
-    { "lan1_ifname", LAN1_IFNAME, 
-        NVRAM_NONE,
-        0 
-    },  /* LAN interface name */
-    { "lan1_proto", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN device name */
-    { "lan1_protov6", "static", 
-        NVRAM_NONE,
-        0 
-    },  /* LAN IPv6 device name */
-    /* LAN temporary parameters */
-    { "lan1_ipaddr", "", 
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IP address */
-    { "lan1_ipaddrv6", "2001:db8:feed:b00::1",
-       NVRAM_TEMP,
-        0 
-    },        /* LAN IPv6 address */
-    { "lan1_netmask", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN netmask */
-    { "lan1_mask", "", 
-       NVRAM_TEMP,
-        0 
-    },          /* LAN netmask2 */
-    { "lan1_prefixv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 prefix */
-    { "lan1_maskv6", "64", 
-       NVRAM_TEMP,
-        0 
-    },          /* LAN IPv6 netmask2 */
-    { "lan1_gateway", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN gateway */
-    { "lan1_gatewayv6", "", 
-       NVRAM_TEMP,
-        0 
-    },       /* LAN IPv6 gateway */
-    { "lan1_dns", "", 
-       NVRAM_TEMP,
-        0 
-    },           /* x.x.x.x x.x.x.x ... */
-    { "lan1_wins", "", 
-       NVRAM_TEMP,
-        0 
-    },          /* x.x.x.x x.x.x.x ... */
-#endif /* LAN_NUM >= 2*/
-#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
-    { "vlan_rule", VLAN_RULE,
-       NVRAM_NONE,
-        0 
-    },      /* name^enable[0|1]^ifname^vid^portmember^flag */
-    { "vlan_rule_num", xstr(VLAN_RULE_NUM),
-       NVRAM_NONE,
-        0 
-    },      
-    { "vlan_rule_max", xstr(VLAN_RULE_MAX),
-       NVRAM_NONE,
-        0 
-    },
-    { "vlanport_rule", VLANPORT_RULE,
-       NVRAM_NONE,
-        0 
-    },       /* name^portid^pvid^tag^gmemb */
-    { "vlanport_rule_num", xstr(VLANPORT_RULE_NUM),
-       NVRAM_NONE,
-        0 
-    },      
-    { "vlanport_rule_max", xstr(VLANPORT_RULE_MAX),
-       NVRAM_NONE,
-        0 
-    },
-    { "br_rule", BR_RULE,
-       NVRAM_NONE,
-        0
-    },      /* name^enable[0|1]^ifnames^flag */
-    { "br_rule_num", xstr(BR_RULE_NUM),
-       NVRAM_NONE,
-        0
-    },
-    { "br_rule_max", xstr(BR_RULE_MAX),
-       NVRAM_NONE,
-        0
-    },
-#ifdef CONFIG_EZP_ARCH_RT305X
-    NVRAM_EZPACKET_DEFAULT_RT305X_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_2
-#endif
-#elif defined(CONFIG_EZP_ARCH_RT3883)
-    NVRAM_EZPACKET_DEFAULT_RT3883_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_2
-#endif
-#endif
-#endif
-
-#ifdef CONFIG_EZP_ARCH_BRCM
-    NVRAM_EZPACKET_DEFAULT_BRCM_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_2
-#endif
-#endif
-#endif
-
-#ifdef CONFIG_EZP_ARCH_AS500
-    NVRAM_EZPACKET_DEFAULT_AS500_LAN_NUM_1
-    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_1
-#if (WAN_NUM == 2)
-    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_2
-#endif
-    NVRAM_EZPACKET_DEFAULT_AS500_SWAP
-    NVRAM_EZPACKET_DEFAULT_AS500_INITD
-#endif
-
-    { "lan_main_rule", LAN_MAIN_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^mtu^stp^weight */
-    { "lan_hwaddr_rule_default", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0
-    },  /* hwaddr */
-    { "lan_static_rule_default", LAN_STATIC_RULE_DEFAULT, 
-        NVRAM_NONE,
-        0 
-    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
-    { "lan_static_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
-    { "lan_staticv6_rule_default", LAN_STATICV6_RULE_DEFAULT, 
-        NVRAM_NONE,
-        0 
-    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
-         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
-    { "lan_staticv6_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
-         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
-         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
-    /* DHCP server parameters */
-    { "lan_dhcps_rule", LAN_DHCPS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^start^num^lease^domain^wins^
-           dnstype[ispdns|opendns|custom|none]^dnsaddr1^
-           dnsaddr2^dnsaddr3^dnsaddr4^dnstype2^dnstype3^dnstype4 */
-    /* LAN hwaddr clone */
-    { "lan_dhcpsv6_rule", LAN_DHCPSV6_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^pppoe_prefix^static_prefix^dhcp_prefix^
-           domain^
-           dnstype[auto|custom]^
-           dnsaddr1^dnsaddr2^type[1|0]^
-           start^end^lifetime" */
-    /* LAN hwaddr clone */
-    { "lan_hwaddr_clone_rule", LAN_HWADDR_CLONE_RULE, 
-        NVRAM_NONE,
-        0
-    },  /* enable[0|1]^hwaddr[XX:XX:XX:XX:XX:XX] */
-    /* Guest lan rule */
-#define GUEST_LAN_RULE "0^rai3^br2^1^192.168.2.1^24^0^0^1^hp_guest.com^33^32"
-    { "guest_lan_rule", GUEST_LAN_RULE,
-        NVRAM_NONE,
-        0
-    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
-         * domain : domain name for this dns group
-         * start : dhcp offering start ip address
-         * count : total count dhcp server can offer
-         * */
-#define GUEST_5G_LAN_RULE "0^ra3^br2^1^192.168.2.1^24^0^0^1^hp_5g_guest.com^33^32"
-    { "guest1_lan_rule", GUEST_5G_LAN_RULE,
-        NVRAM_NONE,
-        0
-    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
-         * domain : domain name for this dns group
-         * start : dhcp offering start ip address
-         * count : total count dhcp server can offer
-         * */
-    /* MASK */
-    { "rt_mask", "0xF0000000", 
-        NVRAM_NONE,
-        0 },      /* Routing mask: 4-bit */
-    { "reserved_mask", "0x0F000000", 
-        NVRAM_NONE,
-        0 },      /* Reserved mask: 4-bit */
-    { "fl_mask", "0x0000FFFF", 
-        NVRAM_NONE,
-        0 },      /* FL mask: 16-bit */
-    { "fl_mark_default", "0x0000FFFF", 
-        NVRAM_NONE,
-        0 },      /* FL mask: 16-bit */
-
-    /* turboNAT */
-    { "turbonat_enable", "0", 
-        NVRAM_NONE,
-        0 
-    },   /* enable [0|1] */
-    /* Session Manager */
-    { "sm_mode", "fast", 
-        NVRAM_NONE,
-        0 
-    },   /* mode [fast|regular|slow] */
-    /* Bandwidth */
-    /*{ "bw_rule", BW_RULE,*/
-    { "bw_rule", "0^32768^32768",
-        NVRAM_NONE,
-        0 
-    },   /* enable^bw_upload^bw_download */
-    { "bw_monitor_rule", "1",
-        NVRAM_NONE,
-        0 
-    },   /* enable */
-    { "bw_tc_mask", "0x00FF0000", 
-        NVRAM_NONE,
-        0 
-    },   /* BW mask */
-    /* SBM */
-    { "bw_sbm_mask", "0x00FF0000", 
-        NVRAM_NONE,
-        0 
-    },   /* BW mask */
-    /*{ "bw_app_rule", BW_APP_RULE, */
-    /* Easy mode */
-    { "bw_ezmodesort_rule", "Game Console|VoIP|Instant Messenger|Web Surfing|P2P/FTP|E-Mail",
-        NVRAM_NONE,
-        0 
-    },   /* catname */
-    { "bw_ezmodesort_rule_num", "6", 
-        NVRAM_NONE,
-        0 
-    },
-    { "bw_ezmodesort_rule_max", "6", 
-        NVRAM_NONE,
-        0 
-    },
-    { "bw_app_rule_num", "11",
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-    { "bw_app_rule_max", "32", 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-#define XBOX_APP "appl^0^1^1^Game Console^XBox Live^3074,3390,3932,5555^88,1900,3074,3776,3777^1^50^1^1^50^1^1^10^1^1^10^1"
-#define PLAYSTATION_APP "appl^0^1^1^Game Console^PlayStation^5223^3478,3479,3658,4658^1^50^1^1^50^1^1^10^1^1^10^1"
-#define MSN_GAME_APP "appl^0^1^1^Game Console^MSN Game Zone^6667,28800:29000^6667,28800:29000^1^50^1^1^50^1^1^10^1^1^10^1"
-#define BATTLENET_APP "appl^0^1^1^Game Console^Battlenet^40,112,6112,4000,6113:9119^^1^50^1^0^50^1^1^10^1^0^10^1"
-#define VOIP_APP "appl^0^1^1^VoIP^VoIP^5060^5060^1^50^1^0^50^1^1^10^1^0^10^1"
-#define IM_APP "appl^0^1^1^Instant Messenger^Instant Messenger^6891:6901,1863^1863,5190,6901^1^50^1^0^50^1^1^10^1^0^10^1"
-#define WEB_APP "appl^0^1^1^Web Surfing^Web Surfing^80,443^^1^50^1^0^50^1^1^10^1^0^10^1"
-#define FTP_APP "appl^0^1^1^P2P/FTP^FTP^21,22^^1^50^1^0^50^1^1^10^1^0^10^1"
-#define EMULE_APP "appl^0^1^1^P2P/FTP^eMule^4662^4672^1^50^1^0^50^1^1^10^1^0^10^1"
-#define BT_APP "appl^0^1^1^P2P/FTP^BitTorrent^tport^uport^1^50^1^1^50^1^1^10^1^1^10^1"
-#define EMAIL_APP "appl^0^1^1^E-Mail^E-Mail^110,995,25,465,587,220,143,993^^1^50^1^0^50^1^1^10^1^0^10^1"
-    { "bw_app_rule", XBOX_APP"|"PLAYSTATION_APP"|"MSN_GAME_APP"|"BATTLENET_APP"|"VOIP_APP"|"IM_APP"|"WEB_APP"|"FTP_APP"|"EMULE_APP"|"BT_APP"|"EMAIL_APP,
-        NVRAM_NONE,
-        0 
-    }, /* name^enable^index^prio^cat^serv^
-          tcp_port[port|port_beg:port_end]^
-          udp_port[port|port_beg:port_end]^
-          lan_tcp_enable^lan_tcp_bw^lan_tcp_min[0:max bw|1:min bw]^
-          lan_udp_enable^lan_udp_bw^lan_udp_min[0:max bw|1:min bw]^
-          wan_tcp_enable^wan_tcp_bw^wan_tcp_min[0:max bw|1:min bw]^
-          wan_udp_enable^wan_udp_bw^wan_udp_min[0:max bw|1:min bw] */
-#define ACCESS1 "access^ROGROUP^\"\"^any^noauth^exact^all^none^none"
-#define ACCESS2 "access^RWGROUP^\"\"^any^noauth^exact^all^all^all"
-    { "snmpd_access_rule", ACCESS1"|"ACCESS2,
-        NVRAM_NONE,
-        0 
-    }, 
-#define GROUP1 "group^RWGROUP^v1^rw"
-#define GROUP2 "group^RWGROUP^v2c^rw"
-#define GROUP3 "group^RWGROUP^usm^rw"    
-#define GROUP4 "group^ROGROUP^v1^ro"
-#define GROUP5 "group^ROGROUP^v2c^ro"
-#define GROUP6 "group^ROGROUP^usm^ro"    
-	{ "snmpd_group_rule", GROUP1"|"GROUP2"|"GROUP3"|"GROUP4"|"GROUP5"|"GROUP6,
-        NVRAM_NONE,
-        0 
-    }, 
-	{ "snmpd_view_rule", "view^all^included^.1^80",
-        NVRAM_NONE,
-        0 
-    }, 
-    { "bw_sbm_rule", BW_SBM_RULE,
-        NVRAM_NONE,
-        0 
-    }, /* name^enable^inipaddr_start^inipaddr_end^proto^extif^
-          bw_towan^bw_tolan^apptype^prio^
-          outipaddr_start^outipaddr_end^inport^outport^reserve_bw */
-    { "bw_sbm_rule_num", BW_SBM_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-    { "bw_sbm_rule_max", BW_SBM_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing BW rules */
-    /* Policy-based routing */
-    { "rt_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },   /* Routing [0|1] */
-    //{ "rt_rule", RT_RULE, 
-    { "rt_rule", "",
-        NVRAM_EMPTY,
-        0 
-    }, /* name^enable[0|1]^srcipaddr_start^srcipaddr_end^dstipaddr_start^
-          dstipaddr_end^proto^srcport_start^srcport_end^dstport_start^
-          dstport_end^extif^routing_type[default|static]^gateway_ipaddr^
-          netmask^matric */
-    //{ "rt_rule_num", "1",
-    { "rt_rule_num", "0",
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing RT rules */
-    { "rt_rule_max", RT_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing RT rules */
-
-    /*  routing */
-    { "rt_conn_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },   /* Routing cache [0|1] */
-    { "rt_rip_rule", RT_RIP_RULE, 
-        NVRAM_NONE,
-        0 
-    }, /* rip[v1/v2/none] */
-    { "nat_rule", NAT_RULE, 
-        NVRAM_NONE,
-        0 
-    }, /* enable */
-#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
-    { "hwnat_rule", HWNAT_RULE, 
-        NVRAM_NONE,
-        0 
-    }, /* enable */
-#endif
-    /* web url/content filtering rule */
-    { "wf_enable", "1",
-        NVRAM_NONE,
-        0
-    }, /* web url filtering [0|1] */
-    { "wf_content_rule", "0^0^0^0^0^",
-        NVRAM_NONE,
-        0
-    }, /* activex_enable^java_enable^proxy_enable^cookie_enable^url_enable^trustipaddr */
-    { "wf_rule", "",
-        NVRAM_EMPTY,
-        0
-    }, /* enable^keyword^type^access */
-    { "wf_rule_num", "0",
-        NVRAM_NONE,
-        0
-    },
-    { "wf_rule_max", WF_RULE_MAX,
-        NVRAM_NONE,
-        0
-    },
-    /* IGMP related rule */
-    { "igmp_proxy_rule", IGMP_PROXY_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* enable */
-    { "igmp_snoop_rule", IGMP_SNOOP_RULE, 
-        NVRAM_NONE,
-        0 
-    },   /* enable^p1^p2^p3^p4 */
-    /* Schedule rule */
-    { "sched_enable", "0", 
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    { "sched1_enable", "0", // for 5g
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    /* Schedule rule */
-    { "sched_enable_bak", "0", 
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    { "sched1_enable_bak", "0", // for 5g
-        NVRAM_NONE,
-        0 
-    },       /* Enable/Disable scheduling function  */
-    { "sched_rule", SCHED_RULE,
-        NVRAM_NONE,
-        0 
-    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
-         /* cat:   category, which will cause invoking action
-          * month: apply month
-          * date:  apply date of month
-          * wkday: apply day of week
-          * beghr,begmin: begin hour and minute of day
-          * endhr,endmin: end hour and minute of day
-          * wlanstatus: wlan status
-          */
-    { "sched1_rule", SCHED1_RULE,
-        NVRAM_NONE,
-        0 
-    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
-         /* cat:   category, which will cause invoking action
-          * month: apply month
-          * date:  apply date of month
-          * wkday: apply day of week
-          * beghr,begmin: begin hour and minute of day
-          * endhr,endmin: end hour and minute of day
-          * wlanstatus: wlan status
-          */
-    { "sched_rule_num", SCHED_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-    { "sched_rule_max", SCHED_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-    { "sched1_rule_num", SCHED1_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-    { "sched1_rule_max", SCHED1_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },       /* The amount of existing sched rules */
-
-    { "fw_upgrade_rule", FW_UPGRADE_RULE,
-        NVRAM_NONE,
-        0 
-    },   /* method^server^path^username^passwd^inf_filename */
-         /* rule set 0 for default online firmware upgrade settings */
-    { "fw_info_rule", "",
-        NVRAM_TEMP,
-        0 
-    },   /* model^version^revision^date^size^filename^release_note^
-            info_ok[1:got fw info | 0:no info]^
-            fw_ok[1:got fw | 0:no fw]^
-            relnote_ok[1:got release note | 0:no release note] */
-         /* rule set 0 for default online firmware upgrade settings */
-    
-    /* RRDCOLLECT */
-    { "rrd_enable", "0", 
-        NVRAM_NONE,
-        0 },    /* RRDcollect client */
-
-    /* Cron */
-    { "cron_rule", "1^1^02 4 * * *", 
-        NVRAM_NONE,
-        0 
-    }, /* enable^ntp_enable[0|1]^ntp_interval */
-
-    /* NTP */
-    //{ "ntp_rule", "^1^pool^pool.ntp.org^^UTC-8^^^^^^^^^^^^^^",
-    { "ntp_rule", "^1^pool^pool.ntp.org^^GMT0BST,M3.5.0/2,M10.5.0/2^0^^^^^^^0^^^^^^^^0^", 
-        NVRAM_NONE,
-        0 
-    }, /* name^enable[0|1]^type^pool^ipaddr^zone^
-          custom_time[0|1]^year^mon^date^hour^min^sec^
-          daylight_saving[0|1]^
-          ds_start_mon^ds_start_day^ds_start_hour^
-          ds_end_mon^ds_end_day^ds_end_hour^customized^
-          custom_server[0|1]^serv_ipaddr */
-
-    /* SSH */
-    { "ssh_rule", "^0^8123", 
-        NVRAM_NONE,
-        0 
-    },       /* name^enable[0|1]^port */
-
-/* Added by Abocom */
-    /* log parameters */
-    { "log_selected_num", "9", 
-        NVRAM_NONE,
-        0 
-    },        /* Log selection number */
-    { "log_index", "show_all", 
-        NVRAM_NONE,
-        0 
-    },
-    /* Log Index */    
-    { "log_rule", LOG_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^ipaddr^ipt_enable^web_mgmt^dns^ppp^
-           upnp^wireless^ntp^sys_warning^dhcp_serv^dhcp_cli^
-           ddns^firewall */
-    /* uPnP */
-    { "upnp_rule", "^1^0^wan0^lan0^5555", 0 },
-    /* name^enable[0|1]^pmp_enable[0|1]^extif^inif^port */
-
-    /* Filters */
-    { "fl_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },    /* fl_enable [0|1] */
-    { "fl_rule", FL_RULE, 
-        NVRAM_EMPTY,
-        0 
-    },    /* name^enable[0|1]^extif^inif^proto^srcip^srcmask^
-                                dstip^dstmask^srcport^dstport^
-                                action[0(DROP)|1(ACCEPT)]^mark^bw_idx^
-                                sched_idx */
-
-    { "fl_rule_num", FL_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },      /* The amount of existing log rules */
-    { "fl_rule_max", FL_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },
-    { "fl_rule_default", "1", 
-        NVRAM_NONE,
-        0 
-    },
-
-    { "fl_hwaddr_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },    /* fl_hwaddr_enable [0|1] */
-    { "fl_hwaddr_rule", "", 
-        NVRAM_EMPTY,
-        0 
-    },    /* name^acl_enable[0|1]^dhcp_enable^arp_enable^hwaddr^
-             action[0(DROP)|1(ACCEPT)]^ipaddr */
-    { "fl_hwaddr_rule_num", "0", 
-        NVRAM_NONE,
-        0 
-    }, /* The amount of existing fl_hwaddr rules */
-    { "fl_hwaddr_rule_max", FL_HWADDR_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },
-    { "fl_hwaddr_rule_default", "1", 
-        NVRAM_NONE,
-        0 
-    },
-
-    /* Port forwards */
-    { "fr_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },  /* fr_enable [0|1] */
-    { "fr_rule", FR_RULE, 
-        NVRAM_EMPTY,
-        0 
-    },  /* name^enable[0|1]^extif^proto[tcp|udp|both]^extport_start^extport_end^ipaddr^inport_start^inport_end */
-    { "fr_rule_num", FR_RULE_NUM, 
-        NVRAM_NONE,
-        0 
-    },      /* fr_rule_num */
-    { "fr_rule_max", FR_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },      /* fr_rule_max */
-    { "fr_dmz_rule", FR_DMZ_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable[0|1]^ipaddr */
-
-    /* Port triggle */
-    { "pt_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },  /* pt_enable [0|1] */
-    { "pt_rule", PT_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable^proto[tcp|udp|all]^port_start^port_end^trig_port_start^trig_port_end */
-    { "pt_rule_num", "12", 
-        NVRAM_NONE,
-        0 
-    },  /* pt_rule_num */
-    { "pt_rule_max", PT_RULE_MAX, 
-        NVRAM_NONE,
-        0 
-    },  /* pt_rule_max */
-
-#if ( WL_NUM > 0 )
-    /* Wireless interface */
-    { "wl_num", xstr(WL_NUM), 
-        NVRAM_NONE,
-        0 
-    },      /* Enable (1) or disable (0) radio */
-    /* Wireless parameters */
-    { "wl_region_default", "0", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },      /* Region code default */
-    { "wl_region", "", 
-        NVRAM_DEFAULT,
-        0 
-    },      /* Region code */
-    { "wl_countrycode_default", WL_COUNTRY_CODE, 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },      /* Region code */
-    { "wl_countrycode", WL_COUNTRY_CODE, 
-        NVRAM_DEFAULT,
-        0 
-    },      /* Region code */
-    { "wl_regionaband_default", WL_REGION_ABAND, 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },      /* Region code */
-    { "wl_regionaband", "", 
-        NVRAM_DEFAULT,
-        0 
-    },      /* Region code */
-    { "wl_ieee80211h", "1", 
-        NVRAM_DEFAULT,
-        0 
-    },      /* IEEE802.11H */
-    /* Physical interface related rules*/
-    { "wl_rule_num", xstr(WL_NUM),     /* How many WLan interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl_rule_max", xstr(WL_NUM),     /* How many WLan interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    /* Virtual interface related rules for wl0/wl1... */
-    { "wlv_rule_num", xstr(WL0_RULE_NUM) ,     /* How many virtual wl0 interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wlv_rule_max", xstr(WL0_RULE_MAX),     /* Max virtual wl0 interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl_enabled_rule", "0", 
-        NVRAM_TEMP,
-        0 
-    },      /* Enable (1) or disable (0) radio */
-    /* This setting reserved the must original wireless setting
-     * such as hardware button status. Some application ,like schedular, 
-     * may change the wifi at run time. We can use this setting to restore
-     * the original setting. 
-     * Currently, only /sbin/ezp-wifionoff may change its value */
-    { "wl_origset_rule", "1",
-        NVRAM_NONE,
-        0 
-    },      /* enable */
-    { "wl1_origset_rule", "1",
-        NVRAM_NONE,
-        0 
-    },      /* enable  for 5g */
-    { "wl_basic_rule", WL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^net_mode^txpower^channel^bisolation */
-    { "wl5g_basic_rule", WL5G_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^net_mode^txpower^channel^bisolation */
-    { "wl_advanced_rule", WL_ADVANCED_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
-               gmode^gmode_protection^afterburner^frameburst^
-               txburst[0:disable|1:enable->1]^
-               pktaggr[0:disable|1:enable->0]^
-               txmode[0:None|1:CCK|2:OFDM->0]^
-
-               rdg[0:disable|1:enablei->0]^
-               linkadapt[0:disable|1:enable->0]^
-               htc[0:disable|1:enable->0]^
-
-               htbw[0:20|1:20/40->1]^
-               gi[0:long|1:short->1]^
-               opmode[0:mixed|1:GreenField->0]^
-               mcs[0~15,32,33=auto->33]^
-               mpdu[0 none, 1~7 -> 5]^
-               amsdu[0:disable|1:enable->0]^
-
-               autoba[0:disable|1:enable->1]^
-               bawinsize[1~64,default=8,iot=64->64]^
-               badecline[0:disable|1:enable->1->0]^
-               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
-               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
-             */
-    { "wl1_advanced_rule", WL1_ADVANCED_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
-               gmode^gmode_protection^afterburner^frameburst^
-               txburst[0:disable|1:enable->1]^
-               pktaggr[0:disable|1:enable->0]^
-               txmode[0:None|1:CCK|2:OFDM->0]^
-
-               rdg[0:disable|1:enablei->0]^
-               linkadapt[0:disable|1:enable->0]^
-               htc[0:disable|1:enable->0]^
-
-               htbw[0:20|1:20/40->1]^
-               gi[0:long|1:short->1]^
-               opmode[0:mixed|1:GreenField->0]^
-               mcs[0~15,32,33=auto->33]^
-               mpdu[0 none, 1~7 -> 5]^
-               amsdu[0:disable|1:enable->0]^
-
-               autoba[0:disable|1:enable->1]^
-               bawinsize[1~64,default=8,iot=64->64]^
-               badecline[0:disable|1:enable->1->0]^
-               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
-               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
-             */
-    { "wl_wds_rule", WL_WDS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
-    { "wl1_wds_rule", WL1_WDS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
-    { "wl_wme_rule", WL_WME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* sta_bk^Sta_be^sta_vi^sta_vo^ap_bk^ap_be^ap_vi^ap_vo^no_ack^max_assoc */
-    { "wl_mode_rule", WL_MODE_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[normal|ap|ur|wisp]^
-             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
-             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
-    { "wl1_mode_rule", WL1_MODE_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[normal|ap|ur|wisp]^
-             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
-             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
-    { "wl_wps_rule", WL_WPS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
-    { "wl1_wps_rule", WL1_WPS_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
-    { "wl_wps_sta_rule", WL_WPS_STA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
-    { "wl1_wps_sta_rule", WL1_WPS_STA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
-    { "wl_led_status_rule", "9^9",
-        NVRAM_TEMP,
-        0 
-    },      /* wl^wps */
-    { "wl0_basic_rule", WL0_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^hidden^rate^wme^isolation */
-    { "wl1_basic_rule", WL1_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^hidden^rate^wme^isolation */
-    { "wl0_ifname_rule", WL0_IFNAME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl0_ssid_rule", WL0_SSID_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl1_ssid_rule", WL5G_SSID_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl0_sec_rule", WL0_SEC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* secmode */
-    { "wl0_sec_wep_rule", WL0_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^
-               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl0_sec_wpa_rule", WL0_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^session_timeout */
-    { "wl0_sec_wpa2_rule", WL0_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
-    { "wl1_sec_rule", WL1_SEC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* secmode */
-    { "wl1_sec_wep_rule", WL0_SEC_5G_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^
-               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl1_sec_wpa_rule", WL0_SEC_5G_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^session_timeout */
-    { "wl1_sec_wpa2_rule", WL0_SEC_5G_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
-/* acl policy can apply to each ssid, we add rule according to ssid number */
-#if (WL0_RULE_MAX >= 1)
-    { "wl00_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl00_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl00_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl00_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 2)
-    { "wl01_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl01_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl01_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl01_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 4)
-    { "wl02_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl02_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl02_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl02_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-    { "wl03_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl03_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl03_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl03_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#endif /* WL0_RULE_MAX >= 4 */
-#endif /* WL0_RULE_MAX >= 2 */
-#endif /* WL0_RULE_MAX >= 1 */
-/*  5g acl policy can apply to each ssid, we add rule according to ssid number */
-#if (WL0_RULE_MAX >= 1)
-    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl10_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl10_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl10_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 2)
-    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl11_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl11_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl11_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 4)
-    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl12_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl12_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl12_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl13_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl13_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl13_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#endif /* WL0_RULE_MAX >= 4 */
-#endif /* WL0_RULE_MAX >= 2 */
-#endif /* WL0_RULE_MAX >= 1 */
-#if 0
-#if ( WL_NUM >= 2 )
-    { "wl1_basic_rule", WL1_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^hidden^rate^wme^isolation */
-    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ifname */
-    { "wl1_ssid_rule", WL1_SSID_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* ssid */
-    { "wl1_sec_rule", WL1_SEC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* secmode */
-    { "wl1_sec_wep_rule", WL1_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^
-               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl1_sec_wpa_rule", WL1_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^session_timeout */
-    { "wl1_sec_wpa2_rule", WL1_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
-               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
-/* acl policy can apply to each ssid, we add rule according to ssid number */
-#if (WL0_RULE_MAX >= 1)
-    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl10_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl10_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl10_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 2)
-    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl11_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl11_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl11_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#if (WL0_RULE_MAX >= 4)
-    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl12_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl12_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl12_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^defpolicy */
-    { "wl13_acl_num", "0", 
-        NVRAM_NONE,
-        0 
-    },      /* number of acl mac list */
-    { "wl13_acl_max", xstr(WL_ACL_MAX), 
-        NVRAM_NONE,
-        0 
-    },      /* max number of acl mac list */
-    { "wl13_acl_rule", "", 
-        NVRAM_NONE,
-        0 
-    },      /* name^enable^mac^policy */
-#endif /* WL0_RULE_MAX >= 4 */
-#endif /* WL0_RULE_MAX >= 2 */
-#endif /* WL0_RULE_MAX >= 1 */
-#endif /* WL_NUM >= 2 */
-#endif
-    /* wds related rules */
-    { "wl0_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_wds_basic_rule", WL0_WDS_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* hwaddr^secmode */
-    { "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
-        NVRAM_NONE,
-        0 
-    },  
-    { "wl1_wds_basic_rule", WL1_WDS_BASIC_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* hwaddr^secmode */
-    { "wl0_wds_sec_wep_rule", "|||", 
-        NVRAM_NONE,
-        0 
-    },      /* key */
-    { "wl0_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl1_wds_sec_wep_rule", "|||", 
-        NVRAM_NONE,
-        0 
-    },      /* key */
-    { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    /* apcli related rules */
-    { "wl0_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl0_apcli_rule", WL0_APCLI_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^ssid^bssid^secmode */
-    { "wl0_apcli_sec_wep_rule", WL0_APCLI_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
-    { "wl0_apcli_sec_wpa_rule", WL0_APCLI_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl0_apcli_sec_wpa2_rule", WL0_APCLI_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
-        NVRAM_NONE,
-        0 
-    },   
-    { "wl1_apcli_rule", WL1_APCLI_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* enable^ssid^bssid^secmode */
-    { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
-    { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
-        NVRAM_NONE,
-        0 
-    },      /* key^crypto */
-    { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
-        NVRAM_NONE,
-        0 
-    }, 
-#if ( WL_NUM >= 2 )
-    //{ "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
-     //   NVRAM_NONE,
-     //   0 
-    //},   
-   // { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
-   //     NVRAM_NONE,
-   //     0 
-  //  },   
-    //{ "wl1_wds_basic_rule", "^disabled|^disabled|^disabled|^disabled", 
-    //    NVRAM_NONE,
-    //    0 
-    //},      /* mac^secmode */
-    //{ "wl1_wds_sec_wep_rule", "|||", 
-    //    NVRAM_NONE,
-    //    0 
-    //},      /* key */
-   // { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
-   //     NVRAM_NONE,
-   //     0 
-   // },      /* key^crypto */
-    /* apcli related rules */
-    //{ "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
-     //   NVRAM_NONE,
-     //   0 
-   // },   
-    //{ "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
-    //    NVRAM_NONE,
-    //    0 
-    //},   
-   // { "wl1_apcli_rule", WL1_APCLI_RULE, 
-   //     NVRAM_NONE,
-  //      0 
-  //  },      /* enable^ssid^bssid^secmode */
-  //  { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
-  //      NVRAM_NONE,
-  //      0 
-  //  },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
-  //  { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
-   //     NVRAM_NONE,
-  //      0 
-  //  },      /* key^crypto */
-  //  { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
-  //      NVRAM_NONE,
-  //      0 
-  //  },      /* key^crypto */
-#endif
-#endif
-    /* for firewall */
-    { "fw_rule", "1^1^1^1^1^0^1^0", 
-        NVRAM_NONE,
-        0 
-    },  /* enable^syn_enable^icmp_enable^icmp_redir_enable
-           ^icmp_ping_enable^rpfilter_enable^state_enable^
-           wantolan_enable[0:drop non-DNAT wan-to-lan connection request|1:otherwise] */
-    { "nat_pass_rule", "1^1^1^1^1^1^1", 
-        NVRAM_NONE,
-        0 
-    },  /* enable^ipsec_enable^pptp_enable^l2tp_enable^
-           h323_enable^rtsp_enable^mms_enable */
-    /* TTL */
-    { "ttl_rule", "^0^64", 
-        NVRAM_NONE,
-        0 
-    },        /* TTL name^enable[1|0]^value */
-    /* TOS */
-    { "tos_rule", "1^1^1^1^1^1^1", 
-        NVRAM_NONE,
-        0 
-    },   /* TOS enable^icmp_enable^dns_enable^ssh_enable^
-            telnet_enable^check_enable^ack_enable */
-    /* MSS */
-    { "mss_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },        /* TOS [1|0] */
-
-    /* SNAT */
-    { "snat_enable", "1", 
-        NVRAM_NONE,
-        0 
-    },        /* SNAT [1|0] */
-
-    /* Conntrack max amount */
-    { "ct_max", CT_MAX, 
-        NVRAM_NONE,
-        0 
-    },        /* SNAT [1|0] */
-    /* Web server parameters */
-    { "http_rule_default", "^1^0^admin^1234^80^^5", 
-        NVRAM_NONE,
-        0 
-    }, /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
-    { "http_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    },  /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
-    {"rip_conf_rule_default", "0^0^0^0^0^0^0^0",
-      NVRAM_NONE,
-      0
-    },
-   {"rip_conf_rule", "",
-      NVRAM_DEFAULT,
-      0
-    },
-    { "snmpd_user_rule_default", "1^1^1^1", 
-        NVRAM_NONE,
-        0 
-    }, /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
-    { "snmpd_user_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    }, 
-    { "snmpd_com2sec_rule_default", "com2sec^ro^default""|""com2sec^rw^default", 
-        NVRAM_NONE,
-        0 
-    }, 
-    { "snmpd_com2sec_rule", "", 
-        NVRAM_DEFAULT,
-        0 
-    }, /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
-    { "adtool_rule", "any^^4^any^^4^any^^4",
-        NVRAM_NONE,
-        0
-    }, /* pingiface^pinghost^pingcnt^arpingiface^arpinghost^arpingcnt^tracerouteiface^traceroutehost^traceroutecnt */
-    { "stats_rule", STATS_RULE, 
-        NVRAM_NONE,
-        0 
-    },  /* name^enable[0|1]^stime^ifnames */
-    { "stats_type", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_ifname */
-    { "stats_ifname", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_ifname */
-    { "stats_proto", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_ifname */
-    { "stats_interval", "", 
-        NVRAM_TEMP,
-        0 
-    },  /* stats_time hourly:60, daily:600, weekly: 3600, monthly: 3600*6 */
-    { "no_root_swap", "1", 
-        NVRAM_NONE,
-        0 
-	}, /* no_root_swap */ 
-    /* enable^pptp_enable^ipsec_enable^l2tp_enable */
-    { "smb_vpn_passthrough_rule", "1^1^1", 
-        NVRAM_NONE,
-        0 
-    }, 
-    /* IPsec */
-	{ "ipsec_enable", "0",
-		NVRAM_NONE,
-		0    
-	},   
-#ifdef IPSEC_RULE_MAX
-#undef IPSEC_RULE_MAX
-#define IPSEC_RULE_MAX "32"
-#else 
-#define IPSEC_RULE_MAX "32"
-#endif
-	{ "ipsec_rule_max", IPSEC_RULE_MAX,
-		NVRAM_NONE,
-		0    
-	}, /* value */
-	{ "ipsec_rule_num", "0", 
-		NVRAM_NONE,
-		0    
-	}, /* value */
-	{ "ipsec_rule", "",  
-		NVRAM_NONE,
-		0    
-	},
-	/*
- name^enable^mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init^ike_keymode^psk^rsa^ca^adv^phase1_mode^phase1_auth^phase1_encrypt^phase1_group^phase1_id^phase2_auth^phase2_encrypt^phase2_group^phase1_lifetime^phase2_lifetime^dpd_enable^dpd_interval^dpd_timeout
-
-	 */
-	{ "ipsec_status_rule", "",
-		NVRAM_TEMP,
-		0
-	}, /* phase1[none|established]^phase2[none|established] */
-
-#undef PPTPD_SESSION_MAX
-#undef PPTPD_USER_RULE_MAX
-#undef L2TPD_SESSION_MAX
-#undef L2TPD_USER_RULE_MAX
-#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
-#define PPTPD_USER_RULE_MAX "32"
-#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
-#define L2TPD_USER_RULE_MAX "32"
-	/*pptpd*/
-    { "pptpd_rule", "0^pptp-server^60^1460^1482^192.168.38.1^" xstr(PPTPD_SESSION_MAX) "^192.168.39.1^" xstr(PPTPD_SESSION_MAX) "^1^^0^0^1^0^0^1^0^1",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^name^redialperiod^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable[0|1]^dns^chap_enable[0|1]^mschap_enable[0|1]^mschapv2_enable[0|1]^eap_enable[0|1]^pap_enable[0|1]^mppe128_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
-
-    { "pptpd_user_rule", "",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^username^provider^passwd^ipaddr */
-    { "pptpd_user_rule_num", "0",
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-    { "pptpd_user_rule_max", PPTPD_USER_RULE_MAX,
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-    { "pptpd_session_max", xstr(PPTPD_SESSION_MAX), 
-        NVRAM_NONE,
-        0 
-    },  /* value */
-    /*l2tpd*/
-    { "l2tpd_rule", "0^l2tp-server^1400^1400^192.168.48.1^" xstr(L2TPD_SESSION_MAX) "^192.168.49.1^" xstr(L2TPD_SESSION_MAX) "^1^^1^0^1^1",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^name^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable^dns^chap_enable[0|1]^pap_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
-    { "l2tpd_user_rule", "",
-        NVRAM_NONE,
-        0 
-    },  /* enable[0|1]^username^provider^passwd^ipaddr */
-    { "l2tpd_user_rule_num", "0",
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-    { "l2tpd_user_rule_max", L2TPD_USER_RULE_MAX,
-        NVRAM_NONE,
-        0 
-    },  /* username^provider^passwd^ipaddr */
-
-	{ "wol_rule", "",
-		NVRAM_NONE,
-		0 
-	},  /* name^enable^bcast^hwaddr^iface^passwd */
-	{ "lang_default", "EN", 
-		NVRAM_NONE,
-		0 
-	},  /* Default web language support */
-	{ "lang", "", 
-		NVRAM_DEFAULT,
-		0 
-	},  /* Web language support */
-	{ "brand", "HPn", 
-		NVRAM_NONE,
-		0 
-	},  /* Brand name - CSS style and SSID. */
-#define UPNP_FRIENDLYNAME   "HPn WP777 Internet Sharing Gateway"
-#define MANUFACTURER        "HPn Communications Corp."
-#define MANUFACTURERURL     "http://www.hp.com"
-#define MODELDESCRIPTION    "HPn WP777 Internet Sharing Gateway"
-#define MODELNAME           "HPn Internet Sharing Gateway"
-#define MODELNUMBER         "WP777"
-#define MODELURL            ""
-#define SERIALNUMBER        "A19003848"
-#define UDN                 "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e"
-#define PRESENTATIONURL     ""
-    { "upnpxml_rule", UPNP_FRIENDLYNAME"^"MANUFACTURER"^"MANUFACTURERURL"^"MODELDESCRIPTION"^"MODELNAME"^"MODELNUMBER"^"MODELURL"^"SERIALNUMBER"^"UDN"^"PRESENTATIONURL, 
-        NVRAM_NONE,
-        0 
-    },  /* friendlyName^manufacturer^manufacturerURL^modelDescription^
-         * modelName^modelNumber^modelURL^serialNumber^UDN^presentationURL */
-    { "igd", "WP777 IGD Version 1.00", 
-        NVRAM_NONE,
-        0 
-    },  /* Brand name - CSS style and SSID. */
-    { "udn", "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e", 
-        NVRAM_NONE,
-        0 
-    },  /* Brand name - CSS style and SSID. */
-    { "model", "WP777 Internet Gateway Device", 
-        NVRAM_NONE,
-        0 
-    },              /* Product model */
-    { "license_key", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },              /* Product model */
-    { "hostname", "WP777",
-        NVRAM_NONE,
-        0 
-    },           /* Hostname */
-    { "prod_cat", xstr(EZP_PROD_CAT), 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },           /* Product category */
-    { "prod_subcat", xstr(EZP_PROD_SUBCAT), 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* Product subcategory */
-    { "prod_subsubcat", xstr(EZP_PROD_SUBSUBCAT), 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* Product sub-subcategory */
-    { "machine_id", "", 
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* Machine id */
-    { "arch", ARCH, 
-        NVRAM_PROTECTED,
-        0 
-    },        /* Arch */
-    { "license_invalid", "",
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* License status */
-    { "bootcount", "",
-        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
-        0 
-    },        /* License bootcount */
-/* Added by Abocom */
-    { "weather_rule", "1^UKXX1428^c", 
-        NVRAM_NONE,
-        0 
-    },        /* enable^city^degree */
-    { "wl_easy_mode_rule", "0", 
-        NVRAM_NONE,
-        0 
-    },        /* mode 0->2.4g  1->5g */
-    { "FirstConfig", "1", 
-        NVRAM_NONE,
-        0 
-    },        /* FirstConfig for web server */
-     { "zyfw_fw_file", "", 
-        NVRAM_NONE,
-        0 
-    },        /* file name for online FW upgrade */
-    { "zyfw_size", "", 
-        NVRAM_NONE,
-        0 
-    },        /* file size for online FW upgrade */
-    { "WISP_Channel", "0", 
-        NVRAM_NONE,
-        0 
-    },        /* Save WISP's wireless Channel */	
-    { "WISP1_Channel", "0", 
-        NVRAM_NONE,
-        0 
-    },        /* Save WISP's wireless 5g Channel */	
-    { "AP_Channel", "0", 
-        NVRAM_NONE,
-        0 
-    },		/* Save AP's wireless Channel */
-    { "AP1_Channel", "36", 
-        NVRAM_NONE,
-        0 
-    },		/* Save AP's wireless Channel */
-    { "wl_wisp_mode_rule", "wisp^ap", 
-        NVRAM_NONE,
-        0 
-    }, /*wifi 2.4g as wisp,wifi 5g as 
-       ap mode when choose wisp mode*/
-    /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
-    { 0, 0, 0 ,0 }
-};
-
-#endif /*_NVRAM_EZPACKET_H */
Index: src/include/nvram_fw.h
===================================================================
--- src/include/nvram_fw.h	(revision 7302)
+++ src/include/nvram_fw.h	(revision 7299)
@@ -1,39 +0,0 @@
-#ifndef _NVRAM_FW_H_
-#define _NVRAM_FW_H_
-
-typedef enum
-{
-    NVRAM_FW_0_0_0 = 0,
-    NVRAM_FW_1_6_5,
-    NVRAM_FW_1_6_6,
-    NVRAM_FW_1_6_7,
-    NVRAM_FW_1_7_0,
-    NVRAM_FW_1_7_1,
-    NVRAM_FW_1_7_2,
-    NVRAM_FW_1_7_3,
-    NVRAM_FW_1_7_4,
-    NVRAM_FW_1_7_5,
-    NVRAM_FW_1_7_6,
-    NVRAM_FW_1_7_7,
-    NVRAM_FW_1_7_8,
-    NVRAM_FW_1_7_9,
-    NVRAM_FW_1_7_10,
-    NVRAM_FW_1_7_11,
-    NVRAM_FW_2_0_0,
-    NVRAM_FW_2_0_1,
-    NVRAM_FW_2_0_2,
-    NVRAM_FW_2_0_3,
-    NVRAM_FW_2_0_4,
-    NVRAM_FW_2_0_5,
-} nvram_fw_version;
-
-struct nvram_fw_tuple {
-    char *fw_str;
-    nvram_fw_version fw_version;
-    int (*fw_upgrade_func)(void); 
-    int (*fw_downgrade_func)(void); 
-};
-
-
-#endif /* _NVRAM_FW_H_ */
-
Index: src/include/ezpcom-lib.h
===================================================================
--- src/include/ezpcom-lib.h	(revision 7302)
+++ src/include/ezpcom-lib.h	(revision 7299)
@@ -1,570 +0,0 @@
-#ifndef _EZPCOM_LIB_H
-#define _EZPCOM_LIB_H
-
-/* 
- * THE VENDOR TABLE 
- */
-
-#define EZP_COM_VENDOR_MAP(X)                                   \
-    X(AUTO, "Auto", 0x3789, 1)                                  \
-    X(HUAWEI, "Huawei", 0x12d1, 1)                              \
-    X(HUAWEI2, "Huawei (Alternative)", 0x1033, 1)               \
-    X(ZTE, "ZTE", 0x19d2, 1)                                    \
-    X(EMPTY, "", 0x0, 0)                                        \
-
-
-/* 
- * THE PRODUCT TABLE TO A SPECIFIC VENDOR
- * (1) Device Name
- * (2) Default Device, Target Vendor, Target Device, Target Class, MessageEndpoint, * ResponseEndpoint,
- * (3) DetachStorageOnly, Mode, Interface, 
- * (4) Device Num, Data, Ctrl,
- * (5) MessageContent, Shown
- *
- * XXX: 
- * I. For the multiple-message devices, the entries (other than the last 
- * message) should be set with 0xF0. The last entries should be set with 0x00.
- * 
- * II. Also, in the first message, flag should be set. Others should be set
- * 0.
- *
- * III. For the express card, the "Default Device" is set as 0xFFFF.
- * 
- */
-
-/* Empty definition. */
-#define EZP_COM_MAP_EMPTY(X)                        \
-    X("",                                           \
-            0x0, EMPTY, 0x0, 0x0, 0x0, -1,          \
-            0, 0, 0x0,                              \
-            0, 0, 0, "",                            \
-            NULL, 0)                                \
-
-
-#define EZP_COM_MAP_AUTO(X)                       \
-    X("Auto",                                       \
-            0x5233, EMPTY, 0x0, 0x0, 0x0, -1,       \
-            0, 0, 0x0,                              \
-            0, 0, 0, "",                         \
-            NULL, 1 )                               \
-    X("",                                           \
-            0x0, EMPTY, 0x0, 0x0, 0x0, -1,          \
-            0, 0, 0x0,                              \
-            0, 0, 0, "",                            \
-            NULL, 0)                                \
-
-/* We intentionally use 0x as TargetProduct. */
-#define EZP_COM_MAP_HUAWEI(X)                       \
-    X("Generic",                                  \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1 )                               \
-    X("E156G",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E160E",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E160G",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E161",       \
-            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
-            0, 0, 0x0,                              \
-            3, 0, 0, "ttyUSB",                         \
-            "55534243000000000000000000000011060000000000000000000000000000", 1) \
-    X("E169",                                    \
-            0x1001, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            3, 0, 0, "ttyUSB",                         \
-            NULL, 1 )                               \
-    X("E1692",                                    \
-            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
-            0, 0, 0x0,                              \
-            3, 0, 2, "ttyUSB",                         \
-            "55534243000000000000000000000011060000000000000000000000000000", 1) \
-    X("E169U",                                    \
-            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
-            0, 0, 0x0,                              \
-            3, 0, 2, "ttyUSB",                         \
-            "55534243000000000000000000000011060000000000000000000000000000", 1) \
-    X("E170",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E172",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E1750",                                    \
-            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
-            0, 0, 0x0,                              \
-            3, 0, 2, "ttyUSB",                         \
-            "55534243000000000000000000000011060000000000000000000000000000", 1) \
-    X("E180",       \
-            0x1414, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E219",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E220",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E226",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E270",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E800",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("E1762",       \
-            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("EC1260",       \
-            0x140b, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("ET128",       \
-            0x1da1, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            3, 2, 0, "ttyACM",                         \
-            NULL, 1) \
-    X("K1550",       \
-            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
-            0, 0, 0x0,                              \
-            3, 0, 0, "ttyUSB",                         \
-            "55534243000000000000000000000011060000000000000000000000000000", 1) \
-    X("K3715",       \
-            0x1001, HUAWEI, 0x0, 0x0, 0x0, -1,       \
-            1, 1, 0x0,                              \
-            3, 0, 0, "ttyUSB",                         \
-            NULL, 1) \
-    X("E870",                                       \
-            0xFFFF, HUAWEI, 0x1003, 0x0, 0x0, -1,       \
-            0, 0, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                \
-    X("",                                           \
-            0x0, EMPTY, 0x0, 0x0, 0x0, -1,          \
-            0, 0, 0x0,                              \
-            0, 0, 0, "",                            \
-            NULL, 0)                                \
-
-
-#define EZP_COM_MAP_HUAWEI2(X)                      \
-    X("E630",                                       \
-            0x0035, HUAWEI, 0x1003, 0x0, 0x0, -1,   \
-            1, 0, 0x0,                              \
-            2, 0, 1, "ttyUSB",                         \
-            NULL, 1)                                  \
-    X("",        \
-            0x0, EMPTY, 0x0, 0x0, 0x0, -1,  \
-            0, 0, 0x0,                              \
-            0, 0, 0, "",                            \
-            NULL, 0) \
-
-
-/*
- * In Australia, pre-paid MF626 is buggy! When the data is on, any access to
- * the control tty causes the modem panic! So in "Generic" and
- * "MF628+/MF626/MF636/MF637" both have the same data and tty nums.
- */ 
-/*
- * In South Africa, K3565-Z does the following steps:
- * # Standard SCSI eject
- * #usb_modeswitch -v ${VID} -p ${PID} -M
- * 5553424312345678000000000000061b000000020000000000000000000000 -R 1
- * # Storage passthrough
- * usb_modeswitch -v ${VID} -p ${PID} -M
- * 55534243123456782400000080000C85000000240000000000000000000000 -R 1
- * NB: It seems some ZTE devices require USB reset. e.g. ZTE MF628 from TWN
- * Mobile. We leverage 0x80 at Mode to indicate reset.
- */
-
-#define EZP_COM_MAP_ZTE(X)                      \
-    X("Generic",                                       \
-            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 2, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("MF622",                                       \
-            0x2000, ZTE, 0x0002, 0x0, 0x04, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            "55534243f8f993882000000080000a85010101180101010101000000000000", 1)\
-    X("MF622 (version 2)",                                       \
-            0x2000, ZTE, 0x0001, 0x0, 0x0, -1,   \
-            1, 0, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            NULL, 1) \
-    X("MF628",                                       \
-            0x2000, ZTE, 0x0015, 0x0, 0x08, -1,   \
-            0, 0x80, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            "5553424312345678000000000000061b000000030000000000000000000000", 1) \
-    X("MF628+",                                       \
-            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 2, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("MF626",                                       \
-            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 2, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("MF633",                                       \
-            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 2, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("MF636",                                       \
-            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 2, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("MF637",                                       \
-            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 2, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("MF638",                                       \
-            0x2000, ZTE, 0x0037, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("MU351",                                       \
-            0x0003, ZTE, 0x0037, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("K3565-Z",                                       \
-            0x2000, ZTE, 0x0063, 0x0, 0x01, -1,   \
-            0, 0, 0x0,                              \
-            5, 3, 1, "ttyUSB",                         \
-            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
-    X("ONDA MT503HS",                                       \
-            0x2000, ZTE, 0x0002, 0x0, 0x08, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            "55534243b0c8dc812000000080000a85010101180101010101000000000000", 1) \
-    X("ONDA MT505UP",                                       \
-            0x2000, ZTE, 0x0002, 0x0, 0x03, -1,   \
-            0, 0, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            "55534243123456780000010080000a28000000001c00002000000000000000", 1) \
-    X("ONDA MT525UP",                                       \
-            0x2000, ZTE, 0x0002, 0x0, 0x0, -1,   \
-            0, 4, 0x0,                              \
-            3, 2, 1, "ttyUSB",                         \
-            NULL, 1) \
-    X("",        \
-            0x0, EMPTY, 0x0, 0x0, 0x0, -1,  \
-            0, 0, 0x0,                              \
-            0, 0, 0, "",                            \
-            NULL, 0) \
-
-
-
-#define EZP_COM_VENDOR_NAME_CONVERTER(VNAME,NAME,VID,SHOWN) EZP_COM_VID_##VNAME,
-typedef enum {
-    EZP_COM_VENDOR_MAP(EZP_COM_VENDOR_NAME_CONVERTER)
-} ezp_com_vendor_name_type;
-
-struct ezp_com_vendor_map_entry_type
-{
-    ezp_com_vendor_name_type vn;
-    char *desc;
-    int DefaultVendor;
-    char shown;
-};
-
-struct ezp_com_map_entry_type
-{
-    char *desc;
-    int DefaultProduct;
-    ezp_com_vendor_name_type TargetVendorType;
-    int TargetProduct;
-    int TargetClass;
-    int MessageEndpoint;
-    int ResponseEndpoint;
-    char DetachStorageOnly;
-    /* 
-     * Huawei(1), Sierra(2), Sony(3), Bandluxe(4), MessageNext(0xF0)
-     */
-    char Mode; 
-    int Interface;
-    /* XXX: I intentionally ignore Configuration, AltSetting. */
-    int DeviceNum; 
-    int DataTTY; 
-    int CtrlTTY;
-    char *DevName;
-    char *MessageContent;
-    /* show in GUI or not */
-    char Flag;
-};
-
-#define EZP_COM_VENDOR_MAP_CONVERTER(VNAME,NAME,VID,SHOWN) \
-    {EZP_COM_VID_##VNAME, NAME, VID, SHOWN},
-
-static struct ezp_com_vendor_map_entry_type ezp_com_vendor_map[] = {
-    EZP_COM_VENDOR_MAP(EZP_COM_VENDOR_MAP_CONVERTER)
-};
-
-#define EZP_COM_MAP_CONVERTER(NAME,PID,TVNAME,TPID,TCLS,EP,REP,DT,MODE,INTF,DNUM,DTTY,CTTY,DEVNMAE,MSG,FLAG) \
-   {NAME, PID, EZP_COM_VID_##TVNAME, TPID, TCLS, EP, REP, DT, MODE, INTF, DNUM, DTTY, CTTY, DEVNMAE, MSG, FLAG},
-
-
-#define EZP_COM_MAP_FOR_EACH_VENDOR_CONVERTER(VNAME,NAME,VID,SHOWN) \
-static struct ezp_com_map_entry_type ezp_com_map_##VNAME[] = { \
-    EZP_COM_MAP_##VNAME(EZP_COM_MAP_CONVERTER) \
-}; 
-
-/* Declare tables to each vendor. */
-EZP_COM_VENDOR_MAP(EZP_COM_MAP_FOR_EACH_VENDOR_CONVERTER)
-
-
-#define EZP_COM_POINTER_MAP_CONVERTER(VNAME,NAME,VID,SHOWN) &ezp_com_map_##VNAME[0],
-
-
-static struct ezp_com_map_entry_type *ezp_com_pointer_map[] = {
-    EZP_COM_VENDOR_MAP(EZP_COM_POINTER_MAP_CONVERTER)
-};
-
-/* ------------------------------------ */
-/* For location & ISP information */
-#define EZP_COM_LOCATION_MAP(X)                         \
-    X(TAIWAN, "Taiwan", 1)                              \
-    X(AUSTRALIA, "Australia", 1)                        \
-    X(CANADA, "Canada", 1)                                    \
-    X(CHINA, "China", 1)                                \
-    X(HONGKONG, "Hongkong", 1)                          \
-    X(INDIA, "India", 1)                                    \
-    X(MEXICO, "Mexico", 1)                              \
-    X(NETHERLANDS, "Netherland", 1)                     \
-    X(NORWAY, "Norway", 1)                              \
-    X(PHILIPPINES, "Philippines", 1)                    \
-    X(RUSSIA, "Russia", 1)                              \
-    X(SOUTH_AFRICA, "South Africa", 1)                  \
-    X(USA, "USA", 1)                                    \
-    X(EMPTY, "", 0)
-
-/*
-    X(AUSTRIA, "Austria", 1)                            \
-    X(BELGIUM, "Belgium", 1)                            \
-    X(BRASIL, "Brasil", 1)                              \
-    X(CANADA, "Canada", 1)                              \
-    X(CHILE, "Chile", 1)                                \
-    X(CROATIA, "Croatia", 1)                            \
-    X(CZECH, "Czech", 1)                                \
-    X(DENMARK, "Denmark", 1)                            \
-    X(EGYPT, "Egypt", 1)                                \
-    X(ESTONIA, "Estonia", 1)                            \
-    X(FINLAND, "Finland", 1)                            \
-    X(FRANCE, "France", 1)                              \
-    X(GERMANY, "Germany", 1)                            \
-    X(GREECE, "Greece", 1)                              \
-    X(HUNGARY, "Hungary", 1)                            \
-    X(INDIA, "India", 1)                                \
-    X(INDONESIA, "Indonesia", 1)                        \
-    X(IRELAND, "Ireland", 1)                            \
-    X(ITALY, "Italy", 1)                                \
-    X(JAPAN, "Japan", 1)                                \
-    X(LITHUANIA, "Lithuania", 1)                        \
-    X(LUXEMBOURG, "Luxembourg", 1)                      \
-    X(MACEDONIAN, "Macedonian", 1)                      \
-    X(MALAYSIA, "Malaysia", 1)                          \
-    X(MEXICO, "Mexico", 1)                              \
-    X(NETHERLANDS, "Netherlands", 1)                    \
-    X(NEW_ZEALAND, "New Zealand", 1)                    \
-    X(POLAND, "Poland", 1)                              \
-*/
-
-
-/* 
- * THE ISP TABLE TO A SPECIFIC LOCATION
- * (1) APN
- * (2) PIN
- * (3) User Name
- * (4) Passwd
- * (5) Dialup String
- *
- */
-
-/* Empty definition. */
-#define EZP_COM_ISP_MAP_EMPTY(X)                                            \
-    X("", "", "", "", "", "", "", 0)
-
-#define EZP_COM_ISP_MAP_TAIWAN(X)                                           \
-    X("Chunghwa Telecom", "internet", "", "chap", "", "", "*99#", 1 )       \
-    X("Far EasTone (internet)", "internet", "", "chap", "", "", "*99#", 1 ) \
-    X("Far EasTone (fetims)", "fetims", "", "chap", "", "", "*99#", 1 )     \
-    X("Taiwan Cellular", "internet", "", "chap", "", "", "*99#", 1 )        \
-    X("Vibo", "internet", "", "chap", "", "", "*99#", 1 )                   \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-
-#define EZP_COM_ISP_MAP_CHINA(X)                                            \
-    X("China Telecom", "", "", "chap", "", "", "#777", 1 )              \
-    X("China Mobile", "cmnet", "", "chap", "", "", "*99#", 1 )              \
-    X("China Unicom", "", "", "chap", "", "", "*99#", 1 )                   \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-
-#define EZP_COM_ISP_MAP_HONGKONG(X)                                         \
-    X("3 HK", "ipc.three.com.hk", "", "chap", "", "", "*99#", 1 )           \
-    X("CSL", "internet", "", "chap", "", "", "*99#", 1 )                    \
-    X("New World", "ineternet", "", "chap", "", "", "*99#", 1 )             \
-    X("PCCW", "pccw", "", "chap", "", "", "*99#", 1 )                       \
-    X("People", "internet", "", "chap", "", "", "*99#", 1 )                 \
-    X("SmarTone", "internet", "", "chap", "", "", "*99#", 1 )               \
-    X("Sunday", "internet", "", "chap", "", "", "*99#", 1 )                 \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_INDIA(X)                                     \
-    X("TATA", "TATA", "", "chap", "internet", "internet", "#777", 1 )             \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_MEXICO(X)                                           \
-    X("Movistar", "internet.movistar.mx", "", "chap", "", "", "*99#", 1 )   \
-    X("Telcel", "internet.itelcel.com", "", "chap", "", "", "*99#", 1 )     \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_NETHERLANDS(X)                                      \
-    X("T-Mobile", "internet", "", "chap", "", "", "*99#", 1 )               \
-    X("KPN", "internet", "", "chap", "", "", "*99#", 1 )                    \
-    X("Telfort", "internet", "", "chap", "", "", "*99#", 1 )                \
-    X("Vodafone", "internet", "", "chap", "", "", "*99#", 1 )               \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_NORWAY(X)                                           \
-    X("Telenor Mobil", "Telenor", "", "chap", "", "", "*99***1#", 1 )       \
-    X("Netcom Mobil", "Netcom", "", "chap", "", "", "*99***1#", 1 )         \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-
-#define EZP_COM_ISP_MAP_PHILIPPINES(X)                                      \
-    X("Globe", "www.globe.com.ph", "", "chap", "globe", "globe", "*99#", 1 ) \
-    X("Smart", "internet", "", "chap", "", "", "*99#", 1 )                  \
-    X("Sun Cellula", "minternet", "", "chap", "", "", "*99#", 1 )           \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_RUSSIA(X)                                           \
-    X("BeeLine", "internet.beeline.ru", "", "chap", "beeline", "beeline", "*99#", 1 )  \
-    X("Megafon (NWGSM)", "internet.nw", "", "chap", "", "", "*99#", 1 )     \
-    X("MTS", "internet.mts.ru", "", "chap", "mts", "mts", "*99#", 1 )       \
-    X("PrimTel", "internet.primtel.ru", "", "chap", "", "", "*99#", 1 )     \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_AUSTRALIA(X)                                        \
-    X("iburst", "internet", "", "chap", "", "", "*99#", 1 )                 \
-    X("Bigpond", "telstra.bigpond", "", "chap", "", "", "*99#", 1 )         \
-    X("Dodo", "dodolns1", "", "chap", "", "", "*99#", 1 )                   \
-    X("Exetel", "exetel1", "", "chap", "", "", "*99#", 1 )                  \
-    X("Internode", "splns333a1", "", "chap", "", "", "*99#", 1 )            \
-    X("Optus", "internet", "", "chap", "", "", "*99#", 1 )                  \
-    X("Telstra", "telstra.internet", "", "chap", "", "", "*99#", 1 )        \
-    X("Three", "3netaccess", "", "chap", "", "", "*99#", 1 )                \
-    X("Three Prepaid", "3services", "", "chap", "", "", "*99#", 1 )         \
-    X("TPG", "internet", "", "chap", "", "", "*99#", 1 )                    \
-    X("Virgin", "virginbroadband", "", "pap", "", "", "*99***1#", 1)        \
-    X("Vodafone", "vfinternet.au", "", "chap", "", "", "*99#", 1 )          \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_SOUTH_AFRICA(X)                                     \
-    X("MTN", "", "", "chap", "", "", "*99#", 1 )                            \
-    X("Vodacom", "internet", "", "chap", "", "", "*99***16#", 1 )           \
-    X("Cell-C", "internet", "", "chap", "Cellcis", "Cellcis", "*99***16#", 1 ) \
-    X("Neotel", "", "", "chap", "", "", "#777", 1 ) \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_CANADA(X)                                     \
-    X("Rogers", "internet.com", "", "chap", "", "", "*99#", 1 )             \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_ISP_MAP_USA(X)                                              \
-    X("AT&T", "proxy", "", "", "chap", "", "*99#", 1 )                      \
-    X("Bell Mobility", "", "", "chap", "", "", "*99#", 1 )                  \
-    X("Cellular One", "cellular1wap", "", "chap", "", "", "*99#", 1 )       \
-    X("Cincinnati Bell", "wap.gocbw.com", "", "chap", "cbw", "", "*99#", 1 ) \
-    X("T-Mobile(T-Zone)", "wap.voicestream.com", "", "chap", "", "", "*99#", 1 ) \
-    X("T-Mobile(internet)", "internet2.voicestream.com","","chap", "","","*99#",1)  \
-    X("Verizon", "", "", "chap", "", "","*99#", 1)                          \
-    X("", "", "", "", "", "", "", 0)                                        \
-
-#define EZP_COM_LOCATION_NAME_CONVERTER(LNAME,NAME,SHOWN) EZP_COM_LID_##LNAME,
-typedef enum {
-    EZP_COM_LOCATION_MAP(EZP_COM_LOCATION_NAME_CONVERTER)
-} ezp_com_location_name_type;
-
-struct ezp_com_location_map_entry_type
-{
-    ezp_com_location_name_type ln;
-    char *desc;
-    char shown;
-};
-
-struct ezp_com_isp_map_entry_type
-{
-    char *desc;
-    char *apn;
-    char *pin;
-    char *auth;
-    char *user_name;
-    char *passwd;
-    char *dialup_str;
-    char shown;
-};
-
-#define EZP_COM_LOCATION_MAP_CONVERTER(LNAME,NAME,SHOWN) \
-    {EZP_COM_LID_##LNAME, NAME, SHOWN},
-
-static struct ezp_com_location_map_entry_type ezp_com_location_map[] = {
-    EZP_COM_LOCATION_MAP(EZP_COM_LOCATION_MAP_CONVERTER)
-};
-
-#define EZP_COM_ISP_MAP_CONVERTER(NAME,APN,PIN,AUTH,USER,PW,DIALUP,SHOWN) \
-   {NAME, APN, PIN, AUTH, USER, PW, DIALUP, SHOWN},
-
-#define EZP_COM_ISP_MAP_FOR_EACH_LOCATION_CONVERTER(LNAME,NAME,SHOWN) \
-static struct ezp_com_isp_map_entry_type ezp_com_isp_map_##LNAME[] = { \
-    EZP_COM_ISP_MAP_##LNAME(EZP_COM_ISP_MAP_CONVERTER) \
-}; 
-
-/* Declare tables to each location. */
-EZP_COM_LOCATION_MAP(EZP_COM_ISP_MAP_FOR_EACH_LOCATION_CONVERTER)
-
-
-#define EZP_COM_ISP_POINTER_MAP_CONVERTER(LNAME,NAME,SHOWN) &ezp_com_isp_map_##LNAME[0],
-
-
-static struct ezp_com_isp_map_entry_type *ezp_com_isp_map[] = {
-    EZP_COM_LOCATION_MAP(EZP_COM_ISP_POINTER_MAP_CONVERTER)
-};
-
-#endif
Index: src/include/ezp-lib.h
===================================================================
--- src/include/ezp-lib.h	(revision 7302)
+++ src/include/ezp-lib.h	(revision 7299)
@@ -1,76 +0,0 @@
-#ifndef _EZP_LIB_H
-#define _EZP_LIB_H
-
-#define EZPLIB_BUF_LEN          8192
-
-#define EZPLIB_USE_CLI          0
-#define EZPLIB_USE_WEB          1
-
-#define EZPLIB_INVALID          -1
-#define EZPLIB_VAL_TRUNC        -2
-#define EZPLIB_NO_RULE_SET      -3
-#define EZPLIB_NO_RULE          -4
-#define EZPLIB_NO_ATTRIBUTE     -5
-#define EZPLIB_IDX_OUT_RANGE    -6
-
-#define RULE_SEP "|"
-#define ATTR_SEP "^"
-
-/**
- * \brief Get a specified rule set from nvram, parse it by the RULE_SEP 
- * character, and return the nth rule.
- */
-int ezplib_get_rule(char *rule_set, int nth, char *buf, int bsize);
-
-/**
- * \brief Get a specified specified rule set from nvram, parse it by 
- * RULE_SEP character, and return the subrule with the attribute position in
- * between start and end.
- */
-int ezplib_get_subrule(char *rule_set, int nth, int start, int end,
-        char *buf, int bsize);
-
-/**
- * \brief Get a specified attribute of the given rule from the rule set queried 
- * from nvram. The rules are separated by blank character and the attributes
- * in a rule are separated by '-' character.
- */
-int ezplib_get_attr_val(char *rule_set, int nth, char *type, char *buf,
-                        int bsize, int use);
-
-/**
- * \brief Replace the nth rule in the given rule-name as the specific rule.
- */
-int ezplib_replace_rule(char *rule_set, int nth, char *new_rule);
-
-/**
- * \brief Replace the mth attribute of the nth rule in the given rule-name as 
- * the specific rule.
- */
-int ezplib_replace_attr(char *rule_set, int nth, char *attr, char *new_attr);
-
-/**
- * \brief Append a new rule into the given rule-name.
- */
-int ezplib_append_rule(char *rule_set, char *new_rule);
-
-/**
- * \brief Prepend a new rule into the given rule-name.
- */
-int ezplib_prepend_rule(char *rule_set, char *new_rule);
-
-/**
- * \brief Add a new rule in the given rule-name as the specific rule.
- */
-int ezplib_add_rule(char *rule_set, int nth, char *new_rule);
-
-/**
- * \brief Delete nth rule in the given rule-name.
- */
-int ezplib_delete_rule(char *rule_set, int nth);
-
-/**
- * \brief Get the number of rules in the given rule-name.
- */
-int ezplib_get_rule_num(char *rule_set);
-#endif
Index: src/include/nvram_ezpacket-rt3883.h
===================================================================
--- src/include/nvram_ezpacket-rt3883.h	(revision 7302)
+++ src/include/nvram_ezpacket-rt3883.h	(revision 7299)
@@ -1,272 +0,0 @@
-#ifdef CONFIG_EZP_ARCH_RT3883
-#define ARCH "RT3883"
-
-#ifndef WL_NUM
-#define WL_NUM 1
-#endif
-
-#ifndef WL_VIRTUAL_NUM
-#define WL_VIRTUAL_NUM 4
-#endif
-
-#ifndef WL_WDS_NUM
-#define WL_WDS_NUM 4
-#endif
-
-#ifndef WL_APCLI_NUM
-#define WL_APCLI_NUM 1
-#endif
-
-#if ( WL_NUM == 1 )
-#define WL_BASIC_RULE "1^9^100^6^1"
-#define WL_AP_BASIC_RULE "1^9^100^6^1"
-#define WL5G_BASIC_RULE "1^8^100^0^1"
-#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE*/
-#define WL0_IFNAME_RULE "rai0"
-#define WL1_IFNAME_RULE "ra0"
-#elif ( WL_VIRTUAL_NUM == 2 )
-#define WL0_IFNAME_RULE "rai0|rai1"
-#define WL1_IFNAME_RULE "ra0|ra1"
-#elif ( WL_VIRTUAL_NUM == 4 )
-#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
-#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
-#endif /* WL0_IFNAME_RULE*/
-#define WL0_RULE_NUM WL_VIRTUAL_NUM
-#define WL0_RULE_MAX WL_VIRTUAL_NUM
-#if (WL0_RULE_NUM == 2)
-#warning "WL0_RULE_NUM 2"
-#warning "WL0_RULE_MAX 2"
-#elif (WL0_RULE_NUM == 4)
-#warning "WL0_RULE_NUM 4"
-#warning "WL0_RULE_MAX 4"
-#endif
-#define WDS_RULE_MAX WL_WDS_NUM
-#define APCLI_RULE_MAX WL_APCLI_NUM
-#elif ( WL_NUM == 2 )
-#define WL_BASIC_RULE "1^9^100^6^1|1^9^100^6^1"
-#define WL_AP_BASIC_RULE "1^9^100^6^1|1^9^100^6^1"
-#define WL5G_BASIC_RULE "1^8^100^6^1|1^8^100^6^1"
-#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE/WL1_IFNAME_RULE*/
-#define WL0_IFNAME_RULE "rai0"
-#define WL1_IFNAME_RULE "ra0"
-#elif ( WL_VIRTUAL_NUM == 2 )
-#define WL0_IFNAME_RULE "rai0|rai2"
-#define WL1_IFNAME_RULE "ra0|ra2"
-#elif ( WL_VIRTUAL_NUM == 4 )
-#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
-#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
-#endif /* WL0_IFNAME_RULE/WL1_RULE_NUM */
-#define WL0_RULE_NUM WL_VIRTUAL_NUM
-#define WL0_RULE_MAX WL_VIRTUAL_NUM
-#define WL1_RULE_NUM WL_VIRTUAL_NUM
-#define WL1_RULE_MAX WL_VIRTUAL_NUM
-#define WDS_RULE_MAX WL_WDS_NUM
-#define APCLI_RULE_MAX WL_APCLI_NUM
-#elif (WL_NUM == 0 )
-#else
-#error "Undefined amount of WLAN interfaces"
-#endif
-
-#if ( WAN_NUM >= 1 )
-
-/* 3G/4G WAN default interface should be ppp0. */
-#if defined(EZP_PROD_CAT_M)
-#define WAN0_IFNAME "vlan2"
-#else
-#define WAN0_IFNAME "vlan2"
-#endif
-
-#define WAN0_IFNAMES ""
-#define WAN0_HWNAME ""
-#define WAN0_DEVICE "vlan2"
-#define WAN0_PORTS "4"
-#if ( LAN_NUM >= 1 )
-    #define LAN0_IFNAME "br0"
-    #define LAN0_IFNAMES "vlan1 ra0 ra1 apcli0 apclii0"
-    #define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 rai0 rai1 apcli0 apclii0 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3"
-    #define LAN0_HWNAME ""
-    #define LAN0_DEVICE "vlan1"
-#endif
-#if (LAN_NUM >= 2)
-    #define LAN1_IFNAME "br2"
-    #define LAN1_DEVICE "br2"
-#endif
-
-#if (LAN_NUM == 1)
-    #if (WL_VIRTUAL_NUM == 2)
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 rai0 rai1 wds0 wds1 apcli0 apclii0^|WAN1^0^vlan2^"
-    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
-    #else
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
-    #endif
-    #define BR_RULE_NUM 2
-    #define BR_RULE_MAX 8
-#elif (LAN_NUM == 2)
-    #define BR_RULE_GUESTLAN "GuestLAN^0^ra1^"
-    #if (WL_VIRTUAL_NUM == 2)
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 rai0 rai1 wds0 wds1 apcli0 apclii0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
-    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0 ^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
-    #else
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
-    #endif
-    #define BR_RULE_NUM 3
-    #define BR_RULE_MAX 8
-#else
-    #if (WL_VIRTUAL_NUM == 2)
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 rai0 rai1 wds0 wds1 apcli0 apclii0^|WAN1^0^vlan2^"
-    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
-    #else
-        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
-    #endif
-    #define BR_RULE_NUM 2
-    #define BR_RULE_MAX 8
-#endif
-
-#define STATS_RULE "^1^60^vlan1 vlan2 ppp0 br0 ra0 rai0 usb0 eth0"
-#define VLAN_RULE_NUM 2
-#define VLAN_RULE_MAX 8
-#ifdef CONFIG_RAETH_RT3883_P5
-    #warning "P5 enabled, vlan set to 1111011"
-    /* Disable vlan, Sean@liteon, 2012-12-25-----> */
-    #define VLAN_RULE "LAN1^0^eth2^1^1111011^|WAN1^0^eth2^2^0000111^"
-    /* <-----Sean@liteon, 2012-12-25 */
-#else
-    #warning "P5 disabled, vlan set to 1111001"
-    /* Disable vlan, Sean@liteon, 2012-12-25-----> */
-    #define VLAN_RULE "LAN1^0^eth2^1^1111011^|WAN1^0^eth2^2^0000111^"
-    /* <-----Sean@liteon, 2012-12-25 */
-#endif /* CONFIG_RAETH_RT3883_P5 : support for GMAC port when using external giga switch. */
-#define VLANPORT_RULE_NUM 5
-#define VLANPORT_RULE_MAX 7
-#define VLANPORT_RULE "PORT1^0^1^0^011101|PORT2^1^1^0^011011|PORT3^2^1^0^010111|PORT4^3^1^0^001111|PORT5^4^2^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
-/* EZP: Old VLAN definition should be Obsolete! */
-#define LAN0_PORTS "0 1 2 3"
-/* WAN0 uses vlan2. XXX: No effect! */
-#define VLAN2_PORTS "4 5"
-/* LAN0 uses vlan1. XXX: No effect! */
-#define VLAN1_PORTS "0 1 2 3 5*"
-#define VLAN_HWNAME "eth2"
-
-#elif ( WAN_NUM == 2 ) 
-
-#define WAN0_IFNAME "vlan2"
-#define WAN0_IFNAMES ""
-#define WAN0_HWNAME ""
-#define WAN0_DEVICE "vlan2"
-#define WAN0_PORTS "4"
-
-/* 3G/4G 2nd WAN default interface should be ppp0. */
-#if defined(EZP_PROD_CAT_N)
-#define WAN1_IFNAME "ppp1"
-#else
-#define WAN1_IFNAME "vlan3"
-#endif
-
-#define WAN1_IFNAMES ""
-#define WAN1_HWNAME ""
-#define WAN1_DEVICE "vlan3"
-#define WAN1_PORTS "3"
-
-#define LAN0_IFNAME "br0"
-#define LAN0_IFNAMES "vlan1 ra0 ra1 rai0 rai1 apcli0 apclii0"
-#define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 rai0 rai1 apcli0 apclii0 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3"
-#define LAN0_HWNAME ""
-#define LAN0_DEVICE "vlan1"
-#define LAN0_PORTS "0 1 2"
-
-#define VLAN_RULE_NUM 3
-#define VLAN_RULE_MAX 16 
-#ifdef CONFIG_RAETH_RT3883_P5
-    #define VLAN_RULE "LAN1^1^eth2^1^1110011^|WAN1^1^eth2^2^0000111^|WAN2^1^eth2^3^0001011^"
-#else
-    #define VLAN_RULE "LAN1^1^eth2^1^1110001^|WAN1^1^eth2^2^0000101^|WAN2^1^eth2^3^0001001^"
-#endif /* CONFIG_RAETH_RT3883_P5 : support for GMAC port when using external giga switch. */
-#define VLANPORT_RULE_NUM 5
-#define VLANPORT_RULE_MAX 7
-#define VLANPORT_RULE "PORT1^0^1^0^001101|PORT2^1^1^0^001011|PORT3^2^1^0^000111|PORT4^3^2^0^000001|PORT5^4^3^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
-/* WAN0 uses vlan2. */
-#define VLAN2_PORTS "4 5"
-/* WAN1 uses vlan3. */
-#define VLAN3_PORTS "3 5"
-/* LAN0 uses vlan1. */
-#define VLAN1_PORTS "0 1 2 5"
-
-#define VLAN_HWNAME "eth2"
-
-#if (WL_VIRTUAL_NUM == 2)
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#else
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#endif
-
-#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
-#define BR_RULE_NUM 3
-#define BR_RULE_MAX 16
-
-#define STATS_RULE "^1^60^vlan3 vlan1 vlan2 ppp0 ppp1 br0 ra0 usb0 eth0 eth1"
-
-#else
-
-#error "Undefined amount of LAN/WAN interfaces"
-
-#endif
-
-#define HWNAT_RULE "1"
-
-#define BW_TYPE \
-        "A1M64K", "A1.5M640K", "A2M256K", "A2M512K", "A3M640K", "A4M1M", \
-        "A6M256K", "A6M640K", "A8M256K", "A8M640K", "A8M800K", "A10M2M", \
-        "A12M1M", "C1M128K", "C2M128K", "C2M384K", "C3M384K", "C6M640K", \
-        "C8M640K", "C10M1M", "V2M2M", "V4M4M", "V10M10M", "V25M25M", \
-        "V50M50M", "V100M100M","Custom"
-
-/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
-#define BW_DOWNLOAD_MAX "102400"
-#define BW_UPLOAD_MAX "102400"
-#define BW_DOWNLOAD_MIN "64"
-#define BW_UPLOAD_MIN "64"
-/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
-
-#define NVRAM_EZPACKET_DEFAULT_RT3883_LAN_NUM_1   \
-    /* WAN1 uses vlan1. */              \
-    { "vlan1ports", VLAN1_PORTS,        \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 port. */                \
-    { "vlan1hwname", VLAN_HWNAME,       \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 device hwname. */       \
-
-#define NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_1   \
-    /* WAN1 uses vlan2. */              \
-    { "vlan2ports", VLAN2_PORTS,        \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 port. */                \
-    { "vlan2hwname", VLAN_HWNAME,       \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN1 device hwname. */       \
-
-
-#define NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_2   \
-    /* WAN3 uses vlan3. */              \
-    { "vlan2ports", VLAN3_PORTS,        \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN3 port. */                \
-    { "vlan3hwname", VLAN_HWNAME,       \
-        NVRAM_NONE,                     \
-        0                               \
-    }, /* VLAN3 device hwname. */       \
-
-
-
-#endif /* CONFIG_EZP_ARCH_RT3883 */
-
Index: src/include/nvram.h
===================================================================
--- src/include/nvram.h	(revision 7302)
+++ src/include/nvram.h	(revision 7299)
@@ -1,87 +0,0 @@
-#ifndef _NVRAM_H
-#define _NVRAM_H 	1
-
-#include <linux/autoconf.h>
-
-#ifdef CONFIG_DUAL_IMAGE
-
-#define UBOOT_NVRAM	0
-#define RT2860_NVRAM    1
-#define RTDEV_NVRAM    	2
-#define CERT_NVRAM    	3
-#define WAPI_NVRAM    	4
-#else
-#define RT2860_NVRAM    0
-#define RTDEV_NVRAM    	1
-#define CERT_NVRAM    	2
-#define WAPI_NVRAM    	3
-#endif
-
-#define NV_DEV "/dev/nvram"
-#define RALINK_NVRAM_IOCTL_GET		0x01
-#define RALINK_NVRAM_IOCTL_GETALL	 0x02
-#define RALINK_NVRAM_IOCTL_SET		0x03
-#define RALINK_NVRAM_IOCTL_COMMIT	0x04
-#define RALINK_NVRAM_IOCTL_CLEAR	0x05
-
-typedef struct environment_s {
-	unsigned long crc;		//CRC32 over data bytes
-	char *data;
-} env_t;
-
-typedef struct cache_environment_s {
-	char *name;
-	char *value;
-} cache_t;
-
-#define MAX_CACHE_ENTRY 500
-typedef struct block_s {
-	char *name;
-	env_t env;			//env block
-	cache_t	cache[MAX_CACHE_ENTRY];	//env cache entry by entry
-	unsigned long flash_offset;
-	unsigned long flash_max_len;	//ENV_BLK_SIZE
-
-	char valid;
-	char dirty;
-} block_t;
-
-#define MAX_NAME_LEN 128
-#define MAX_VALUE_LEN (ENV_BLK_SIZE * 5)
-typedef struct nvram_ioctl_s {
-	int index;
-	int ret;
-	char *name;
-	char *value;
-} nvram_ioctl_t;
-
-
-#ifdef CONFIG_DUAL_IMAGE
-#define FLASH_BLOCK_NUM	5
-#else
-#define FLASH_BLOCK_NUM	1
-#endif
-
-
-int nvram_init_ralink(int index,int * nvram_fd);
-void nvram_close_ralink(int index);
-
-int	nvram_set_ralink(int index, char *name, char *value);
-char *nvram_get_ralink(int index, const char *name);
-int nvram_getall_ralink(int index, char *buf,int count);
-int nvram_bufset(int index, char *name, char *value);
-char *nvram_bufget(int index, char *name);
-void nvram_buflist(int index);
-int nvram_commit_ralink(int index);
-
-int nvram_clear(int index);
-int nvram_erase(int index);
-
-int getNvramNum(void);
-unsigned int getNvramOffset(int index);
-unsigned int getNvramBlockSize(int index);
-char *getNvramName(int index);
-unsigned int getNvramIndex(char *name);
-void toggleNvramDebug(void);
-
-#endif
Index: src/include/flash_api.h
===================================================================
--- src/include/flash_api.h	(revision 7302)
+++ src/include/flash_api.h	(revision 7299)
@@ -1,7 +0,0 @@
-#ifndef __FLASH_API
-#define __FLASH_API
-
-int flash_read(char *buf, off_t from, size_t len);
-int flash_write(char *buf, off_t to, size_t len);
-
-#endif
Index: src/include/shutils.h
===================================================================
--- src/include/shutils.h	(revision 0)
+++ src/include/shutils.h	(revision 7299)
@@ -0,0 +1,209 @@
+/*
+ * Shell-like utility functions
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: shutils.h 1517 2005-07-21 11:45:36Z nbd $
+ */
+
+#ifndef _shutils_h_
+#define _shutils_h_
+#include <string.h>
+
+#define EZP_LOG(fname, fmt, args...) ({ FILE *fp = fopen(fname, "a"); fprintf(fp, fmt, ## args); fflush(fp); fclose(fp); })
+/*
+ * Reads file and returns contents
+ * @param	fd	file descriptor
+ * @return	contents of file or NULL if an error occurred
+ */
+extern char * fd2str(int fd);
+
+/*
+ * Reads file and returns contents
+ * @param	path	path to file
+ * @return	contents of file or NULL if an error occurred
+ */
+extern char * file2str(const char *path);
+
+/* 
+ * Waits for a file descriptor to become available for reading or unblocked signal
+ * @param	fd	file descriptor
+ * @param	timeout	seconds to wait before timing out or 0 for no timeout
+ * @return	1 if descriptor changed status or 0 if timed out or -1 on error
+ */
+extern int waitfor(int fd, int timeout);
+
+/* 
+ * Concatenates NULL-terminated list of arguments into a single
+ * commmand and executes it
+ * @param	argv	argument list
+ * @param	path	NULL, ">output", or ">>output"
+ * @param	timeout	seconds to wait before timing out or 0 for no timeout
+ * @param	ppid	NULL to wait for child termination or pointer to pid
+ * @return	return value of executed command or errno
+ */
+extern int _eval(char *const argv[], char *path, int timeout, pid_t *ppid);
+
+/* 
+ * Concatenates NULL-terminated list of arguments into a single
+ * commmand and executes it
+ * @param	argv	argument list
+ * @return	stdout of executed command or NULL if an error occurred
+ */
+extern char * _backtick(char *const argv[]);
+
+/* 
+ * Kills process whose PID is stored in plaintext in pidfile
+ * @param	pidfile	PID file
+ * @return	0 on success and errno on failure
+ */
+extern int kill_pidfile(char *pidfile);
+
+/* 
+ * Check whether the process is running
+ * @param      program
+ * @return     1 on success and 0 on failure
+ */
+extern int process_is_running(char *program);
+
+/*
+ * fread() with automatic retry on syscall interrupt
+ * @param	ptr	location to store to
+ * @param	size	size of each element of data
+ * @param	nmemb	number of elements
+ * @param	stream	file stream
+ * @return	number of items successfully read
+ */
+extern int safe_fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
+
+/*
+ * fwrite() with automatic retry on syscall interrupt
+ * @param	ptr	location to read from
+ * @param	size	size of each element of data
+ * @param	nmemb	number of elements
+ * @param	stream	file stream
+ * @return	number of items successfully written
+ */
+extern int safe_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
+
+/*
+ * Convert Ethernet address string representation to binary data
+ * @param	a	string in xx:xx:xx:xx:xx:xx notation
+ * @param	e	binary data
+ * @return	TRUE if conversion was successful and FALSE otherwise
+ */
+extern int ether_atoe(const char *a, unsigned char *e);
+
+/*
+ * Convert Ethernet address binary data to string representation
+ * @param	e	binary data
+ * @param	a	string in xx:xx:xx:xx:xx:xx notation
+ * @return	a
+ */
+extern char * ether_etoa(const unsigned char *e, char *a);
+
+/*
+ * Concatenate two strings together into a caller supplied buffer
+ * @param	s1	first string
+ * @param	s2	second string
+ * @param	buf	buffer large enough to hold both strings
+ * @return	buf
+ */
+static inline char * strcat_r(const char *s1, const char *s2, char *buf)
+{
+	strcpy(buf, s1);
+	strcat(buf, s2);
+	return buf;
+}	
+
+/* Check for a blank character; that is, a space or a tab */
+#define isblank(c) ((c) == ' ' || (c) == '\t')
+
+/* Strip trailing CR/NL from string <s> */
+#define chomp(s) ({ \
+	char *c = (s) + strlen((s)) - 1; \
+	while ((c > (s)) && (*c == '\n' || *c == '\r' || *c == ' ')) \
+		*c-- = '\0'; \
+	s; \
+})
+
+/* Simple version of _backtick() */
+#define backtick(cmd, args...) ({ \
+	char *argv[] = { cmd, ## args, NULL }; \
+	_backtick(argv); \
+})
+
+/* Simple version of _eval() (no timeout and wait for child termination) */
+#define eval(cmd, args...) ({ \
+	char *argv[] = { cmd, ## args, NULL }; \
+	_eval(argv, ">/dev/console", 0, NULL); \
+})
+
+/* Copy each token in wordlist delimited by space into word */
+#define foreach(word, wordlist, next) \
+	for (next = &wordlist[strspn(wordlist, " ")], \
+	     strncpy(word, next, sizeof(word)), \
+	     word[strcspn(word, " ")] = '\0', \
+	     word[sizeof(word) - 1] = '\0', \
+	     next = strchr(next, ' '); \
+	     strlen(word); \
+	     next = next ? &next[strspn(next, " ")] : "", \
+	     strncpy(word, next, sizeof(word)), \
+	     word[strcspn(word, " ")] = '\0', \
+	     word[sizeof(word) - 1] = '\0', \
+	     next = strchr(next, ' '))
+
+/* Return NUL instead of NULL if undefined */
+#define safe_getenv(s) (getenv(s) ? : "")
+
+/* Print directly to the console */
+#define cprintf(fmt, args...) do { \
+	FILE *fp = fopen("/dev/console", "w"); \
+	if (fp) { \
+		fprintf(fp, fmt, ## args); \
+		fclose(fp); \
+	} \
+} while (0)
+
+/* Debug print */
+#ifdef DEBUG
+#define dprintf(fmt, args...) cprintf("%s: " fmt, __FUNCTION__, ## args)
+#else
+#define dprintf(fmt, args...)
+#endif
+
+#ifdef vxworks
+
+#include <inetLib.h>
+#define inet_aton(a, n) ((inet_aton((a), (n)) == ERROR) ? 0 : 1)
+#define inet_ntoa(n) ({ char a[INET_ADDR_LEN]; inet_ntoa_b ((n), a); a; })
+
+#include <typedefs.h>
+#include <bcmutils.h>
+#define ether_atoe(a, e) bcm_ether_atoe((a), (e))
+#define ether_etoa(e, a) bcm_ether_ntoa((e), (a))
+
+/* These declarations are not available where you would expect them */
+extern int vsnprintf (char *, size_t, const char *, va_list);
+extern int snprintf(char *str, size_t count, const char *fmt, ...);
+extern char *strdup(const char *);
+extern char *strsep(char **stringp, char *delim);
+extern int strcasecmp(const char *s1, const char *s2); 
+extern int strncasecmp(const char *s1, const char *s2, size_t n); 
+
+/* Neither are socket() and connect() */
+#include <sockLib.h>
+
+#ifdef DEBUG
+#undef dprintf
+#define dprintf printf
+#endif
+#endif
+
+#endif /* _shutils_h_ */

Property changes on: src/include/shutils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/include/bcmutils.h
===================================================================
--- src/include/bcmutils.h	(revision 0)
+++ src/include/bcmutils.h	(revision 7299)
@@ -0,0 +1,157 @@
+/*
+ * Misc useful os-independent macros and functions.
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id: bcmutils.h 1517 2005-07-21 11:45:36Z nbd $
+ */
+
+#ifndef	_bcmutils_h_
+#define	_bcmutils_h_
+
+#ifndef MIN
+#define	MIN(a, b)		(((a)<(b))?(a):(b))
+#endif
+
+#ifndef MAX
+#define	MAX(a, b)		(((a)>(b))?(a):(b))
+#endif
+
+#define CEIL(x, y)		(((x) + ((y)-1)) / (y))
+#define	ROUNDUP(x, y)		((((ulong)(x)+((y)-1))/(y))*(y))
+#define	ISALIGNED(a, x)		(((uint)(a) & ((x)-1)) == 0)
+#define	ISPOWEROF2(x)		((((x)-1)&(x))==0)
+#define	OFFSETOF(type, member)	((uint) &((type *)0)->member)
+#define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
+
+/* bit map related macros */
+#ifndef setbit
+#define	NBBY	8	/* 8 bits per byte */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif
+
+#define	NBITS(type)	(sizeof (type) * 8)
+
+#define _BCM_U	0x01	/* upper */
+#define _BCM_L	0x02	/* lower */
+#define _BCM_D	0x04	/* digit */
+#define _BCM_C	0x08	/* cntrl */
+#define _BCM_P	0x10	/* punct */
+#define _BCM_S	0x20	/* white space (space/lf/tab) */
+#define _BCM_X	0x40	/* hex digit */
+#define _BCM_SP	0x80	/* hard space (0x20) */
+
+extern unsigned char bcm_ctype[];
+#define bcm_ismask(x) (bcm_ctype[(int)(unsigned char)(x)])
+
+#define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_isalpha(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L)) != 0)
+#define bcm_iscntrl(c)	((bcm_ismask(c)&(_BCM_C)) != 0)
+#define bcm_isdigit(c)	((bcm_ismask(c)&(_BCM_D)) != 0)
+#define bcm_isgraph(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_islower(c)	((bcm_ismask(c)&(_BCM_L)) != 0)
+#define bcm_isprint(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D|_BCM_SP)) != 0)
+#define bcm_ispunct(c)	((bcm_ismask(c)&(_BCM_P)) != 0)
+#define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
+#define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
+#define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
+
+/*
+ * Spin at most 'us' microseconds while 'exp' is true.
+ * Caller should explicitly test 'exp' when this completes
+ * and take appropriate error action if 'exp' is still true.
+ */
+#define SPINWAIT(exp, us) { \
+	uint countdown = (us) + 9; \
+	while ((exp) && (countdown >= 10)) {\
+		OSL_DELAY(10); \
+		countdown -= 10; \
+	} \
+}
+
+/* generic osl packet queue */
+struct pktq {
+	void *head;	/* first packet to dequeue */
+	void *tail;	/* last packet to dequeue */
+	uint len;	/* number of queued packets */
+	uint maxlen;	/* maximum number of queued packets */
+	bool priority;	/* enqueue by packet priority */
+};
+#define DEFAULT_QLEN	128
+
+#define	pktq_len(q)	((q)->len)
+#define	pktq_avail(q)	((q)->maxlen - (q)->len)
+#define	pktq_head(q)	((q)->head)
+#define	pktq_full(q)	((q)->len >= (q)->maxlen)
+
+/* crc defines */
+#define CRC8_INIT_VALUE  0xff		/* Initial CRC8 checksum value */
+#define CRC8_GOOD_VALUE  0x9f		/* Good final CRC8 checksum value */
+#define CRC16_INIT_VALUE 0xffff		/* Initial CRC16 checksum value */
+#define CRC16_GOOD_VALUE 0xf0b8		/* Good final CRC16 checksum value */
+#define CRC32_INIT_VALUE 0xffffffff	/* Initial CRC32 checksum value */
+#define CRC32_GOOD_VALUE 0xdebb20e3	/* Good final CRC32 checksum value */
+
+/* tag_ID/length/value_buffer tuple */
+typedef struct bcm_tlv {
+	uint8	id;
+	uint8	len;
+	uint8	data[1];
+} bcm_tlv_t;
+
+/* Check that bcm_tlv_t fits into the given buflen */
+#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (buflen) >= 2 + (elt)->len)
+
+/* buffer length for ethernet address from bcm_ether_ntoa() */
+#define ETHER_ADDR_STR_LEN	18
+
+/*
+* load 32-bit value from unaligned byte array
+*/
+#ifdef IL_BIGENDIAN
+#define load32_ua(a)	((((uint8 *)(a))[0] << 24) + (((uint8 *)(a))[1] << 16) + \
+			(((uint8 *)(a))[2] << 8) + ((uint8 *)(a))[3])
+#else
+#define load32_ua(a)	((((uint8 *)(a))[3] << 24) + (((uint8 *)(a))[2] << 16) + \
+			(((uint8 *)(a))[1] << 8) + ((uint8 *)(a))[0])
+#endif
+
+/* externs */
+extern uint bcm_atoi(char *s);
+extern uchar bcm_toupper(uchar c);
+extern ulong bcm_strtoul(char *cp, char **endp, uint base);
+extern void deadbeef(char *p, uint len);
+extern void prhex(char *msg, uchar *buf, uint len);
+extern void prpkt(char *msg, void *drv, void *p0);
+extern uint pktcopy(void *drv, void *p, uint offset, int len, uchar *buf);
+extern uint pkttotlen(void *drv, void *);
+extern uchar *bcm_ether_ntoa(char *ea, char *buf);
+extern int bcm_ether_atoe(char *p, char *ea);
+extern void bcm_mdelay(uint ms);
+extern char *getvar(char *vars, char *name);
+extern int getintvar(char *vars, char *name);
+extern char *bcmstrstr(char *haystack, char *needle);
+
+extern uint8 crc8(uint8 *p, uint nbytes, uint8 crc);
+extern uint16 crc16(uint8 *p, uint nbytes, uint16 crc);
+extern uint32 crc32(uint8 *p, uint nbytes, uint32 crc);
+extern bcm_tlv_t *bcm_next_tlv(bcm_tlv_t *elt, int *buflen);
+extern bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen, uint key);
+extern bcm_tlv_t *bcm_parse_ordered_tlvs(void *buf, int buflen, uint key);
+extern void pktq_init(struct pktq *q, uint maxlen, bool priority);
+extern bool pktenq(struct pktq *q, void *p, bool lifo);
+extern void *pktdeq(struct pktq *q);
+
+#define	bcmlog(fmt, a1, a2)
+#define	bcmdumplog(buf, size)	*buf = '\0'
+#define	bcmdumplogent(buf, idx)	-1
+
+#endif	/* _bcmutils_h_ */

Property changes on: src/include/bcmutils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/include/typedefs.h
===================================================================
--- src/include/typedefs.h	(revision 0)
+++ src/include/typedefs.h	(revision 7299)
@@ -0,0 +1,295 @@
+/*
+ * Copyright 2004, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id: typedefs.h 6177 2007-01-22 14:46:37Z nbd $
+ */
+
+#ifndef _TYPEDEFS_H_
+#define _TYPEDEFS_H_
+
+
+/* Define 'SITE_TYPEDEFS' in the compile to include a site specific
+ * typedef file "site_typedefs.h".
+ *
+ * If 'SITE_TYPEDEFS' is not defined, then the "Inferred Typedefs"
+ * section of this file makes inferences about the compile environment
+ * based on defined symbols and possibly compiler pragmas.
+ *
+ * Following these two sections is the "Default Typedefs"
+ * section. This section is only prcessed if 'USE_TYPEDEF_DEFAULTS' is
+ * defined. This section has a default set of typedefs and a few
+ * proprocessor symbols (TRUE, FALSE, NULL, ...).
+ */
+
+#ifdef SITE_TYPEDEFS
+
+/*******************************************************************************
+ * Site Specific Typedefs
+ *******************************************************************************/
+
+#include "site_typedefs.h"
+
+#else
+
+/*******************************************************************************
+ * Inferred Typedefs
+ *******************************************************************************/
+
+/* Infer the compile environment based on preprocessor symbols and pramas.
+ * Override type definitions as needed, and include configuration dependent
+ * header files to define types.
+ */
+
+#ifdef __cplusplus
+
+#define TYPEDEF_BOOL
+#ifndef FALSE
+#define FALSE	false
+#endif
+#ifndef TRUE
+#define TRUE	true
+#endif
+
+#else	/* ! __cplusplus */
+
+/* for Windows build, define bool as a uchar instead of the default int */
+#if defined(_WIN32)
+
+#define TYPEDEF_BOOL
+typedef	unsigned char	bool;
+
+#endif /* _WIN32 */
+
+#endif	/* ! __cplusplus */
+
+#ifdef _MSC_VER	    /* Microsoft C */
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+typedef signed __int64	int64;
+typedef unsigned __int64 uint64;
+#endif
+
+#if defined(MACOSX) && defined(KERNEL)
+#define TYPEDEF_BOOL
+#endif
+
+
+#if defined(linux)
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#define TYPEDEF_ULONG
+#endif
+
+#if !defined(linux) && !defined(_WIN32) && !defined(PMON) && !defined(_CFE_)
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#endif
+
+
+/* Do not support the (u)int64 types with strict ansi for GNU C */
+#if defined(__GNUC__) && defined(__STRICT_ANSI__)
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+#endif
+
+/* ICL accepts unsigned 64 bit type only, and complains in ANSI mode
+ * for singned or unsigned */
+#if defined(__ICL)
+
+#define TYPEDEF_INT64
+
+#if defined(__STDC__)
+#define TYPEDEF_UINT64
+#endif
+
+#endif /* __ICL */
+
+
+#if !defined(_WIN32) && !defined(PMON) && !defined(_CFE_)
+
+/* pick up ushort & uint from standard types.h */
+#if defined(linux) && defined(__KERNEL__)
+
+#include <linux/types.h>	/* sys/types.h and linux/types.h are oil and water */
+
+#else
+
+#include <sys/types.h>	
+
+#endif
+
+#endif /* !_WIN32 && !PMON && !_CFE_ */
+
+#if defined(MACOSX) && defined(KERNEL)
+#include <IOKit/IOTypes.h>
+#endif
+
+
+/* use the default typedefs in the next section of this file */
+#define USE_TYPEDEF_DEFAULTS
+
+#endif /* SITE_TYPEDEFS */
+
+
+/*******************************************************************************
+ * Default Typedefs
+ *******************************************************************************/
+
+#ifdef USE_TYPEDEF_DEFAULTS
+#undef USE_TYPEDEF_DEFAULTS
+
+#ifndef TYPEDEF_BOOL
+typedef	int	bool;
+#endif
+
+/*----------------------- define uchar, ushort, uint, ulong ----------------*/
+
+#ifndef TYPEDEF_UCHAR
+typedef unsigned char	uchar;
+#endif
+
+#ifndef TYPEDEF_USHORT
+typedef unsigned short	ushort;
+#endif
+
+#ifndef TYPEDEF_UINT
+typedef unsigned int	uint;
+#endif
+
+#ifndef TYPEDEF_ULONG
+typedef unsigned long	ulong;
+#endif
+
+/*----------------------- define [u]int8/16/32/64 --------------------------*/
+
+#ifndef TYPEDEF_UINT8
+typedef unsigned char	uint8;
+#endif
+
+#ifndef TYPEDEF_UINT16
+typedef unsigned short	uint16;
+#endif
+
+#ifndef TYPEDEF_UINT32
+typedef unsigned int	uint32;
+#endif
+
+#ifndef TYPEDEF_UINT64
+typedef unsigned long long uint64;
+#endif
+
+#ifndef TYPEDEF_INT8
+typedef signed char	int8;
+#endif
+
+#ifndef TYPEDEF_INT16
+typedef signed short	int16;
+#endif
+
+#ifndef TYPEDEF_INT32
+typedef signed int	int32;
+#endif
+
+#ifndef TYPEDEF_INT64
+typedef signed long long int64;
+#endif
+
+/*----------------------- define float32/64, float_t -----------------------*/
+
+#ifndef TYPEDEF_FLOAT32
+typedef float		float32;
+#endif
+
+#ifndef TYPEDEF_FLOAT64
+typedef double		float64;
+#endif
+
+/*
+ * abstracted floating point type allows for compile time selection of
+ * single or double precision arithmetic.  Compiling with -DFLOAT32
+ * selects single precision; the default is double precision.
+ */
+
+#ifndef TYPEDEF_FLOAT_T
+
+#if defined(FLOAT32)
+typedef float32 float_t;
+#else /* default to double precision floating point */
+typedef float64 float_t;
+#endif
+
+#endif /* TYPEDEF_FLOAT_T */
+
+/*----------------------- define macro values -----------------------------*/
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#ifndef ON
+#define	ON	1
+#endif
+
+/*----------------------- define PTRSZ, INLINE ----------------------------*/
+
+#ifndef PTRSZ
+#define	PTRSZ	sizeof (char*)
+#endif
+
+#ifndef INLINE
+
+#ifdef _MSC_VER
+
+#define INLINE __inline
+
+#elif __GNUC__
+
+#define INLINE __inline__
+
+#else
+
+#define INLINE
+
+#endif /* _MSC_VER */
+
+#endif /* INLINE */
+
+#undef TYPEDEF_BOOL
+#undef TYPEDEF_UCHAR
+#undef TYPEDEF_USHORT
+#undef TYPEDEF_UINT
+#undef TYPEDEF_ULONG
+#undef TYPEDEF_UINT8
+#undef TYPEDEF_UINT16
+#undef TYPEDEF_UINT32
+#undef TYPEDEF_UINT64
+#undef TYPEDEF_INT8
+#undef TYPEDEF_INT16
+#undef TYPEDEF_INT32
+#undef TYPEDEF_INT64
+#undef TYPEDEF_FLOAT32
+#undef TYPEDEF_FLOAT64
+#undef TYPEDEF_FLOAT_T
+
+#define ETHER_ADDR_LEN 6
+
+#endif /* USE_TYPEDEF_DEFAULTS */
+
+#endif /* _TYPEDEFS_H_ */

Property changes on: src/include/typedefs.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/include/wlutils.h
===================================================================
--- src/include/wlutils.h	(revision 0)
+++ src/include/wlutils.h	(revision 7299)
@@ -0,0 +1,82 @@
+/*
+ * Broadcom wireless network adapter utility functions
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: wlutils.h 6177 2007-01-22 14:46:37Z nbd $
+ */
+
+#ifndef _wlutils_h_
+#define _wlutils_h_
+
+#include <typedefs.h>
+
+/* check this magic number */
+#define WLC_IOCTL_MAGIC		0x14e46c77
+
+/* maximum length buffer required */
+#define WLC_IOCTL_SMLEN         256
+
+#define WLC_IOCTL_VERSION	1
+
+#define WLC_GET_MAGIC				0
+#define WLC_GET_VERSION				1
+#define WLC_GET_VAR				262	/* get value of named variable */
+#define WLC_SET_VAR				263	/* set named variable to value */
+
+/* Linux network driver ioctl encoding */
+typedef struct wl_ioctl {
+	uint cmd;	/* common ioctl definition */
+	void *buf;	/* pointer to user buffer */
+	uint len;	/* length of user buffer */
+	bool set;	/* get or set request (optional) */
+	uint used;	/* bytes read or written (optional) */
+	uint needed;	/* bytes needed (optional) */
+} wl_ioctl_t;
+
+
+/*
+ * Pass a wlioctl request to the specified interface.
+ * @param	name	interface name
+ * @param	cmd	WLC_GET_MAGIC <= cmd < WLC_LAST
+ * @param	buf	buffer for passing in and/or receiving data
+ * @param	len	length of buf
+ * @return	>= 0 if successful or < 0 otherwise
+ */
+extern int wl_ioctl(char *name, int cmd, void *buf, int len);
+
+/*
+ * Get the MAC (hardware) address of the specified interface.
+ * @param	name	interface name
+ * @param	hwaddr	6-byte buffer for receiving address
+ * @return	>= 0 if successful or < 0 otherwise
+ */
+extern int wl_hwaddr(char *name, unsigned char *hwaddr);
+
+/*
+ * Probe the specified interface.
+ * @param	name	interface name
+ * @return	>= 0 if a Broadcom wireless device or < 0 otherwise
+ */
+extern int wl_probe(char *name);
+
+/*
+ * Set/Get named variable.
+ * @param	name	interface name
+ * @param	var	variable name
+ * @param	val	variable value/buffer
+ * @param	len	variable value/buffer length
+ * @return	success == 0, failure != 0
+ */
+extern int wl_set_val(char *name, char *var, void *val, int len);
+extern int wl_get_val(char *name, char *var, void *val, int len);
+extern int wl_set_int(char *name, char *var, int val);
+extern int wl_get_int(char *name, char *var, int *val);
+
+#endif /* _wlutils_h_ */

Property changes on: src/include/wlutils.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/zlib.h
===================================================================
--- src/zlib.h	(revision 0)
+++ src/zlib.h	(revision 7299)
@@ -0,0 +1,654 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.1.3, July 9th, 1998
+
+  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef _ZLIB_H
+#define _ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.1.3"
+
+/* 
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    void     *workspace; /* memory allocated for this stream */
+
+    int     data_type;  /* best guess about the data type: ascii or binary */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_PACKET_FLUSH  2
+#define Z_SYNC_FLUSH    3
+#define Z_FULL_FLUSH    4
+#define Z_FINISH        5
+/* Allowed flush values; see deflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlib_zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+ZEXTERN int ZEXPORT zlib_deflate_workspacesize OF((void));
+/*
+   Returns the number of bytes that needs to be allocated for a per-
+   stream workspace.  A pointer to this number of bytes should be
+   returned in stream->workspace before calling zlib_deflateInit().
+*/
+
+/* 
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT zlib_deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  the compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out).
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+  
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm->adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update data_type if it can make a good guess about
+  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero).
+*/
+
+
+ZEXTERN int ZEXPORT zlib_deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+ZEXTERN int ZEXPORT zlib_inflate_workspacesize OF((void));
+/*
+   Returns the number of bytes that needs to be allocated for a per-
+   stream workspace.  A pointer to this number of bytes should be
+   returned in stream->workspace before calling zlib_inflateInit().
+*/
+
+/* 
+ZEXTERN int ZEXPORT zlib_inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, and workspace must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT zlib_inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may some
+  introduce some output latency (reading input without producing any output)
+  except when forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
+  output as possible to the output buffer. The flushing behavior of inflate is
+  not specified for values of the flush parameter other than Z_SYNC_FLUSH
+  and Z_FINISH, but the current implementation actually flushes as much output
+  as possible anyway.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster routine
+  may be used for the single inflate() call.
+
+     If a preset dictionary is needed at this point (see inflateSetDictionary
+  below), inflate sets strm-adler to the adler32 checksum of the
+  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
+  it sets strm->adler to the adler32 checksum of all output produced
+  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
+  an error code as described below. At the end of the stream, inflate()
+  checks that its computed adler32 checksum is equal to that saved by the
+  compressor and returns Z_STREAM_END only if the checksum is correct.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect
+  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
+  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
+  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
+  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
+  case, the application may then call inflateSync to look for a good
+  compression block.
+*/
+
+
+ZEXTERN int ZEXPORT zlib_inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*   
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer).  It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match).  Filtered data consists mostly of small values with a
+   somewhat random distribution. In this case, the compression algorithm is
+   tuned to compress them better. The effect of Z_FILTERED is to force more
+   Huffman coding and less string matching; it is somewhat intermediate
+   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
+   the compression ratio but not the correctness of the compressed output even
+   if it is not set appropriately.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+                            
+ZEXTERN int ZEXPORT zlib_deflateSetDictionary OF((z_streamp strm,
+						     const Bytef *dictionary,
+						     uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front.
+
+     Upon return of this function, strm->adler is set to the Adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The Adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.)
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT zlib_deflateCopy OF((z_streamp dest,
+					    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT zlib_deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT zlib_deflateParams OF((z_streamp strm,
+					      int level,
+					      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+/*   
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. If a compressed stream with a larger window size is given as
+   input, inflate() will return with the error code Z_DATA_ERROR instead of
+   trying to allocate a larger window.
+
+      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
+   memLevel). msg is set to null if there is no error message.  inflateInit2
+   does not perform any decompression apart from reading the zlib header if
+   present: this will be done by inflate(). (So next_in and avail_in may be
+   modified, but next_out and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT zlib_inflateSetDictionary OF((z_streamp strm,
+						     const Bytef *dictionary,
+						     uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate
+   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the Adler32 value returned by this call of
+   inflate. The compressor and decompressor must use exactly the same
+   dictionary (see deflateSetDictionary).
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect Adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT zlib_inflateSync OF((z_streamp strm));
+/* 
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT zlib_inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+extern int ZEXPORT zlib_inflateIncomp OF((z_stream *strm));
+/*
+     This function adds the data at next_in (avail_in bytes) to the output
+   history without performing any output.  There must be no pending output,
+   and the decompressor must be expecting to see the start of a block.
+   Calling this function is equivalent to decompressing a stored block
+   containing the data at next_in (except that the data is not output).
+*/
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT zlib_deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT zlib_inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT zlib_deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT zlib_inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+#define zlib_deflateInit(strm, level) \
+        zlib_deflateInit_((strm), (level), ZLIB_VERSION, sizeof(z_stream))
+#define zlib_inflateInit(strm) \
+        zlib_inflateInit_((strm), ZLIB_VERSION, sizeof(z_stream))
+#define zlib_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        zlib_deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy), ZLIB_VERSION, sizeof(z_stream))
+#define zlib_inflateInit2(strm, windowBits) \
+        zlib_inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zlib_zError           OF((int err));
+ZEXTERN int            ZEXPORT zlib_inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT zlib_get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ZLIB_H */

Property changes on: src/zlib.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/ezpcom-lib.h
===================================================================
--- src/ezpcom-lib.h	(revision 0)
+++ src/ezpcom-lib.h	(revision 7299)
@@ -0,0 +1,570 @@
+#ifndef _EZPCOM_LIB_H
+#define _EZPCOM_LIB_H
+
+/* 
+ * THE VENDOR TABLE 
+ */
+
+#define EZP_COM_VENDOR_MAP(X)                                   \
+    X(AUTO, "Auto", 0x3789, 1)                                  \
+    X(HUAWEI, "Huawei", 0x12d1, 1)                              \
+    X(HUAWEI2, "Huawei (Alternative)", 0x1033, 1)               \
+    X(ZTE, "ZTE", 0x19d2, 1)                                    \
+    X(EMPTY, "", 0x0, 0)                                        \
+
+
+/* 
+ * THE PRODUCT TABLE TO A SPECIFIC VENDOR
+ * (1) Device Name
+ * (2) Default Device, Target Vendor, Target Device, Target Class, MessageEndpoint, * ResponseEndpoint,
+ * (3) DetachStorageOnly, Mode, Interface, 
+ * (4) Device Num, Data, Ctrl,
+ * (5) MessageContent, Shown
+ *
+ * XXX: 
+ * I. For the multiple-message devices, the entries (other than the last 
+ * message) should be set with 0xF0. The last entries should be set with 0x00.
+ * 
+ * II. Also, in the first message, flag should be set. Others should be set
+ * 0.
+ *
+ * III. For the express card, the "Default Device" is set as 0xFFFF.
+ * 
+ */
+
+/* Empty definition. */
+#define EZP_COM_MAP_EMPTY(X)                        \
+    X("",                                           \
+            0x0, EMPTY, 0x0, 0x0, 0x0, -1,          \
+            0, 0, 0x0,                              \
+            0, 0, 0, "",                            \
+            NULL, 0)                                \
+
+
+#define EZP_COM_MAP_AUTO(X)                       \
+    X("Auto",                                       \
+            0x5233, EMPTY, 0x0, 0x0, 0x0, -1,       \
+            0, 0, 0x0,                              \
+            0, 0, 0, "",                         \
+            NULL, 1 )                               \
+    X("",                                           \
+            0x0, EMPTY, 0x0, 0x0, 0x0, -1,          \
+            0, 0, 0x0,                              \
+            0, 0, 0, "",                            \
+            NULL, 0)                                \
+
+/* We intentionally use 0x as TargetProduct. */
+#define EZP_COM_MAP_HUAWEI(X)                       \
+    X("Generic",                                  \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1 )                               \
+    X("E156G",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E160E",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E160G",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E161",       \
+            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
+            0, 0, 0x0,                              \
+            3, 0, 0, "ttyUSB",                         \
+            "55534243000000000000000000000011060000000000000000000000000000", 1) \
+    X("E169",                                    \
+            0x1001, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            3, 0, 0, "ttyUSB",                         \
+            NULL, 1 )                               \
+    X("E1692",                                    \
+            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
+            0, 0, 0x0,                              \
+            3, 0, 2, "ttyUSB",                         \
+            "55534243000000000000000000000011060000000000000000000000000000", 1) \
+    X("E169U",                                    \
+            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
+            0, 0, 0x0,                              \
+            3, 0, 2, "ttyUSB",                         \
+            "55534243000000000000000000000011060000000000000000000000000000", 1) \
+    X("E170",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E172",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E1750",                                    \
+            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
+            0, 0, 0x0,                              \
+            3, 0, 2, "ttyUSB",                         \
+            "55534243000000000000000000000011060000000000000000000000000000", 1) \
+    X("E180",       \
+            0x1414, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E219",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E220",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E226",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E270",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E800",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("E1762",       \
+            0x1003, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("EC1260",       \
+            0x140b, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("ET128",       \
+            0x1da1, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            3, 2, 0, "ttyACM",                         \
+            NULL, 1) \
+    X("K1550",       \
+            0x1446, HUAWEI, 0x0, 0x0, 0x1, -1,       \
+            0, 0, 0x0,                              \
+            3, 0, 0, "ttyUSB",                         \
+            "55534243000000000000000000000011060000000000000000000000000000", 1) \
+    X("K3715",       \
+            0x1001, HUAWEI, 0x0, 0x0, 0x0, -1,       \
+            1, 1, 0x0,                              \
+            3, 0, 0, "ttyUSB",                         \
+            NULL, 1) \
+    X("E870",                                       \
+            0xFFFF, HUAWEI, 0x1003, 0x0, 0x0, -1,       \
+            0, 0, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                \
+    X("",                                           \
+            0x0, EMPTY, 0x0, 0x0, 0x0, -1,          \
+            0, 0, 0x0,                              \
+            0, 0, 0, "",                            \
+            NULL, 0)                                \
+
+
+#define EZP_COM_MAP_HUAWEI2(X)                      \
+    X("E630",                                       \
+            0x0035, HUAWEI, 0x1003, 0x0, 0x0, -1,   \
+            1, 0, 0x0,                              \
+            2, 0, 1, "ttyUSB",                         \
+            NULL, 1)                                  \
+    X("",        \
+            0x0, EMPTY, 0x0, 0x0, 0x0, -1,  \
+            0, 0, 0x0,                              \
+            0, 0, 0, "",                            \
+            NULL, 0) \
+
+
+/*
+ * In Australia, pre-paid MF626 is buggy! When the data is on, any access to
+ * the control tty causes the modem panic! So in "Generic" and
+ * "MF628+/MF626/MF636/MF637" both have the same data and tty nums.
+ */ 
+/*
+ * In South Africa, K3565-Z does the following steps:
+ * # Standard SCSI eject
+ * #usb_modeswitch -v ${VID} -p ${PID} -M
+ * 5553424312345678000000000000061b000000020000000000000000000000 -R 1
+ * # Storage passthrough
+ * usb_modeswitch -v ${VID} -p ${PID} -M
+ * 55534243123456782400000080000C85000000240000000000000000000000 -R 1
+ * NB: It seems some ZTE devices require USB reset. e.g. ZTE MF628 from TWN
+ * Mobile. We leverage 0x80 at Mode to indicate reset.
+ */
+
+#define EZP_COM_MAP_ZTE(X)                      \
+    X("Generic",                                       \
+            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 2, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("MF622",                                       \
+            0x2000, ZTE, 0x0002, 0x0, 0x04, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            "55534243f8f993882000000080000a85010101180101010101000000000000", 1)\
+    X("MF622 (version 2)",                                       \
+            0x2000, ZTE, 0x0001, 0x0, 0x0, -1,   \
+            1, 0, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            NULL, 1) \
+    X("MF628",                                       \
+            0x2000, ZTE, 0x0015, 0x0, 0x08, -1,   \
+            0, 0x80, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            "5553424312345678000000000000061b000000030000000000000000000000", 1) \
+    X("MF628+",                                       \
+            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 2, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("MF626",                                       \
+            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 2, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("MF633",                                       \
+            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 2, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("MF636",                                       \
+            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 2, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("MF637",                                       \
+            0x2000, ZTE, 0x0031, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 2, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("MF638",                                       \
+            0x2000, ZTE, 0x0037, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("MU351",                                       \
+            0x0003, ZTE, 0x0037, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("K3565-Z",                                       \
+            0x2000, ZTE, 0x0063, 0x0, 0x01, -1,   \
+            0, 0, 0x0,                              \
+            5, 3, 1, "ttyUSB",                         \
+            "55534243123456782000000080000c85010101180101010101000000000000", 1) \
+    X("ONDA MT503HS",                                       \
+            0x2000, ZTE, 0x0002, 0x0, 0x08, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            "55534243b0c8dc812000000080000a85010101180101010101000000000000", 1) \
+    X("ONDA MT505UP",                                       \
+            0x2000, ZTE, 0x0002, 0x0, 0x03, -1,   \
+            0, 0, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            "55534243123456780000010080000a28000000001c00002000000000000000", 1) \
+    X("ONDA MT525UP",                                       \
+            0x2000, ZTE, 0x0002, 0x0, 0x0, -1,   \
+            0, 4, 0x0,                              \
+            3, 2, 1, "ttyUSB",                         \
+            NULL, 1) \
+    X("",        \
+            0x0, EMPTY, 0x0, 0x0, 0x0, -1,  \
+            0, 0, 0x0,                              \
+            0, 0, 0, "",                            \
+            NULL, 0) \
+
+
+
+#define EZP_COM_VENDOR_NAME_CONVERTER(VNAME,NAME,VID,SHOWN) EZP_COM_VID_##VNAME,
+typedef enum {
+    EZP_COM_VENDOR_MAP(EZP_COM_VENDOR_NAME_CONVERTER)
+} ezp_com_vendor_name_type;
+
+struct ezp_com_vendor_map_entry_type
+{
+    ezp_com_vendor_name_type vn;
+    char *desc;
+    int DefaultVendor;
+    char shown;
+};
+
+struct ezp_com_map_entry_type
+{
+    char *desc;
+    int DefaultProduct;
+    ezp_com_vendor_name_type TargetVendorType;
+    int TargetProduct;
+    int TargetClass;
+    int MessageEndpoint;
+    int ResponseEndpoint;
+    char DetachStorageOnly;
+    /* 
+     * Huawei(1), Sierra(2), Sony(3), Bandluxe(4), MessageNext(0xF0)
+     */
+    char Mode; 
+    int Interface;
+    /* XXX: I intentionally ignore Configuration, AltSetting. */
+    int DeviceNum; 
+    int DataTTY; 
+    int CtrlTTY;
+    char *DevName;
+    char *MessageContent;
+    /* show in GUI or not */
+    char Flag;
+};
+
+#define EZP_COM_VENDOR_MAP_CONVERTER(VNAME,NAME,VID,SHOWN) \
+    {EZP_COM_VID_##VNAME, NAME, VID, SHOWN},
+
+static struct ezp_com_vendor_map_entry_type ezp_com_vendor_map[] = {
+    EZP_COM_VENDOR_MAP(EZP_COM_VENDOR_MAP_CONVERTER)
+};
+
+#define EZP_COM_MAP_CONVERTER(NAME,PID,TVNAME,TPID,TCLS,EP,REP,DT,MODE,INTF,DNUM,DTTY,CTTY,DEVNMAE,MSG,FLAG) \
+   {NAME, PID, EZP_COM_VID_##TVNAME, TPID, TCLS, EP, REP, DT, MODE, INTF, DNUM, DTTY, CTTY, DEVNMAE, MSG, FLAG},
+
+
+#define EZP_COM_MAP_FOR_EACH_VENDOR_CONVERTER(VNAME,NAME,VID,SHOWN) \
+static struct ezp_com_map_entry_type ezp_com_map_##VNAME[] = { \
+    EZP_COM_MAP_##VNAME(EZP_COM_MAP_CONVERTER) \
+}; 
+
+/* Declare tables to each vendor. */
+EZP_COM_VENDOR_MAP(EZP_COM_MAP_FOR_EACH_VENDOR_CONVERTER)
+
+
+#define EZP_COM_POINTER_MAP_CONVERTER(VNAME,NAME,VID,SHOWN) &ezp_com_map_##VNAME[0],
+
+
+static struct ezp_com_map_entry_type *ezp_com_pointer_map[] = {
+    EZP_COM_VENDOR_MAP(EZP_COM_POINTER_MAP_CONVERTER)
+};
+
+/* ------------------------------------ */
+/* For location & ISP information */
+#define EZP_COM_LOCATION_MAP(X)                         \
+    X(TAIWAN, "Taiwan", 1)                              \
+    X(AUSTRALIA, "Australia", 1)                        \
+    X(CANADA, "Canada", 1)                                    \
+    X(CHINA, "China", 1)                                \
+    X(HONGKONG, "Hongkong", 1)                          \
+    X(INDIA, "India", 1)                                    \
+    X(MEXICO, "Mexico", 1)                              \
+    X(NETHERLANDS, "Netherland", 1)                     \
+    X(NORWAY, "Norway", 1)                              \
+    X(PHILIPPINES, "Philippines", 1)                    \
+    X(RUSSIA, "Russia", 1)                              \
+    X(SOUTH_AFRICA, "South Africa", 1)                  \
+    X(USA, "USA", 1)                                    \
+    X(EMPTY, "", 0)
+
+/*
+    X(AUSTRIA, "Austria", 1)                            \
+    X(BELGIUM, "Belgium", 1)                            \
+    X(BRASIL, "Brasil", 1)                              \
+    X(CANADA, "Canada", 1)                              \
+    X(CHILE, "Chile", 1)                                \
+    X(CROATIA, "Croatia", 1)                            \
+    X(CZECH, "Czech", 1)                                \
+    X(DENMARK, "Denmark", 1)                            \
+    X(EGYPT, "Egypt", 1)                                \
+    X(ESTONIA, "Estonia", 1)                            \
+    X(FINLAND, "Finland", 1)                            \
+    X(FRANCE, "France", 1)                              \
+    X(GERMANY, "Germany", 1)                            \
+    X(GREECE, "Greece", 1)                              \
+    X(HUNGARY, "Hungary", 1)                            \
+    X(INDIA, "India", 1)                                \
+    X(INDONESIA, "Indonesia", 1)                        \
+    X(IRELAND, "Ireland", 1)                            \
+    X(ITALY, "Italy", 1)                                \
+    X(JAPAN, "Japan", 1)                                \
+    X(LITHUANIA, "Lithuania", 1)                        \
+    X(LUXEMBOURG, "Luxembourg", 1)                      \
+    X(MACEDONIAN, "Macedonian", 1)                      \
+    X(MALAYSIA, "Malaysia", 1)                          \
+    X(MEXICO, "Mexico", 1)                              \
+    X(NETHERLANDS, "Netherlands", 1)                    \
+    X(NEW_ZEALAND, "New Zealand", 1)                    \
+    X(POLAND, "Poland", 1)                              \
+*/
+
+
+/* 
+ * THE ISP TABLE TO A SPECIFIC LOCATION
+ * (1) APN
+ * (2) PIN
+ * (3) User Name
+ * (4) Passwd
+ * (5) Dialup String
+ *
+ */
+
+/* Empty definition. */
+#define EZP_COM_ISP_MAP_EMPTY(X)                                            \
+    X("", "", "", "", "", "", "", 0)
+
+#define EZP_COM_ISP_MAP_TAIWAN(X)                                           \
+    X("Chunghwa Telecom", "internet", "", "chap", "", "", "*99#", 1 )       \
+    X("Far EasTone (internet)", "internet", "", "chap", "", "", "*99#", 1 ) \
+    X("Far EasTone (fetims)", "fetims", "", "chap", "", "", "*99#", 1 )     \
+    X("Taiwan Cellular", "internet", "", "chap", "", "", "*99#", 1 )        \
+    X("Vibo", "internet", "", "chap", "", "", "*99#", 1 )                   \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+
+#define EZP_COM_ISP_MAP_CHINA(X)                                            \
+    X("China Telecom", "", "", "chap", "", "", "#777", 1 )              \
+    X("China Mobile", "cmnet", "", "chap", "", "", "*99#", 1 )              \
+    X("China Unicom", "", "", "chap", "", "", "*99#", 1 )                   \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+
+#define EZP_COM_ISP_MAP_HONGKONG(X)                                         \
+    X("3 HK", "ipc.three.com.hk", "", "chap", "", "", "*99#", 1 )           \
+    X("CSL", "internet", "", "chap", "", "", "*99#", 1 )                    \
+    X("New World", "ineternet", "", "chap", "", "", "*99#", 1 )             \
+    X("PCCW", "pccw", "", "chap", "", "", "*99#", 1 )                       \
+    X("People", "internet", "", "chap", "", "", "*99#", 1 )                 \
+    X("SmarTone", "internet", "", "chap", "", "", "*99#", 1 )               \
+    X("Sunday", "internet", "", "chap", "", "", "*99#", 1 )                 \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_INDIA(X)                                     \
+    X("TATA", "TATA", "", "chap", "internet", "internet", "#777", 1 )             \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_MEXICO(X)                                           \
+    X("Movistar", "internet.movistar.mx", "", "chap", "", "", "*99#", 1 )   \
+    X("Telcel", "internet.itelcel.com", "", "chap", "", "", "*99#", 1 )     \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_NETHERLANDS(X)                                      \
+    X("T-Mobile", "internet", "", "chap", "", "", "*99#", 1 )               \
+    X("KPN", "internet", "", "chap", "", "", "*99#", 1 )                    \
+    X("Telfort", "internet", "", "chap", "", "", "*99#", 1 )                \
+    X("Vodafone", "internet", "", "chap", "", "", "*99#", 1 )               \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_NORWAY(X)                                           \
+    X("Telenor Mobil", "Telenor", "", "chap", "", "", "*99***1#", 1 )       \
+    X("Netcom Mobil", "Netcom", "", "chap", "", "", "*99***1#", 1 )         \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+
+#define EZP_COM_ISP_MAP_PHILIPPINES(X)                                      \
+    X("Globe", "www.globe.com.ph", "", "chap", "globe", "globe", "*99#", 1 ) \
+    X("Smart", "internet", "", "chap", "", "", "*99#", 1 )                  \
+    X("Sun Cellula", "minternet", "", "chap", "", "", "*99#", 1 )           \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_RUSSIA(X)                                           \
+    X("BeeLine", "internet.beeline.ru", "", "chap", "beeline", "beeline", "*99#", 1 )  \
+    X("Megafon (NWGSM)", "internet.nw", "", "chap", "", "", "*99#", 1 )     \
+    X("MTS", "internet.mts.ru", "", "chap", "mts", "mts", "*99#", 1 )       \
+    X("PrimTel", "internet.primtel.ru", "", "chap", "", "", "*99#", 1 )     \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_AUSTRALIA(X)                                        \
+    X("iburst", "internet", "", "chap", "", "", "*99#", 1 )                 \
+    X("Bigpond", "telstra.bigpond", "", "chap", "", "", "*99#", 1 )         \
+    X("Dodo", "dodolns1", "", "chap", "", "", "*99#", 1 )                   \
+    X("Exetel", "exetel1", "", "chap", "", "", "*99#", 1 )                  \
+    X("Internode", "splns333a1", "", "chap", "", "", "*99#", 1 )            \
+    X("Optus", "internet", "", "chap", "", "", "*99#", 1 )                  \
+    X("Telstra", "telstra.internet", "", "chap", "", "", "*99#", 1 )        \
+    X("Three", "3netaccess", "", "chap", "", "", "*99#", 1 )                \
+    X("Three Prepaid", "3services", "", "chap", "", "", "*99#", 1 )         \
+    X("TPG", "internet", "", "chap", "", "", "*99#", 1 )                    \
+    X("Virgin", "virginbroadband", "", "pap", "", "", "*99***1#", 1)        \
+    X("Vodafone", "vfinternet.au", "", "chap", "", "", "*99#", 1 )          \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_SOUTH_AFRICA(X)                                     \
+    X("MTN", "", "", "chap", "", "", "*99#", 1 )                            \
+    X("Vodacom", "internet", "", "chap", "", "", "*99***16#", 1 )           \
+    X("Cell-C", "internet", "", "chap", "Cellcis", "Cellcis", "*99***16#", 1 ) \
+    X("Neotel", "", "", "chap", "", "", "#777", 1 ) \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_CANADA(X)                                     \
+    X("Rogers", "internet.com", "", "chap", "", "", "*99#", 1 )             \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_ISP_MAP_USA(X)                                              \
+    X("AT&T", "proxy", "", "", "chap", "", "*99#", 1 )                      \
+    X("Bell Mobility", "", "", "chap", "", "", "*99#", 1 )                  \
+    X("Cellular One", "cellular1wap", "", "chap", "", "", "*99#", 1 )       \
+    X("Cincinnati Bell", "wap.gocbw.com", "", "chap", "cbw", "", "*99#", 1 ) \
+    X("T-Mobile(T-Zone)", "wap.voicestream.com", "", "chap", "", "", "*99#", 1 ) \
+    X("T-Mobile(internet)", "internet2.voicestream.com","","chap", "","","*99#",1)  \
+    X("Verizon", "", "", "chap", "", "","*99#", 1)                          \
+    X("", "", "", "", "", "", "", 0)                                        \
+
+#define EZP_COM_LOCATION_NAME_CONVERTER(LNAME,NAME,SHOWN) EZP_COM_LID_##LNAME,
+typedef enum {
+    EZP_COM_LOCATION_MAP(EZP_COM_LOCATION_NAME_CONVERTER)
+} ezp_com_location_name_type;
+
+struct ezp_com_location_map_entry_type
+{
+    ezp_com_location_name_type ln;
+    char *desc;
+    char shown;
+};
+
+struct ezp_com_isp_map_entry_type
+{
+    char *desc;
+    char *apn;
+    char *pin;
+    char *auth;
+    char *user_name;
+    char *passwd;
+    char *dialup_str;
+    char shown;
+};
+
+#define EZP_COM_LOCATION_MAP_CONVERTER(LNAME,NAME,SHOWN) \
+    {EZP_COM_LID_##LNAME, NAME, SHOWN},
+
+static struct ezp_com_location_map_entry_type ezp_com_location_map[] = {
+    EZP_COM_LOCATION_MAP(EZP_COM_LOCATION_MAP_CONVERTER)
+};
+
+#define EZP_COM_ISP_MAP_CONVERTER(NAME,APN,PIN,AUTH,USER,PW,DIALUP,SHOWN) \
+   {NAME, APN, PIN, AUTH, USER, PW, DIALUP, SHOWN},
+
+#define EZP_COM_ISP_MAP_FOR_EACH_LOCATION_CONVERTER(LNAME,NAME,SHOWN) \
+static struct ezp_com_isp_map_entry_type ezp_com_isp_map_##LNAME[] = { \
+    EZP_COM_ISP_MAP_##LNAME(EZP_COM_ISP_MAP_CONVERTER) \
+}; 
+
+/* Declare tables to each location. */
+EZP_COM_LOCATION_MAP(EZP_COM_ISP_MAP_FOR_EACH_LOCATION_CONVERTER)
+
+
+#define EZP_COM_ISP_POINTER_MAP_CONVERTER(LNAME,NAME,SHOWN) &ezp_com_isp_map_##LNAME[0],
+
+
+static struct ezp_com_isp_map_entry_type *ezp_com_isp_map[] = {
+    EZP_COM_LOCATION_MAP(EZP_COM_ISP_POINTER_MAP_CONVERTER)
+};
+
+#endif

Property changes on: src/ezpcom-lib.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/bcmtimer.h
===================================================================
--- src/bcmtimer.h	(revision 0)
+++ src/bcmtimer.h	(revision 7299)
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * Low resolution timer interface. Timer handlers may be called 
+ * in a deferred manner in a different task context after the 
+ * timer expires or in the task context from which the timer
+ * was created, depending on the implementation.
+ *
+ * $Id: bcmtimer.h 1629 2005-08-13 14:22:32Z nbd $
+ */
+#ifndef __bcmtimer_h__
+#define __bcmtimer_h__
+
+/* ANSI headers */
+#include <time.h>
+
+/* timer ID */
+typedef unsigned int bcm_timer_module_id;
+typedef unsigned int bcm_timer_id;
+
+/* timer callback */
+typedef void (*bcm_timer_cb)(bcm_timer_id id, int data);
+
+/* OS-independant interfaces, applications should call these functions only */
+int bcm_timer_module_init(int timer_entries, bcm_timer_module_id *module_id);
+int bcm_timer_module_cleanup(bcm_timer_module_id module_id);
+int bcm_timer_module_enable(bcm_timer_module_id module_id, int enable);
+int bcm_timer_create(bcm_timer_module_id module_id, bcm_timer_id *timer_id);
+int bcm_timer_delete(bcm_timer_id timer_id);
+int bcm_timer_gettime(bcm_timer_id timer_id, struct itimerspec *value);
+int bcm_timer_settime(bcm_timer_id timer_id, const struct itimerspec *value);
+int bcm_timer_connect(bcm_timer_id timer_id, bcm_timer_cb func, int data);
+int bcm_timer_cancel(bcm_timer_id timer_id);
+int bcm_timer_change_expirytime(bcm_timer_id timer_id, const struct itimerspec *timer_spec);
+
+#endif	/* #ifndef __bcmtimer_h__ */

Property changes on: src/bcmtimer.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/ezp-lib.h
===================================================================
--- src/ezp-lib.h	(revision 0)
+++ src/ezp-lib.h	(revision 7299)
@@ -0,0 +1,76 @@
+#ifndef _EZP_LIB_H
+#define _EZP_LIB_H
+
+#define EZPLIB_BUF_LEN          8192
+
+#define EZPLIB_USE_CLI          0
+#define EZPLIB_USE_WEB          1
+
+#define EZPLIB_INVALID          -1
+#define EZPLIB_VAL_TRUNC        -2
+#define EZPLIB_NO_RULE_SET      -3
+#define EZPLIB_NO_RULE          -4
+#define EZPLIB_NO_ATTRIBUTE     -5
+#define EZPLIB_IDX_OUT_RANGE    -6
+
+#define RULE_SEP "|"
+#define ATTR_SEP "^"
+
+/**
+ * \brief Get a specified rule set from nvram, parse it by the RULE_SEP 
+ * character, and return the nth rule.
+ */
+int ezplib_get_rule(char *rule_set, int nth, char *buf, int bsize);
+
+/**
+ * \brief Get a specified specified rule set from nvram, parse it by 
+ * RULE_SEP character, and return the subrule with the attribute position in
+ * between start and end.
+ */
+int ezplib_get_subrule(char *rule_set, int nth, int start, int end,
+        char *buf, int bsize);
+
+/**
+ * \brief Get a specified attribute of the given rule from the rule set queried 
+ * from nvram. The rules are separated by blank character and the attributes
+ * in a rule are separated by '-' character.
+ */
+int ezplib_get_attr_val(char *rule_set, int nth, char *type, char *buf,
+                        int bsize, int use);
+
+/**
+ * \brief Replace the nth rule in the given rule-name as the specific rule.
+ */
+int ezplib_replace_rule(char *rule_set, int nth, char *new_rule);
+
+/**
+ * \brief Replace the mth attribute of the nth rule in the given rule-name as 
+ * the specific rule.
+ */
+int ezplib_replace_attr(char *rule_set, int nth, char *attr, char *new_attr);
+
+/**
+ * \brief Append a new rule into the given rule-name.
+ */
+int ezplib_append_rule(char *rule_set, char *new_rule);
+
+/**
+ * \brief Prepend a new rule into the given rule-name.
+ */
+int ezplib_prepend_rule(char *rule_set, char *new_rule);
+
+/**
+ * \brief Add a new rule in the given rule-name as the specific rule.
+ */
+int ezplib_add_rule(char *rule_set, int nth, char *new_rule);
+
+/**
+ * \brief Delete nth rule in the given rule-name.
+ */
+int ezplib_delete_rule(char *rule_set, int nth);
+
+/**
+ * \brief Get the number of rules in the given rule-name.
+ */
+int ezplib_get_rule_num(char *rule_set);
+#endif

Property changes on: src/ezp-lib.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/shared.h
===================================================================
--- src/shared.h	(revision 0)
+++ src/shared.h	(revision 7299)
@@ -0,0 +1,44 @@
+#ifndef __SHARED_H__
+#define __SHARED_H__
+
+#include <netinet/in.h>
+#include <stdint.h>
+
+#define Y2K			946684800UL		// seconds since 1970
+
+#define ASIZE(array)	(sizeof(array) / sizeof(array[0]))
+
+// process.c
+extern char *psname(int pid, char *buffer, int maxlen);
+extern int pidof(const char *name);
+extern int killall(const char *name, int sig);
+
+// files.c
+#define FW_CREATE	0
+#define FW_APPEND	1
+#define FW_NEWLINE	2
+
+extern unsigned long f_size(const char *path);
+extern int f_exists(const char *file);
+extern int f_read(const char *file, void *buffer, int max);												// returns bytes read
+extern int f_write(const char *file, const void *buffer, int len, unsigned flags, unsigned cmode);		//
+extern int f_read_string(const char *file, char *buffer, int max);										// returns bytes read, not including term; max includes term
+extern int f_write_string(const char *file, const char *buffer, unsigned flags, unsigned cmode);		//
+extern int f_read_alloc(const char *path, char **buffer, int max);
+extern int f_read_alloc_string(const char *path, char **buffer, int max);
+
+
+// base64.c
+extern int base64_encode(unsigned char *in, char *out, int inlen);			// returns amount of out buffer used
+extern int base64_decode(const char *in, unsigned char *out, int inlen);	// returns amount of out buffer used
+extern int base64_encoded_len(int len);
+extern int base64_decoded_len(int len);										// maximum possible, not actual
+
+
+// strings.c
+extern int find_word(const char *buffer, const char *word);
+
+// crc32.o
+extern unsigned long crc32(unsigned long, const unsigned char *, unsigned int);
+
+#endif

Property changes on: src/shared.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/process.c
===================================================================
--- src/process.c	(revision 0)
+++ src/process.c	(revision 7299)
@@ -0,0 +1,112 @@
+/*
+
+	Tomato Firmware
+	Copyright (C) 2006 Jonathan Zarate
+
+*/
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <signal.h>
+#include <dirent.h>
+
+#include "shared.h"
+
+
+//# cat /proc/1/stat
+//1 (init) S 0 0 0 0 -1 256 287 10043 109 21377 7 110 473 1270 9 0 0 0 27 1810432 126 2147483647 4194304 4369680 2147450688 2147449688 717374852 0 0 0 514751 2147536844 0 0 0 0
+
+char *psname(int pid, char *buffer, int maxlen)
+{
+	char buf[512];
+	char path[64];
+	char *p;
+	
+	if (maxlen <= 0) return NULL;
+	*buffer = 0;
+	sprintf(path, "/proc/%d/stat", pid);
+	if ((f_read_string(path, buf, sizeof(buf)) > 4) && ((p = strrchr(buf, ')')) != NULL)) {
+		*p = 0;
+		if (((p = strchr(buf, '(')) != NULL) && (atoi(buf) == pid)) {
+			strlcpy(buffer, p + 1, maxlen);
+		}
+	}
+	return buffer;
+}
+
+static int _pidof(const char *name, pid_t** pids)
+{
+	const char *p;
+	char *e;
+	DIR *dir;
+	struct dirent *de;
+	pid_t i;
+	int count;
+	char buf[256];
+
+	count = 0;
+	*pids = NULL;
+	if ((p = strchr(name, '/')) != NULL) name = p + 1;
+	if ((dir = opendir("/proc")) != NULL) {
+		while ((de = readdir(dir)) != NULL) {
+			i = strtol(de->d_name, &e, 10);
+			if (*e != 0) continue;
+			if (strcmp(name, psname(i, buf, sizeof(buf))) == 0) {
+				if ((*pids = realloc(*pids, sizeof(pid_t) * (count + 1))) == NULL) {
+					return -1;
+				}
+				(*pids)[count++] = i;
+			}
+		}
+	}
+	closedir(dir);
+	return count;
+}
+
+int pidof(const char *name)
+{
+	pid_t *pids;
+	pid_t p;
+	
+	if (_pidof(name, &pids) > 0) {
+		p = *pids;
+		free(pids);
+		return p;
+	}
+	return -1;
+}
+
+int killall(const char *name, int sig)
+{
+	pid_t *pids;
+	int i;
+	int r;
+	
+	if ((i = _pidof(name, &pids)) > 0) {
+		r = 0;
+		do {
+			r |= kill(pids[--i], sig);
+		} while (i > 0);
+		free(pids);
+		return r;
+	}
+	return -2;
+}
+
+
+/*
+int main(int argc, char **argv)
+{
+	int p;
+	char buf[64];
+	
+	if (argc != 2) return 0;
+	p = pidof(argv[1]);
+	printf("pidof = %d\n", p);
+	if (p > 1) {
+		printf("psname = %s\n", psname(p, buf, sizeof(buf)));
+		killall(argv[1], SIGTERM);
+	}
+}
+*/

Property changes on: src/process.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/nvram_ezpacket.h
===================================================================
--- src/nvram_ezpacket.h	(revision 0)
+++ src/nvram_ezpacket.h	(revision 7299)
@@ -0,0 +1,2598 @@
+/*
+ * EZ Packet product default NVRAM values
+ *
+ * Copyright 2006, 2007 EZ Packet Technologies
+ * All Rights Reserved.
+ */
+
+/*
+ * Router default NVRAM values
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ *
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: defaults.c,v 1.104 2005/05/25 12:31:20 honor Exp $
+ */
+
+#ifndef _NVRAM_EZPACKET_H
+#define _NVRAM_EZPACKET_H
+
+#include <bcmnvram.h>
+
+/* HW dependent definition. */
+#ifdef CONFIG_EZP_ARCH_RT305X
+#include "nvram_ezpacket-rt305x.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_RT3883
+#include "nvram_ezpacket-rt3883.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_AS500
+#include "nvram_ezpacket-as500.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_BRCM
+#include "nvram_ezpacket-brcm.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_OX810
+#include "nvram_ezpacket-ox810.h"
+#endif
+#ifdef CONFIG_EZP_ARCH_RTL865X
+#include "nvram_ezpacket-rtl865x.h"
+#endif /* CONFIG_EZP_ARCH_RTL865X */
+
+#if (LAN_NUM == 1)
+    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^liteon.com^custom^^^0^100^200^30"
+    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
+#elif (LAN_NUM == 2)
+    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^liteon.com^custom^^^0^100^200^30|default^0^2001:db8:feed:b10::^2001:db8:feed:b10::^2001:db8:feed:b10::^liteon.com^custom^^^0^100^200^30"
+    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^|2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^2001:db8:feed:b10::^1^64^^^^^^^^^^"
+#else
+    #define LAN_DHCPSV6_RULE "default^1^2001:db8:feed:b00::^2001:db8:feed:b00::^2001:db8:feed:b00::^liteon.com^custom^^^0^100^200^30"
+    #define LAN_STATICV6_RULE_DEFAULT "2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^2001:db8:feed:b00::^1^64^^^^^^^^^^"
+#endif
+#define EZP_PROD_FW_VERSION "V1.00(BWQ.1)C0"
+#define WL_COUNTRY_CODE "US"
+#define WL_REGION_ABAND "7"
+
+/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
+#define FL_HWADDR_RULE_MAX "64"
+
+/* PGP consumes too much memory and leaves less for conntrack. */
+#if defined(EZP_PROD_CAT_C) || defined (EZP_PROD_CAT_T) || defined (EZP_PROD_CAT_D) 
+#define CT_MAX "16000"
+#else
+#define CT_MAX "16000"
+#endif
+
+#define RT_RULE_MAX "32"
+#define BW_RULE_MAX "32"
+
+#if defined(EZP_PROD_SUBSUBCAT_L)
+#define BW_DBM_RULE_MAX "0"
+#define BW_SBM_RULE_MAX "64"
+#define SBM_MAX "64"
+#define DBM_MAX "1"
+#define BW_DBM_RULE_NUM "0"
+#define BW_DBM_RULE "DBM^0^192.168.1.20^192.168.1.27^8^"
+#else
+#define BW_DBM_RULE_MAX "32"
+#define BW_SBM_RULE_MAX "32"
+#define SBM_MAX "8"
+#define DBM_MAX "8"
+#define BW_DBM_RULE_NUM "1"
+#define BW_DBM_RULE "DBM^1^192.168.1.20^192.168.1.27^8^"
+#endif
+
+#define FL_RULE_MAX "64"
+#define FR_RULE_MAX "64"
+#define PT_RULE_MAX "64"
+#define WF_RULE_MAX "16"
+#define IGMP_PROXY_RULE "0"
+#define IGMP_SNOOP_RULE "0^0^0^0^0"
+#define FL_RULE_NUM "0"
+#define FL_RULE ""
+#define BW_ENABLE "1"
+#define BW_SBM_RULE_NUM "10"
+#define USER_SBM_DEFAULT_IPADDR_START ""
+#define USER_SBM_DEFAULT_IPADDR_END   ""
+#define USER_SBM1 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM2 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM3 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM4 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM5 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM6 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM7 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define USER_SBM8 "^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^tcp^wan0^0^10^Game Console^1^^^^^1"
+#define GuestLANtoLAN "GuestLANtoLAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
+#define GuestLANtoWAN "GuestLANtoWAN^0^"USER_SBM_DEFAULT_IPADDR_START"^"USER_SBM_DEFAULT_IPADDR_END"^^wan0^0^0^Game Console^1^^^^^0"
+#define BW_SBM_RULE USER_SBM1"|"USER_SBM2"|"USER_SBM3"|"USER_SBM4"|"USER_SBM5"|"USER_SBM6"|"USER_SBM7"|"USER_SBM8"|"GuestLANtoLAN"|"GuestLANtoWAN
+#if (LAN_NUM == 1)
+    #define LAN_DHCPS_RULE "default^1^33^32^86400^liteon.com^^dnsrelay^^^^^none^opendns^opendns^192.168.1.10^24^60"
+#elif (LAN_NUM == 2)
+    #define LAN_DHCPS_GUESTLAN "default^0^33^32^86400^liteon.com^^ispdns^^^^^none^opendns^opendns^192.168.1.10^24^60"
+    #define LAN_DHCPS_RULE "default^1^33^32^86400^liteon.com^^dnsrelay^^^^^none^opendns^opendns^192.168.1.10^24^60|"LAN_DHCPS_GUESTLAN
+#else
+    #define LAN_DHCPS_RULE "default^1^33^32^86400^liteon.com^^dnsrelay^^^^^none^opendns^opendns^192.168.1.10^24^60"
+#endif
+#define VNC_SESSION_MAX "16"
+
+#define BT_TORRENT_MAX "10"
+#define FTPD_USER_RULE_MAX "8"
+#define IS_RULE "0^^AXIMCom^iscsi_disc^5^8192^8192"
+#define ISUSER_RULE_MAX "8"
+#define ISHOST_RULE_MAX "8"
+#define LOG_RULE "^1^^0^1^1^1^1^0^1^1^1^1^1^0"
+#define SCHED_RULE_MAX "16"
+#define SCHED_RULE_NUM "8"
+#define SCHED_RULE "^0^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
+#define SCHED1_RULE_MAX "16"
+#define SCHED1_RULE_NUM "8"
+#define SCHED1_RULE "^0^wireless^^^everyday^00^00^00^00^0|^0^wireless^^^0^00^00^00^00^0|^0^wireless^^^1^00^00^00^00^0|^0^wireless^^^2^00^00^00^00^0|^0^wireless^^^3^00^00^00^00^0|^0^wireless^^^4^00^00^00^00^0|^0^wireless^^^5^00^00^00^00^0|^0^wireless^^^6^00^00^00^00^0"
+
+/* VPN comes in. Note: No VPN in this subcat except MR-108N.*/
+#if ( WAN_NUM == 1 ) 
+#if defined(EZP_PROD_CAT_M)
+#define PPTPD_SESSION_MAX 5	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "5"
+#else
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#endif
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+
+#elif ( WAN_NUM == 2 ) /* EZP_PROD_CAT: "L" */
+#define PPTPD_SESSION_MAX 0	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "0"
+#define L2TPD_SESSION_MAX 0	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "0"
+#define IPSEC_RULE_MAX "0"
+#else
+#error "Undefined amount of LAN/WAN interfaces"
+#endif /* VPN */
+/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
+
+
+#define SUBCAT_MAX  7
+#define FW_UPGRADE_RULE "ftpget^192.168.100.178^^^^zyfw_info"
+
+/* WAN amount dependent definition. */
+#if ( WAN_NUM == 1 )
+#define WAN_MAIN_RULE "WAN1^1^1500^1^1^0"
+#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
+#define WAN_DETECT_RULE "^0^ping^^60^8"
+#define WAN_WEIGHT_RULE "1^1"
+#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^"
+#define WAN_DHCP_RULE "^^86400"
+#define WAN_HTC_RULE "^^86400^512^0"
+#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^"
+#define WAN_STATICV6_RULE "2001:db8:feed:b01::2^64^2001:db8:feed:b01::1^^"
+#define WAN_DHCPV6_RULE "^^86400^stateful"
+#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^"
+#define WAN_WWAN_RULE "1^0^0^internet^^auto^chap^^^0^300^20^20^1492^1492^*99***1#^0^0^0^0^0^0^1^0"
+#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap"
+#define WAN_DNS_RULE "ispdns^^ispdns^"
+#define WAN_DNSV6_RULE "ispdns^^ispdns^"
+#define WAN_WWAN_PROBE_RULE "^^^^^^^"
+#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
+#define WAN_BIGPOND_RULE "0^61.9.192.13^^"
+#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^"
+#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^"
+#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^"
+#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
+#define RT_RIP_RULE "none"
+#define NAT_RULE "1"
+#define FR_RULE ""
+#define FR_RULE_NUM "0"
+#define FR_DMZ_RULE "^0^"
+#define PT_RULE "^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0|^0^all^0^0^0^0"
+
+#elif ( WAN_NUM == 2 )
+#define WAN_MAIN_RULE "WAN1^1^1500^1^0^0|WAN2^1^1500^1^1^0"
+#define WAN_BW_RULE "A2M256K^2048^256^0^0^75^90^90^155^19^1244^155|A2M256K^2048^256^0^0^75^90^90^155^19^1244^155"
+#define WAN_DETECT_RULE "^0^ping^208.67.222.222^60^8|^0^ping^208.67.222.222^60^8"
+#define WAN_WEIGHT_RULE "1^1|1^1"
+#define WAN_FAILOVER_RULE "0^wan0^wan1"
+#define WAN_STATIC_RULE "10.1.1.25^24^10.1.1.254^10.1.1.254^^|10.1.2.25^24^10.1.2.254^10.1.2.254^^"
+#define WAN_DHCP_RULE "^^86400|^^86400"
+#define WAN_HTC_RULE "^^86400^512^0|^^86400^512^0"
+#define WAN_PPPOE_RULE "chap^^^0^300^5^5^1492^1492^isp^^|chap^^^0^300^5^5^1492^1492^isp^^"
+#define WAN_STATICV6_RULE "^^^^|^^^^"
+#define WAN_DHCPV6_RULE "^^86400^stateful|^^86400^stateful"
+#define WAN_PPPOEV6_RULE "^^^0^300^5^5^1492^1492^isp^|^^^0^300^5^5^1492^1492^isp^"
+#define WAN_PPTP_L2TP_RULE "^static^^^^^^1^300^isp^^disabled^chap|^static^^^^^^1^300^isp^^disabled^chap"
+#define WAN_DNS_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
+#define WAN_DNSV6_RULE "ispdns^^ispdns^|ispdns^^ispdns^"
+#define WAN_WWAN_PROBE_RULE "^^^^^^^|^^^^^^^"
+#define WAN_WWAN_MODE "auto", "hsdpa", "umts", "edge", "gprs"
+#define WAN_BIGPOND_RULE "0^61.9.192.13^^|0^61.9.192.13^^"
+#define WAN_HWADDR_CLONE_RULE "0^^hwaddr^|0^^hwaddr^"
+#define WAN_DDNS_RULE "WAN1_DDNS^0^dyndns^^^^|WAN2_DDNS^0^dyndns^^^^"
+#define WAN_OPENDNS_RULE "WAN1_OPENDNS^0^^^0^|WAN2_OPENDNS^0^^^0^"
+#define RT_RULE "SMTP^0^^^^^tcp^^^25^25^wan0^default^^^"
+#define RT_RIP_RULE "none"
+#define NAT_RULE "1"
+#define FR_RULE "HTTP^0^wan0^tcp^80^80^192.168.1.20^^|HTTPS^0^wan0^tcp^443^443^192.168.1.20^^|POP3^0^wan0^tcp^110^110^192.168.1.20^^|POP3S^0^wan0^tcp^995^995^192.168.1.20^^|SMTP^0^wan0^tcp^25^25^192.168.1.20^^|SMTPS^0^wan0^tcp^465^465^192.168.1.20^^|SSH^0^wan0^tcp^22^22^192.168.1.21^^|eMule^0^wan1^both^4662^4672^192.168.1.21^^"
+#define FR_RULE_NUM "8"
+#define FR_DMZ_RULE "^0^|^0^"
+
+#else
+#error "Undefined amount of WAN interface(s)"
+#endif
+
+/* LAN amount dependent definition. */
+#if ( LAN_NUM == 1 )
+    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0"
+    #define LAN_STATIC_RULE_DEFAULT "192.168.1.10^24^^192.168.1.10^^0^^^192.168.1.10^24^192.168.1.10^24"
+    #define LAN_HWADDR_CLONE_RULE "0^"
+#elif ( LAN_NUM == 2 )
+    #define LAN_MAIN_GUESTLAN "GuestLAN^0^1500^1^1^0"
+    #define LAN_MAIN_RULE "LAN1^1^1500^1^1^0|"LAN_MAIN_GUESTLAN
+    #define LAN_STATIC_GUESTLAN "192.168.100.1^24^^192.168.100.1^^0^^^192.168.100.1^24^192.168.1.2^24"
+    #define LAN_STATIC_RULE_DEFAULT "192.168.1.10^24^^192.168.1.10^^0^^^192.168.1.10^24^192.168.1.10^24|"LAN_STATIC_GUESTLAN
+    #define LAN_HWADDR_CLONE_RULE "0^"
+#else
+#error "Undefined amount of LAN interface(s)"
+#endif
+
+#if (WL_NUM > 0) /* WL_NUM is not zero. */
+
+#if ( WL_NUM == 1 )
+/* XXX: #define WL_BASIC_RULE "1^0^100^6^0" */
+#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
+#define WL_AP_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
+
+#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^1^HT^1^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
+#define WL_WDS_RULE "disabled^1"
+#define WL1_WDS_RULE "disabled^1"
+#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
+#define WL_MODE_RULE "ur^2^0"
+#define WL1_MODE_RULE "ur^2^0"
+#define WL_WPS_RULE "0^^0"
+#define WL1_WPS_RULE "0^^0"
+#define WL_WPS_STA_RULE "0^^^^^^"
+#define WL1_WPS_STA_RULE "0^^^^^^"
+#define WL_ACL_MAX "64"
+#define WL_ACL_BASIC_RULE "1^disabled"
+#elif ( WL_NUM == 2 )
+/* #define WL_BASIC_RULE "1^0^100^6^0|1^0^100^6^0" */
+#define WL_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
+#define WL_AP_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1^2000"
+
+#define WL1_ADVANCED_RULE "1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1|1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^0^0^0^0^0^0^1^1^0^33^5^0^1^64^0^1^0^1"
+#define WL_WDS_RULE "disabled^1|disabled^1"
+#define WL1_WDS_RULE "disabled^1|disabled^1"
+#define WL_WME_RULE "15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128|15 1023 7 0 0 off^15 1023 3 0 0 off^7 15 2 6016 3008 off^3 7 2 3264 1504 off^15 1023 7 0 0 off^15 63 3 0 0 off^7 15 1 6016 3008 off^3 7 1 3264 1504 off^off^128"
+#define WL_MODE_RULE "ur^0^0|ur^0^0"
+#define WL1_MODE_RULE "ur^0^0|ur^0^0"
+#define WL_WPS_RULE "0^^0|0^^0"
+#define WL1_WPS_RULE "0^^0|0^^0"
+#define WL_WPS_STA_RULE "0^^^^^^|0^^^^^^"
+#define WL1_WPS_STA_RULE "0^^^^^^|0^^^^^^"
+#define WL_ACL_MAX "64"
+#define WL_ACL_BASIC_RULE "1^disabled"
+#else
+#error "Undefined amount of WLAN interfaces"
+#endif
+
+#if ( WL_NUM == 1 )
+  /* WDS */
+  #define WL0_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
+  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
+  #define WL0_WDS_SEC_WEP_RULE "|||"
+  #define WL0_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
+  /* APCLI */
+  #define WL0_APCLI_RULE "1^CPE_2.4G^^disabled^0^0^0"
+  #define WL1_APCLI_RULE "1^CPE_5G^^disabled^0^0"
+  #define WL0_APCLI_SEC_WEP_RULE "1^^^^^^open"
+  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
+  #define WL0_APCLI_SEC_WPA_RULE "^tkip"
+  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
+  #define WL0_APCLI_SEC_WPA2_RULE "^aes"
+  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
+  #if (WL0_RULE_MAX == 2)
+    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
+    #define WL0_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
+    #define WL0_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
+  #elif (WL0_RULE_MAX == 4)
+    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
+    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^0|0^0^0^1^0|0^0^0^1^0"
+    #define WL0_SSID_RULE "CPE_2.4G|CPE_2.4G_SSID1|CPE_2.4G_SSID2|CPE_2.4G_SSID3"
+    #define WL5G_SSID_RULE "CPE_5G|CPE_5G_SSID1|CPE_5G_SSID2|CPE_5G_SSID3"
+    #define WL0_SEC_RULE "disabled|disabled|disabled|disabled"
+    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
+    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_WPA_RULE   "12345678^mixed^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
+    #define WL0_SEC_WPA2_RULE   "12345678^mixed^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
+    #define WL0_SEC_5G_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_5G_WPA_RULE   "12345678^mixed^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000|^tkip^^^1812^time^3600^5000^3000"
+    #define WL0_SEC_5G_WPA2_RULE   "12345678^mixed^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1|^aes^^^1812^time^3600^5000^0^10^3000^1"
+  #else
+/* default set visual interface number to 2 */
+    #define WL0_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL1_BASIC_RULE "1^0^0^1^0|0^0^0^1^1"
+    #define WL0_SSID_RULE "AXIMCom1|AXIMCom2"
+    #define WL0_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL0_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL0_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000^3000|^tkip^^^1812^disable^3600^5000^3000"
+    #define WL0_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^5000^0^10^3000^1|^aes^^^1812^disable^3600^5000^0^10^3000^1"
+  #endif
+#endif
+
+#if ( WL_NUM == 2 )
+  /* WDS */
+  #define WL1_WDS_BASIC_RULE "^disabled|^disabled|^disabled|^disabled"
+  #define WL1_WDS_SEC_WEP_RULE "|||"
+  #define WL1_WDS_SEC_WPA_RULE "^tkip|^tkip|^tkip|^tkip"
+  /* APCLI */
+  #define WL1_APCLI_RULE "1^^^disabled"
+  #define WL1_APCLI_SEC_WEP_RULE "1^^^^^^open"
+  #define WL1_APCLI_SEC_WPA_RULE "^tkip"
+  #define WL1_APCLI_SEC_WPA2_RULE "^aes"
+  #if (WL1_RULE_MAX == 2)
+    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL1_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
+    #define WL1_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
+  #elif (WL1_RULE_MAX == 4)
+    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6|AXIMCom7|AXIMCom8"
+    #define WL1_SEC_RULE "disabled|disabled|disabled|disabled"
+    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open|1^^^^^^open|1^^^^^^open"
+    #define WL1_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
+    #define WL1_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
+  #else
+    /* default set visual interface number to 2 */
+    #define WL1_SSID_RULE "AXIMCom5|AXIMCom6"
+    #define WL1_SEC_RULE "disabled|disabled"
+    #define WL1_SEC_WEP_RULE   "1^^^^^^open|1^^^^^^open"
+    #define WL1_SEC_WPA_RULE   "^mixed^^^1812^disable^3600^5000|^tkip^^^1812^disable^3600^5000"
+    #define WL1_SEC_WPA2_RULE   "^mixed^^^1812^disable^3600^0^10^3000|^aes^^^1812^disable^3600^0^10^3000"
+  #endif
+#endif
+#endif /* WL_NUM is not zero. */
+/* 
+ * The following macros are to stringify the macro argument. Please refer to
+ * "C Preprocessor - Stringification".
+ */
+#define xstr(s) str(s)
+#define str(s)  #s 
+
+#define QOS_CONFIG
+
+#ifdef QOS_CONFIG
+/*direct_multicast_status*/
+#define DIRECT_MULTICAST_STATUS_VALUE "1|1|1|1|1|1|1|1"
+/*direct_multicast_maxnum*/
+#define DIRECT_MULTICAST_MAXNUM_VALUE "10"
+/*cos_classification_status*/
+#define COS_CLASSIFICATION_STATUS_VALUE "0|0|0|0|0|0|0|0|0"
+/*tos_classification_status*/
+#define TOS_CLASSIFICATION_STATUS_VALUE "1|1|1|1|1|1|1|1|1|1|1|1"
+/*heuristics_classification_status*/
+#define HEURISTICS_CLASSIFICATION_STATUS_VALUE "1|1|1|1|1|1|1|1|1"
+/*bwm_level_dl_index*/
+#define BWM_LEVEL_DL_INDEX_VALUE "0|0|0|0|0|0|0|0"
+/*bwm_level_up_index*/
+#define BWM_LEVEL_UP_INDEX_VALUE "0|0|0|0|0|0|0|0"
+/*qos_rule_status*/
+#define QOS_RULE_STATUS_VALUE "0|0|0|0|0|0|0|0|0"
+/*qos_rule_active*/
+#define QOS_RULE_ACTIVE_DEFAULT_VALUE "0^0^0^0^0^0^0^0^0"
+#define QOS_RULE_ACTIVE_VALUE \
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE"|"\
+	QOS_RULE_ACTIVE_DEFAULT_VALUE
+/*bwm_level*/
+#define BWM_LEVEL_1 "512,512,1500,60,102,102,1500,10,256,461,1500,25,154,512,1500,25,1,1,1500,1"
+#define BWM_LEVEL_2 "1024,1024,2560,110,256,256,1500,10,512,922,1500,50,256,1024,1500,50,1,1,1500,1"
+#define BWM_LEVEL_3 "2048,2048,5120,110,256,256,1500,10,1536,1843,3840,50,256,2048,1500,50,1,1,1500,1"
+#define BWM_LEVEL_4 "2458,4096,6144,110,256,256,1500,10,1843,4096,4608,50,358,4096,1500,50,1,1,1500,1"
+#define BWM_LEVEL_5 "3686,6144,9216,110,256,256,1500,10,2765,6144,6912,50,666,6144,1664,50,1,1,1500,1"
+#define BWM_LEVEL_6 "4915,8192,12288,110,256,256,1500,10,3686,8192,9216,50,973,8192,2432,50,1,1,1500,1"
+#define BWM_LEVEL_7 "5120,10240,12800,110,256,256,1500,10,3840,10240,9600,50,1024,10240,2560,50,1,1,1500,1"
+#define BWM_LEVEL_8 "10240,20480,25600,110,512,512,1500,10,7168,20480,17920,50,2560,20480,6400,50,1,1,1500,1"
+#define BWM_LEVEL_9 "15360,30720,38400,110,512,512,1500,10,11520,30720,28800,50,3328,30720,8320,50,1,1,1500,1"
+#define BWM_LEVEL_10 "15565,40960,38912,110,512,512,1500,10,11674,40960,29184,50,3379,40960,8448,50,1,1,1500,1"
+#define BWM_LEVEL_11 "23347,61440,58368,110,512,512,1500,10,17510,61440,43776,50,5325,61440,13312,50,1,1,1500,1"
+#define BWM_LEVEL_12 "31130,81920,77824,110,512,512,1500,10,23347,81920,58368,50,7270,81920,18176,50,1,1,1500,1"
+#define BWM_LEVEL_13 "30720,102400,76800,110,1024,1024,1500,10,23040,102400,57600,50,6656,102400,16640,50,1,1,1500,1"
+#define BWM_LEVEL_14 "46080,153600,115200,110,1024,1024,1500,10,34560,153600,86400,50,10496,153600,26240,50,1,1,1500,1"
+#define BWM_LEVEL_15 "61440,204800,153600,110,1024,1024,1500,10,46080,204800,115200,50,14336,204800,35840,50,1,1,1500,1"
+#define BWM_LEVEL_16 ",,,,,,,,,,,,,,,,,,,"
+#define BWM_LEVEL_VALUE	\
+	BWM_LEVEL_1"|"\
+	BWM_LEVEL_2"|"\
+	BWM_LEVEL_3"|"\
+	BWM_LEVEL_4"|"\
+	BWM_LEVEL_5"|"\
+	BWM_LEVEL_6"|"\
+	BWM_LEVEL_7"|"\
+	BWM_LEVEL_8"|"\
+	BWM_LEVEL_9"|"\
+	BWM_LEVEL_10"|"\
+	BWM_LEVEL_11"|"\
+	BWM_LEVEL_12"|"\
+	BWM_LEVEL_13"|"\
+	BWM_LEVEL_14"|"\
+	BWM_LEVEL_15"|"\
+	BWM_LEVEL_16
+
+/*stream_priority*/
+/*voice^video^data^background*/
+#define STREAM_PRIORITY_VALUE "4^5^6^7"
+/*sta_priority*/
+#define STA_PRIORITY_DEFAULT_VALUE "none,1"
+#define STA_PRIORITY_VALUE \
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE"|"\
+	STA_PRIORITY_DEFAULT_VALUE
+
+/*qos_rule_record*/
+#define QOS_RULE_RECORD_DEFAULT_VALUE \
+    "none,none,none,none,none,none,none,none,none"
+#define QOS_RULE_RECORD_VALUE \
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE"|"\
+	QOS_RULE_RECORD_DEFAULT_VALUE
+
+/*igmp_snooping*/
+/*status^age*/
+#define IGMP_SNOOPING_VALUE "1^260"
+/*tos_classify*/
+/*voice^video^data^background*/
+#define TOS_CLASSIFY_VALUE "0xE0,0xC0,0xB8^0xA0,0x80^none^none^0^0"
+/*cos_classify*/
+/*voice^video^data^background*/
+#define COS_CLASSIFY_VALUE "none^none^none^none"
+/*heuristics_classify*/
+/*(d_count^b_count^ipg_min^ipg_max^pl_min^pl_max)*/
+#define VOICE_HEURISTICS_CLASSIFY	"600,10000,15,275,70,400"
+#define VIDEO_HEURISTICS_CLASSIFY	"50000,500000,0,65,1000,1518"
+#define DATA_HEURISTICS_CLASSIFY	"0,0,0,0,0,0"
+#define BACKGROUND_HEURISTICS_CLASSIFY	"0,0,0,0,0,0"
+#define HEURISTICS_CLASSIFY_VALUE	\
+	VOICE_HEURISTICS_CLASSIFY"^"\
+	VIDEO_HEURISTICS_CLASSIFY"^"\
+	DATA_HEURISTICS_CLASSIFY"^"\
+	BACKGROUND_HEURISTICS_CLASSIFY
+/*tos_mark*/
+#define TOS_MARK_VALUE "1^0x8^0x5^0x0^0x0"
+
+/*root_bw*/
+#define ROOT_BW_VALUE "307200^307200^307200"
+
+#endif
+
+static struct nvram_tuple nvram_ezpacket_default[] = {
+    { "fw_version", xstr(EZP_PROD_VERSION), 
+        NVRAM_NONE, 
+        0 
+    },   
+    /* Added for different customer's version definition. */
+    { "prod_fw_version", EZP_PROD_FW_VERSION, 
+        NVRAM_NONE, 
+        0 
+    },   
+    { "ifup_types", "lan wan", 
+        NVRAM_NONE, 
+        0 
+    },   
+    { "wan_num", xstr(WAN_NUM),     /* How many WAN interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wan_weight_type", "1", 
+        NVRAM_NONE,
+        0 
+    },   /* WAN weight type [0 (manual) |1 (auto) ] */
+
+#if (WAN_NUM >= 1)
+    /* WAN0 */
+    /* WAN H/W parameters */
+
+    { "wan0_ifname", WAN0_IFNAME, 
+        NVRAM_NONE,
+        0 
+    },    /* WAN interface name */
+    { "wan0_ifnames", WAN0_IFNAMES, 
+        NVRAM_NONE,
+        0 
+    },       /* WAN interface names */
+    { "wan0_hwname", WAN0_HWNAME, 
+        NVRAM_NONE,
+        0 
+    },        /* WAN driver name (e.g. et1) */
+    { "wan0_device", WAN0_DEVICE, 
+        NVRAM_NONE,
+        0 
+    },        /* WAN device name */
+    { "wan0_device_backup", WAN0_DEVICE, 
+        NVRAM_NONE,
+        0 
+    },        /* WAN device name */
+    { "psyslocation", "deskTop", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN driver name (e.g. et1) */
+    { "psyscontact", "everyone@local.com", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN device name */
+    { "psysservices", "sysservices^72", 
+        NVRAM_NONE,
+        0 
+    }, 
+    {"rip_mode","0",
+       NVRAM_NONE,
+       0
+
+    },       /*rip mode: 0 rip,1 ripng, 2 both*/
+ 	{"ripng_config","lan&wan",
+	   NVRAM_NONE,
+       0
+	},/*interface value:lan/wan/lan&wan*/
+    { "telnet_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },
+    { "telnet_port", "23", 
+        NVRAM_NONE,
+        0 
+    },
+    { "https_enable", "0", 
+        NVRAM_NONE,
+        0 
+    },
+    { "https_port", "443", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_ro_username", "admin", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_ro_passwd", "12345678", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_rw_username", "user", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_rw_passwd", "12345678", 
+        NVRAM_NONE,
+        0 
+    },
+    { "snmpd_ro_community", "private", 
+        NVRAM_NONE,
+        0 
+   },
+   { "snmpd_rw_community", "public", 
+        NVRAM_NONE,
+        0 
+   },
+   { "snmpd_trap_ipadress", "192.168.1.10", 
+        NVRAM_NONE,
+        0 
+   },
+	/* WAN device name */
+    /* MR routers use wwan as default*/
+#if defined(EZP_PROD_CAT_M) 
+    { "wan0_proto", "dhcp", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN proto */
+#else
+    { "wan0_proto", "dhcp", 
+        NVRAM_NONE,
+        0 
+    },        /* WAN proto */
+#endif
+    { "wan0_protov6", "link-local", 
+        NVRAM_NONE,
+        0 
+    },        /* IPv6 WAN proto */
+    { "wan0_rtmark", "0x10000000", 
+        NVRAM_NONE,
+        0 
+    }, /* WAN device routing mark. */
+    { "wan0_ports", WAN0_PORTS, 
+        NVRAM_NONE,
+        0 
+    }, /* WAN device port assignment. */
+    { "wan0_bw_mode", "auto",
+        NVRAM_NONE,
+        0
+    }, /* WAN DBM mode: auto/expert */
+
+    /* WAN temporary parameters */
+    { "wan0_ipaddr", "",
+       NVRAM_TEMP,
+       0 
+    },        /* WAN IP address */
+    /* WAN temporary parameters */
+    { "wan0_ipaddrv6", "",
+       NVRAM_TEMP,
+       0 
+    },        /* WAN IP address */
+    { "wan0_netmask", "",
+       NVRAM_TEMP,
+       0 
+    },       /* WAN netmask */
+    { "wan0_mask", "", 
+       NVRAM_TEMP,
+       0 
+    },          /* WAN netmask2 */
+    { "wan0_prefixv6", "", 
+       NVRAM_TEMP,
+       0 
+    },          /* WAN netmask2 */
+    { "wan0_maskv6", "", 
+       NVRAM_TEMP,
+       0 
+    },          /* WAN netmask2 */
+    { "wan0_gateway", "",
+       NVRAM_TEMP,
+       0 
+    },       /* WAN gateway */
+    { "wan0_gatewayv6", "",
+       NVRAM_TEMP,
+       0 
+    },       /* WAN gateway */
+    { "wan0_dns", "",
+       NVRAM_TEMP,
+       0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "wan0_dnsv6", "",
+       NVRAM_TEMP,
+       0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "wan0_wins", "",
+       NVRAM_TEMP,
+       0 
+    },          /* x.x.x.x x.x.x.x ... */
+    { "wan0_failcount", "",
+       NVRAM_TEMP,
+       0 
+    },          /* WAN detection failure count */
+    { "wan0_upnp_proto", "",
+       NVRAM_TEMP,
+       0 
+    },          /* WAN UPnP proto */
+    { "wan0_upnp_ifname", "",
+       NVRAM_TEMP,
+       0 
+    },          /* WAN UPnP ifname */
+    /* Because we have v4/v6 on the same device, we have to check both when
+     * trying to bring down an interface */
+    { "wan_up_down_state_rule", "0^0",
+       NVRAM_TEMP,
+       0 
+    },          /* v4^v6 */
+
+#endif
+
+    /* WAN main rules */
+    { "wan_main_rule", WAN_MAIN_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^mtu^stp^upnp */
+    /* WAN proto parameters rules */
+    { "wan_static_rule", WAN_STATIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* ipaddr^mask^gateway^dns1^dns2^wins */
+    { "wan_dhcp_rule", WAN_DHCP_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* hostname^domain^lease*/
+    { "wan_pppoe_rule", WAN_PPPOE_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* auth^username^passwd^demand^idletime^echo_failure^redialperiod^
+         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr^servname
+         */
+    /* V6 WAN proto parameters rules */
+    { "wan_staticv6_rule", WAN_STATICV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* ipaddr^length^gateway^dns1^dns2 */
+    { "wan_dhcpv6_rule", WAN_DHCPV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* hostname^domain^lease^type[0:stateless|1:stateful] */
+    { "wan_pppoev6_rule", WAN_PPPOEV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* username^passwd^servicename^
+         * demand^idletime^echo_failure^redialperiod^
+         * mru^mtu^pppiptype[isp|custom]^custom_ipaddr */
+#define WAN_TUNNEL6_RULE "72.52.104.74^2001:470:1f04:d1c::2/64^2001:470:1f04:d1c::1"
+    { "wan_tunnel6_rule", WAN_TUNNEL6_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* brokerv4addr^v6ipaddr_length^v6gateway */
+    { "wan_wwan_rule", WAN_WWAN_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
+         * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
+         * ctrltty^devname^flag^turbolink
+         */
+    /* wan_pptp_l2tp_rule */
+    { "wan_pptp_l2tp_rule", WAN_PPTP_L2TP_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* serverip^iptype[static|dhcp]^ipaddr^netmask^gateway^username^
+           passwd^nailup^timeout^pppiptype[isp|custom]^custom_ipaddr^
+           encmode[disabled|mppe]^auth[chap|pap|none] */
+    { "wan_wwan_probe_rule", WAN_WWAN_PROBE_RULE, 
+        NVRAM_TEMP,
+        0 
+    },  /* brand^model^signal^numtty^datatty^ctrltty^devname^flag */
+    { "wan_bigpond_rule", WAN_BIGPOND_RULE,
+        NVRAM_NONE,
+        0 
+    },  /* enable^server^username^passwd */
+    { "wan_dns_rule", WAN_DNS_RULE,
+        NVRAM_NONE,
+        0 
+    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
+    { "wan_dnsv6_rule", WAN_DNSV6_RULE,
+        NVRAM_NONE,
+        0 
+    },  /* dnstype1[ispdns|custom|none]^dns1^dnstype2[ispdns|custom|none]^dns2 */
+    /* WAN hwaddr */ 
+    { "wan_hwaddr_rule_default", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0
+    },  /* hwaddr */
+    /* WAN hwaddr clone */ 
+    { "wan_hwaddr_clone_rule", WAN_HWADDR_CLONE_RULE, 
+        NVRAM_NONE,
+        0
+    },  /* enable[0|1]^hwaddr^addrtype[ipaddr|hwaddr]^ipaddr */
+    /* DDNS */
+    { "wan_ddns_rule", WAN_DDNS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^type[dyndns|tzo|zoneedit]^username^
+           passwd^hostname */
+    /* OpenDNS */
+    { "wan_opendns_rule", WAN_OPENDNS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^username^passwd^redirect[0|1]^label */
+    /* WAN status rule */
+    { "wan_st_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* WAN status rule */
+    { "wan_stv6_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* LAN status rule */
+    { "lan_st_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* LAN status rule */
+    { "lan_stv6_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    /* WLAN status rule */
+    { "wlan_st_rule", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* uptime */
+    { "lan_num", xstr(LAN_NUM), 
+        NVRAM_NONE,
+        0 
+    },  /* How many LAN interfaces are available.*/
+#if LAN_NUM >= 1
+    /* LAN0 */
+    /* LAN H/W parameters */
+
+    { "lan0_ifname", LAN0_IFNAME, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN interface name */
+    { "lan0_ifnames", LAN0_IFNAMES, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN interface names */
+    { "lan0_hwname", LAN0_HWNAME, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN driver name (e.g. et1) */
+    { "lan0_device", LAN0_DEVICE, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN device name */
+    { "lan0_proto", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN device name */
+    { "lan0_protov6", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN IPv6 device name */
+    { "lan0_ports", LAN0_PORTS, 
+        NVRAM_NONE,
+        0 
+    }, /* LAN device port assignment. */
+
+    /* LAN temporary parameters */
+    { "lan0_ipaddr", "", 
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IP address */
+    /* LAN temporary parameters */
+    { "lan0_ipaddrv6", "2001:db8:feed:b00::1",
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IPv6 address */
+    { "lan0_netmask", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN netmask */
+    { "lan0_mask", "", 
+       NVRAM_TEMP,
+        0 
+    },
+    /* LAN netmask2 */
+    { "lan0_prefixv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 prefix */
+    { "lan0_maskv6", "64", 
+       NVRAM_TEMP,
+        0 
+    },          /* LAN IPv6 netmask2 */
+    { "lan0_gateway", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN gateway */
+    { "lan0_gatewayv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 gateway */
+    { "lan0_dns", "", 
+       NVRAM_TEMP,
+        0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "lan0_wins", "", 
+       NVRAM_TEMP,
+        0 
+    },          /* x.x.x.x x.x.x.x ... */
+#if LAN_NUM >= 2
+    /* LAN0 */
+
+    { "lan1_ifname", LAN1_IFNAME, 
+        NVRAM_NONE,
+        0 
+    },  /* LAN interface name */
+    { "lan1_proto", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN device name */
+    { "lan1_protov6", "static", 
+        NVRAM_NONE,
+        0 
+    },  /* LAN IPv6 device name */
+    /* LAN temporary parameters */
+    { "lan1_ipaddr", "", 
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IP address */
+    { "lan1_ipaddrv6", "2001:db8:feed:b00::1",
+       NVRAM_TEMP,
+        0 
+    },        /* LAN IPv6 address */
+    { "lan1_netmask", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN netmask */
+    { "lan1_mask", "", 
+       NVRAM_TEMP,
+        0 
+    },          /* LAN netmask2 */
+    { "lan1_prefixv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 prefix */
+    { "lan1_maskv6", "64", 
+       NVRAM_TEMP,
+        0 
+    },          /* LAN IPv6 netmask2 */
+    { "lan1_gateway", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN gateway */
+    { "lan1_gatewayv6", "", 
+       NVRAM_TEMP,
+        0 
+    },       /* LAN IPv6 gateway */
+    { "lan1_dns", "", 
+       NVRAM_TEMP,
+        0 
+    },           /* x.x.x.x x.x.x.x ... */
+    { "lan1_wins", "", 
+       NVRAM_TEMP,
+        0 
+    },          /* x.x.x.x x.x.x.x ... */
+#endif /* LAN_NUM >= 2*/
+#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
+    { "vlan_rule", VLAN_RULE,
+       NVRAM_NONE,
+        0 
+    },      /* name^enable[0|1]^ifname^vid^portmember^flag */
+    { "vlan_rule_num", xstr(VLAN_RULE_NUM),
+       NVRAM_NONE,
+        0 
+    },      
+    { "vlan_rule_max", xstr(VLAN_RULE_MAX),
+       NVRAM_NONE,
+        0 
+    },
+    { "vlanport_rule", VLANPORT_RULE,
+       NVRAM_NONE,
+        0 
+    },       /* name^portid^pvid^tag^gmemb */
+    { "vlanport_rule_num", xstr(VLANPORT_RULE_NUM),
+       NVRAM_NONE,
+        0 
+    },      
+    { "vlanport_rule_max", xstr(VLANPORT_RULE_MAX),
+       NVRAM_NONE,
+        0 
+    },
+    { "br_rule", BR_RULE,
+       NVRAM_NONE,
+        0
+    },      /* name^enable[0|1]^ifnames^flag */
+    { "br_rule_num", xstr(BR_RULE_NUM),
+       NVRAM_NONE,
+        0
+    },
+    { "br_rule_max", xstr(BR_RULE_MAX),
+       NVRAM_NONE,
+        0
+    },
+#ifdef CONFIG_EZP_ARCH_RT305X
+    NVRAM_EZPACKET_DEFAULT_RT305X_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_2
+#endif
+#elif defined(CONFIG_EZP_ARCH_RT3883)
+    NVRAM_EZPACKET_DEFAULT_RT3883_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_2
+#endif
+#endif
+#endif
+
+#ifdef CONFIG_EZP_ARCH_BRCM
+    NVRAM_EZPACKET_DEFAULT_BRCM_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_BRCM_WAN_NUM_2
+#endif
+#endif
+#endif
+
+#ifdef CONFIG_EZP_ARCH_AS500
+    NVRAM_EZPACKET_DEFAULT_AS500_LAN_NUM_1
+    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_1
+#if (WAN_NUM == 2)
+    NVRAM_EZPACKET_DEFAULT_AS500_WAN_NUM_2
+#endif
+    NVRAM_EZPACKET_DEFAULT_AS500_SWAP
+    NVRAM_EZPACKET_DEFAULT_AS500_INITD
+#endif
+
+    { "lan_main_rule", LAN_MAIN_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^mtu^stp^weight */
+    { "lan_hwaddr_rule_default", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0
+    },  /* hwaddr */
+    { "lan_static_rule_default", LAN_STATIC_RULE_DEFAULT, 
+        NVRAM_NONE,
+        0 
+    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
+    { "lan_static_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    },  /* ipaddr^mask^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+           ipaddr_normal^mask_normal^ipaddr_ap^mask_ap  */
+    { "lan_staticv6_rule_default", LAN_STATICV6_RULE_DEFAULT, 
+        NVRAM_NONE,
+        0 
+    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
+         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
+    { "lan_staticv6_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    },  /* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
+         * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+         * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
+    /* DHCP server parameters */
+    { "lan_dhcps_rule", LAN_DHCPS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^start^num^lease^domain^wins^
+           dnstype[ispdns|opendns|custom|none]^dnsaddr1^
+           dnsaddr2^dnsaddr3^dnsaddr4^dnstype2^dnstype3^dnstype4 */
+    /* LAN hwaddr clone */
+    { "lan_dhcpsv6_rule", LAN_DHCPSV6_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^pppoe_prefix^static_prefix^dhcp_prefix^
+           domain^
+           dnstype[auto|custom]^
+           dnsaddr1^dnsaddr2^type[1|0]^
+           start^end^lifetime" */
+    /* LAN hwaddr clone */
+    { "lan_hwaddr_clone_rule", LAN_HWADDR_CLONE_RULE, 
+        NVRAM_NONE,
+        0
+    },  /* enable[0|1]^hwaddr[XX:XX:XX:XX:XX:XX] */
+    /* Guest lan rule */
+#define GUEST_LAN_RULE "0^rai3^br2^1^192.168.2.1^24^0^0^1^liteon_guest.com^33^32"
+    { "guest_lan_rule", GUEST_LAN_RULE,
+        NVRAM_NONE,
+        0
+    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
+         * domain : domain name for this dns group
+         * start : dhcp offering start ip address
+         * count : total count dhcp server can offer
+         * */
+#define GUEST_5G_LAN_RULE "0^ra3^br2^1^192.168.2.1^24^0^0^1^liteon_5g_guest.com^33^32"
+    { "guest1_lan_rule", GUEST_5G_LAN_RULE,
+        NVRAM_NONE,
+        0
+    },  /* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
+         * domain : domain name for this dns group
+         * start : dhcp offering start ip address
+         * count : total count dhcp server can offer
+         * */
+    /* MASK */
+    { "rt_mask", "0xF0000000", 
+        NVRAM_NONE,
+        0 },      /* Routing mask: 4-bit */
+    { "reserved_mask", "0x0F000000", 
+        NVRAM_NONE,
+        0 },      /* Reserved mask: 4-bit */
+    { "fl_mask", "0x0000FFFF", 
+        NVRAM_NONE,
+        0 },      /* FL mask: 16-bit */
+    { "fl_mark_default", "0x0000FFFF", 
+        NVRAM_NONE,
+        0 },      /* FL mask: 16-bit */
+
+    /* turboNAT */
+    { "turbonat_enable", "0", 
+        NVRAM_NONE,
+        0 
+    },   /* enable [0|1] */
+    /* Session Manager */
+    { "sm_mode", "fast", 
+        NVRAM_NONE,
+        0 
+    },   /* mode [fast|regular|slow] */
+    /* Bandwidth */
+    /*{ "bw_rule", BW_RULE,*/
+    { "bw_rule", "0^32768^32768",
+        NVRAM_NONE,
+        0 
+    },   /* enable^bw_upload^bw_download */
+    { "bw_monitor_rule", "1",
+        NVRAM_NONE,
+        0 
+    },   /* enable */
+    { "bw_tc_mask", "0x00FF0000", 
+        NVRAM_NONE,
+        0 
+    },   /* BW mask */
+    /* SBM */
+    { "bw_sbm_mask", "0x00FF0000", 
+        NVRAM_NONE,
+        0 
+    },   /* BW mask */
+    /*{ "bw_app_rule", BW_APP_RULE, */
+    /* Easy mode */
+    { "bw_ezmodesort_rule", "Game Console|VoIP|Instant Messenger|Web Surfing|P2P/FTP|E-Mail",
+        NVRAM_NONE,
+        0 
+    },   /* catname */
+    { "bw_ezmodesort_rule_num", "6", 
+        NVRAM_NONE,
+        0 
+    },
+    { "bw_ezmodesort_rule_max", "6", 
+        NVRAM_NONE,
+        0 
+    },
+    { "bw_app_rule_num", "11",
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+    { "bw_app_rule_max", "32", 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+#define XBOX_APP "appl^0^1^1^Game Console^XBox Live^3074,3390,3932,5555^88,1900,3074,3776,3777^1^50^1^1^50^1^1^10^1^1^10^1"
+#define PLAYSTATION_APP "appl^0^1^1^Game Console^PlayStation^5223^3478,3479,3658,4658^1^50^1^1^50^1^1^10^1^1^10^1"
+#define MSN_GAME_APP "appl^0^1^1^Game Console^MSN Game Zone^6667,28800:29000^6667,28800:29000^1^50^1^1^50^1^1^10^1^1^10^1"
+#define BATTLENET_APP "appl^0^1^1^Game Console^Battlenet^40,112,6112,4000,6113:9119^^1^50^1^0^50^1^1^10^1^0^10^1"
+#define VOIP_APP "appl^0^1^1^VoIP^VoIP^5060^5060^1^50^1^0^50^1^1^10^1^0^10^1"
+#define IM_APP "appl^0^1^1^Instant Messenger^Instant Messenger^6891:6901,1863^1863,5190,6901^1^50^1^0^50^1^1^10^1^0^10^1"
+#define WEB_APP "appl^0^1^1^Web Surfing^Web Surfing^80,443^^1^50^1^0^50^1^1^10^1^0^10^1"
+#define FTP_APP "appl^0^1^1^P2P/FTP^FTP^21,22^^1^50^1^0^50^1^1^10^1^0^10^1"
+#define EMULE_APP "appl^0^1^1^P2P/FTP^eMule^4662^4672^1^50^1^0^50^1^1^10^1^0^10^1"
+#define BT_APP "appl^0^1^1^P2P/FTP^BitTorrent^tport^uport^1^50^1^1^50^1^1^10^1^1^10^1"
+#define EMAIL_APP "appl^0^1^1^E-Mail^E-Mail^110,995,25,465,587,220,143,993^^1^50^1^0^50^1^1^10^1^0^10^1"
+    { "bw_app_rule", XBOX_APP"|"PLAYSTATION_APP"|"MSN_GAME_APP"|"BATTLENET_APP"|"VOIP_APP"|"IM_APP"|"WEB_APP"|"FTP_APP"|"EMULE_APP"|"BT_APP"|"EMAIL_APP,
+        NVRAM_NONE,
+        0 
+    }, /* name^enable^index^prio^cat^serv^
+          tcp_port[port|port_beg:port_end]^
+          udp_port[port|port_beg:port_end]^
+          lan_tcp_enable^lan_tcp_bw^lan_tcp_min[0:max bw|1:min bw]^
+          lan_udp_enable^lan_udp_bw^lan_udp_min[0:max bw|1:min bw]^
+          wan_tcp_enable^wan_tcp_bw^wan_tcp_min[0:max bw|1:min bw]^
+          wan_udp_enable^wan_udp_bw^wan_udp_min[0:max bw|1:min bw] */
+#define ACCESS1 "access^ROGROUP^\"\"^any^noauth^exact^all^none^none"
+#define ACCESS2 "access^RWGROUP^\"\"^any^noauth^exact^all^all^all"
+    { "snmpd_access_rule", ACCESS1"|"ACCESS2,
+        NVRAM_NONE,
+        0 
+    }, 
+#define GROUP1 "group^RWGROUP^v1^rw"
+#define GROUP2 "group^RWGROUP^v2c^rw"
+#define GROUP3 "group^RWGROUP^usm^rw"    
+#define GROUP4 "group^ROGROUP^v1^ro"
+#define GROUP5 "group^ROGROUP^v2c^ro"
+#define GROUP6 "group^ROGROUP^usm^ro"    
+	{ "snmpd_group_rule", GROUP1"|"GROUP2"|"GROUP3"|"GROUP4"|"GROUP5"|"GROUP6,
+        NVRAM_NONE,
+        0 
+    }, 
+	{ "snmpd_view_rule", "view^all^included^.1^80",
+        NVRAM_NONE,
+        0 
+    }, 
+    { "bw_sbm_rule", BW_SBM_RULE,
+        NVRAM_NONE,
+        0 
+    }, /* name^enable^inipaddr_start^inipaddr_end^proto^extif^
+          bw_towan^bw_tolan^apptype^prio^
+          outipaddr_start^outipaddr_end^inport^outport^reserve_bw */
+    { "bw_sbm_rule_num", BW_SBM_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+    { "bw_sbm_rule_max", BW_SBM_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing BW rules */
+    /* Policy-based routing */
+    { "rt_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },   /* Routing [0|1] */
+    //{ "rt_rule", RT_RULE, 
+    { "rt_rule", "",
+        NVRAM_EMPTY,
+        0 
+    }, /* name^enable[0|1]^srcipaddr_start^srcipaddr_end^dstipaddr_start^
+          dstipaddr_end^proto^srcport_start^srcport_end^dstport_start^
+          dstport_end^extif^routing_type[default|static]^gateway_ipaddr^
+          netmask^matric */
+    //{ "rt_rule_num", "1",
+    { "rt_rule_num", "0",
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing RT rules */
+    { "rt_rule_max", RT_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing RT rules */
+
+    /*  routing */
+    { "rt_conn_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },   /* Routing cache [0|1] */
+    { "rt_rip_rule", RT_RIP_RULE, 
+        NVRAM_NONE,
+        0 
+    }, /* rip[v1/v2/none] */
+    { "nat_rule", NAT_RULE, 
+        NVRAM_NONE,
+        0 
+    }, /* enable */
+#if defined(CONFIG_EZP_ARCH_RT305X) || defined(CONFIG_EZP_ARCH_RT3883)
+    { "hwnat_rule", HWNAT_RULE, 
+        NVRAM_NONE,
+        0 
+    }, /* enable */
+#endif
+    /* web url/content filtering rule */
+    { "wf_enable", "1",
+        NVRAM_NONE,
+        0
+    }, /* web url filtering [0|1] */
+    { "wf_content_rule", "0^0^0^0^0^",
+        NVRAM_NONE,
+        0
+    }, /* activex_enable^java_enable^proxy_enable^cookie_enable^url_enable^trustipaddr */
+    { "wf_rule", "",
+        NVRAM_EMPTY,
+        0
+    }, /* enable^keyword^type^access */
+    { "wf_rule_num", "0",
+        NVRAM_NONE,
+        0
+    },
+    { "wf_rule_max", WF_RULE_MAX,
+        NVRAM_NONE,
+        0
+    },
+    /* IGMP related rule */
+    { "igmp_proxy_rule", IGMP_PROXY_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* enable */
+    { "igmp_snoop_rule", IGMP_SNOOP_RULE, 
+        NVRAM_NONE,
+        0 
+    },   /* enable^p1^p2^p3^p4 */
+    /* Schedule rule */
+    { "sched_enable", "0", 
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    { "sched1_enable", "0", // for 5g
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    /* Schedule rule */
+    { "sched_enable_bak", "0", 
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    { "sched1_enable_bak", "0", // for 5g
+        NVRAM_NONE,
+        0 
+    },       /* Enable/Disable scheduling function  */
+    { "sched_rule", SCHED_RULE,
+        NVRAM_NONE,
+        0 
+    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
+         /* cat:   category, which will cause invoking action
+          * month: apply month
+          * date:  apply date of month
+          * wkday: apply day of week
+          * beghr,begmin: begin hour and minute of day
+          * endhr,endmin: end hour and minute of day
+          * wlanstatus: wlan status
+          */
+    { "sched1_rule", SCHED1_RULE,
+        NVRAM_NONE,
+        0 
+    },   /* name^enable[0|1]^cat^month^date^wkday^beghr^bmin^endhr^endmin */
+         /* cat:   category, which will cause invoking action
+          * month: apply month
+          * date:  apply date of month
+          * wkday: apply day of week
+          * beghr,begmin: begin hour and minute of day
+          * endhr,endmin: end hour and minute of day
+          * wlanstatus: wlan status
+          */
+    { "sched_rule_num", SCHED_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+    { "sched_rule_max", SCHED_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+    { "sched1_rule_num", SCHED1_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+    { "sched1_rule_max", SCHED1_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },       /* The amount of existing sched rules */
+
+    { "fw_upgrade_rule", FW_UPGRADE_RULE,
+        NVRAM_NONE,
+        0 
+    },   /* method^server^path^username^passwd^inf_filename */
+         /* rule set 0 for default online firmware upgrade settings */
+    { "fw_info_rule", "",
+        NVRAM_TEMP,
+        0 
+    },   /* model^version^revision^date^size^filename^release_note^
+            info_ok[1:got fw info | 0:no info]^
+            fw_ok[1:got fw | 0:no fw]^
+            relnote_ok[1:got release note | 0:no release note] */
+         /* rule set 0 for default online firmware upgrade settings */
+    
+    /* RRDCOLLECT */
+    { "rrd_enable", "0", 
+        NVRAM_NONE,
+        0 },    /* RRDcollect client */
+
+    /* Cron */
+    { "cron_rule", "1^1^02 4 * * *", 
+        NVRAM_NONE,
+        0 
+    }, /* enable^ntp_enable[0|1]^ntp_interval */
+
+    /* NTP */
+    //{ "ntp_rule", "^1^pool^pool.ntp.org^^UTC-8^^^^^^^^^^^^^^",
+    { "ntp_rule", "^1^pool^pool.ntp.org^^GMT0BST,M3.5.0/2,M10.5.0/2^0^^^^^^^0^^^^^^^^0^", 
+        NVRAM_NONE,
+        0 
+    }, /* name^enable[0|1]^type^pool^ipaddr^zone^
+          custom_time[0|1]^year^mon^date^hour^min^sec^
+          daylight_saving[0|1]^
+          ds_start_mon^ds_start_day^ds_start_hour^
+          ds_end_mon^ds_end_day^ds_end_hour^customized^
+          custom_server[0|1]^serv_ipaddr */
+
+    /* SSH */
+    { "ssh_rule", "^1^8123", 
+        NVRAM_NONE,
+        0 
+    },       /* name^enable[0|1]^port */
+
+/* Added by Abocom */
+    /* log parameters */
+    { "log_selected_num", "9", 
+        NVRAM_NONE,
+        0 
+    },        /* Log selection number */
+    { "log_index", "show_all", 
+        NVRAM_NONE,
+        0 
+    },
+    /* Log Index */    
+    { "log_rule", LOG_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^ipaddr^ipt_enable^web_mgmt^dns^ppp^
+           upnp^wireless^ntp^sys_warning^dhcp_serv^dhcp_cli^
+           ddns^firewall */
+    /* uPnP */
+    { "upnp_rule", "^1^0^wan0^lan0^5555", 0 },
+    /* name^enable[0|1]^pmp_enable[0|1]^extif^inif^port */
+
+    /* Filters */
+    { "fl_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },    /* fl_enable [0|1] */
+    { "fl_rule", FL_RULE, 
+        NVRAM_EMPTY,
+        0 
+    },    /* name^enable[0|1]^extif^inif^proto^srcip^srcmask^
+                                dstip^dstmask^srcport^dstport^
+                                action[0(DROP)|1(ACCEPT)]^mark^bw_idx^
+                                sched_idx */
+
+    { "fl_rule_num", FL_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },      /* The amount of existing log rules */
+    { "fl_rule_max", FL_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },
+    { "fl_rule_default", "1", 
+        NVRAM_NONE,
+        0 
+    },
+
+    { "fl_hwaddr_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },    /* fl_hwaddr_enable [0|1] */
+    { "fl_hwaddr_rule", "", 
+        NVRAM_EMPTY,
+        0 
+    },    /* name^acl_enable[0|1]^dhcp_enable^arp_enable^hwaddr^
+             action[0(DROP)|1(ACCEPT)]^ipaddr */
+    { "fl_hwaddr_rule_num", "0", 
+        NVRAM_NONE,
+        0 
+    }, /* The amount of existing fl_hwaddr rules */
+    { "fl_hwaddr_rule_max", FL_HWADDR_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },
+    { "fl_hwaddr_rule_default", "1", 
+        NVRAM_NONE,
+        0 
+    },
+
+    /* Port forwards */
+    { "fr_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },  /* fr_enable [0|1] */
+    { "fr_rule", FR_RULE, 
+        NVRAM_EMPTY,
+        0 
+    },  /* name^enable[0|1]^extif^proto[tcp|udp|both]^extport_start^extport_end^ipaddr^inport_start^inport_end */
+    { "fr_rule_num", FR_RULE_NUM, 
+        NVRAM_NONE,
+        0 
+    },      /* fr_rule_num */
+    { "fr_rule_max", FR_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },      /* fr_rule_max */
+    { "fr_dmz_rule", FR_DMZ_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable[0|1]^ipaddr */
+
+    /* Port triggle */
+    { "pt_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },  /* pt_enable [0|1] */
+    { "pt_rule", PT_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable^proto[tcp|udp|all]^port_start^port_end^trig_port_start^trig_port_end */
+    { "pt_rule_num", "12", 
+        NVRAM_NONE,
+        0 
+    },  /* pt_rule_num */
+    { "pt_rule_max", PT_RULE_MAX, 
+        NVRAM_NONE,
+        0 
+    },  /* pt_rule_max */
+
+#if ( WL_NUM > 0 )
+    /* Wireless interface */
+    { "wl_num", xstr(WL_NUM), 
+        NVRAM_NONE,
+        0 
+    },      /* Enable (1) or disable (0) radio */
+    /* Wireless parameters */
+    { "wl_region_default", "0", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },      /* Region code default */
+    { "wl_region", "", 
+        NVRAM_DEFAULT,
+        0 
+    },      /* Region code */
+    { "wl_countrycode_default", WL_COUNTRY_CODE, 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },      /* Region code */
+    { "wl_countrycode", WL_COUNTRY_CODE, 
+        NVRAM_DEFAULT,
+        0 
+    },      /* Region code */
+    { "wl_regionaband_default", WL_REGION_ABAND, 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },      /* Region code */
+    { "wl_regionaband", "", 
+        NVRAM_DEFAULT,
+        0 
+    },      /* Region code */
+    { "wl_ieee80211h", "1", 
+        NVRAM_DEFAULT,
+        0 
+    },      /* IEEE802.11H */
+    /* Physical interface related rules*/
+    { "wl_rule_num", xstr(WL_NUM),     /* How many WLan interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl_rule_max", xstr(WL_NUM),     /* How many WLan interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    /* Virtual interface related rules for wl0/wl1... */
+    { "wlv_rule_num", xstr(WL0_RULE_NUM) ,     /* How many virtual wl0 interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wlv_rule_max", xstr(WL0_RULE_MAX),     /* Max virtual wl0 interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl_enabled_rule", "0", 
+        NVRAM_TEMP,
+        0 
+    },      /* Enable (1) or disable (0) radio */
+    /* This setting reserved the must original wireless setting
+     * such as hardware button status. Some application ,like schedular, 
+     * may change the wifi at run time. We can use this setting to restore
+     * the original setting. 
+     * Currently, only /sbin/ezp-wifionoff may change its value */
+    { "wl_origset_rule", "1",
+        NVRAM_NONE,
+        0 
+    },      /* enable */
+    { "wl1_origset_rule", "1",
+        NVRAM_NONE,
+        0 
+    },      /* enable  for 5g */
+    { "wl_basic_rule", WL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^net_mode^txpower^channel^bisolation */
+    { "wl_ap_basic_rule", WL_AP_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^net_mode^txpower^channel^bisolation */
+    { "wl5g_basic_rule", WL5G_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^net_mode^txpower^channel^bisolation */
+	{ "wl_ap_advanced_rule", WL_AP_ADVANCED_RULE, 
+        NVRAM_NONE,
+        0 
+    },
+	{ "wl_advanced_rule", WL_ADVANCED_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
+               gmode^gmode_protection^afterburner^frameburst^
+               txburst[0:disable|1:enable->1]^
+               pktaggr[0:disable|1:enable->0]^
+               txmode[0:None|1:CCK|2:OFDM->0]^
+
+               rdg[0:disable|1:enablei->0]^
+               linkadapt[0:disable|1:enable->0]^
+               htc[0:disable|1:enable->0]^
+
+               htbw[0:20|1:20/40->1]^
+               gi[0:long|1:short->1]^
+               opmode[0:mixed|1:GreenField->0]^
+               mcs[0~15,32,33=auto->33]^
+               mpdu[0 none, 1~7 -> 5]^
+               amsdu[0:disable|1:enable->0]^
+
+               autoba[0:disable|1:enable->1]^
+               bawinsize[1~64,default=8,iot=64->64]^
+               badecline[0:disable|1:enable->1->0]^
+               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
+               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
+             */
+    { "wl1_advanced_rule", WL1_ADVANCED_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^antdiv^
+               gmode^gmode_protection^afterburner^frameburst^
+               txburst[0:disable|1:enable->1]^
+               pktaggr[0:disable|1:enable->0]^
+               txmode[0:None|1:CCK|2:OFDM->0]^
+
+               rdg[0:disable|1:enablei->0]^
+               linkadapt[0:disable|1:enable->0]^
+               htc[0:disable|1:enable->0]^
+
+               htbw[0:20|1:20/40->1]^
+               gi[0:long|1:short->1]^
+               opmode[0:mixed|1:GreenField->0]^
+               mcs[0~15,32,33=auto->33]^
+               mpdu[0 none, 1~7 -> 5]^
+               amsdu[0:disable|1:enable->0]^
+
+               autoba[0:disable|1:enable->1]^
+               bawinsize[1~64,default=8,iot=64->64]^
+               badecline[0:disable|1:enable->1->0]^
+               extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
+               => 1^ap^default^0^2346^2346^1^100^0^1^1^off^off^off^1^0^0^0^0^0^1^1^0^33^5^0^1^64^0^0^0
+             */
+    { "wl_wds_rule", WL_WDS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
+    { "wl1_wds_rule", WL1_WDS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode^timeout */  /*mode: disabled/bridge/repeater*/
+    { "wl_wme_rule", WL_WME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* sta_bk^Sta_be^sta_vi^sta_vo^ap_bk^ap_be^ap_vi^ap_vo^no_ack^max_assoc */
+    { "wl_mode_rule", WL_MODE_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[normal|ap|ur|wisp]^
+             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
+             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
+    { "wl1_mode_rule", WL1_MODE_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[normal|ap|ur|wisp]^
+             * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
+             * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
+    { "wl_wps_rule", WL_WPS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
+    { "wl1_wps_rule", WL1_WPS_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
+    { "wl_wps_sta_rule", WL_WPS_STA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
+    { "wl1_wps_sta_rule", WL1_WPS_STA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
+    { "wl_led_status_rule", "9^9",
+        NVRAM_TEMP,
+        0 
+    },      /* wl^wps */
+    { "wl0_basic_rule", WL0_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^hidden^rate^wme^isolation */
+    { "wl1_basic_rule", WL1_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^hidden^rate^wme^isolation */
+    { "wl0_ifname_rule", WL0_IFNAME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl0_ssid_rule", WL0_SSID_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl1_ssid_rule", WL5G_SSID_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl0_sec_rule", WL0_SEC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* secmode */
+    { "wl0_sec_wep_rule", WL0_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^
+               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl0_sec_wpa_rule", WL0_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^session_timeout */
+    { "wl0_sec_wpa2_rule", WL0_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
+    { "wl1_sec_rule", WL1_SEC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* secmode */
+    { "wl1_sec_wep_rule", WL0_SEC_5G_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^
+               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl1_sec_wpa_rule", WL0_SEC_5G_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^session_timeout */
+    { "wl1_sec_wpa2_rule", WL0_SEC_5G_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
+/* acl policy can apply to each ssid, we add rule according to ssid number */
+#if (WL0_RULE_MAX >= 1)
+    { "wl00_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl00_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl00_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl00_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 2)
+    { "wl01_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl01_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl01_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl01_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 4)
+    { "wl02_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl02_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl02_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl02_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+    { "wl03_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl03_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl03_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl03_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#endif /* WL0_RULE_MAX >= 4 */
+#endif /* WL0_RULE_MAX >= 2 */
+#endif /* WL0_RULE_MAX >= 1 */
+/*  5g acl policy can apply to each ssid, we add rule according to ssid number */
+#if (WL0_RULE_MAX >= 1)
+    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl10_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl10_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl10_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 2)
+    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl11_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl11_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl11_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 4)
+    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl12_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl12_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl12_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl13_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl13_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl13_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#endif /* WL0_RULE_MAX >= 4 */
+#endif /* WL0_RULE_MAX >= 2 */
+#endif /* WL0_RULE_MAX >= 1 */
+#if 0
+#if ( WL_NUM >= 2 )
+    { "wl1_basic_rule", WL1_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^hidden^rate^wme^isolation */
+    { "wl1_ifname_rule", WL1_IFNAME_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ifname */
+    { "wl1_ssid_rule", WL1_SSID_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* ssid */
+    { "wl1_sec_rule", WL1_SEC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* secmode */
+    { "wl1_sec_wep_rule", WL1_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^
+               keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl1_sec_wpa_rule", WL1_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^session_timeout */
+    { "wl1_sec_wpa2_rule", WL1_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+               rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout^wpacap */
+/* acl policy can apply to each ssid, we add rule according to ssid number */
+#if (WL0_RULE_MAX >= 1)
+    { "wl10_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl10_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl10_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl10_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 2)
+    { "wl11_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl11_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl11_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl11_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#if (WL0_RULE_MAX >= 4)
+    { "wl12_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl12_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl12_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl12_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+    { "wl13_acl_basic_rule", WL_ACL_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^defpolicy */
+    { "wl13_acl_num", "0", 
+        NVRAM_NONE,
+        0 
+    },      /* number of acl mac list */
+    { "wl13_acl_max", xstr(WL_ACL_MAX), 
+        NVRAM_NONE,
+        0 
+    },      /* max number of acl mac list */
+    { "wl13_acl_rule", "", 
+        NVRAM_NONE,
+        0 
+    },      /* name^enable^mac^policy */
+#endif /* WL0_RULE_MAX >= 4 */
+#endif /* WL0_RULE_MAX >= 2 */
+#endif /* WL0_RULE_MAX >= 1 */
+#endif /* WL_NUM >= 2 */
+#endif
+    /* wds related rules */
+    { "wl0_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_wds_basic_rule", WL0_WDS_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* hwaddr^secmode */
+    { "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
+        NVRAM_NONE,
+        0 
+    },  
+    { "wl1_wds_basic_rule", WL1_WDS_BASIC_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* hwaddr^secmode */
+    { "wl0_wds_sec_wep_rule", "|||", 
+        NVRAM_NONE,
+        0 
+    },      /* key */
+    { "wl0_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl1_wds_sec_wep_rule", "|||", 
+        NVRAM_NONE,
+        0 
+    },      /* key */
+    { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    /* apcli related rules */
+    { "wl0_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl0_apcli_rule", WL0_APCLI_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^ssid^bssid^secmode */
+    { "wl0_apcli_sec_wep_rule", WL0_APCLI_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+    { "wl0_apcli_sec_wpa_rule", WL0_APCLI_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl0_apcli_sec_wpa2_rule", WL0_APCLI_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
+        NVRAM_NONE,
+        0 
+    },   
+    { "wl1_apcli_rule", WL1_APCLI_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* enable^ssid^bssid^secmode */
+    { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
+    { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
+        NVRAM_NONE,
+        0 
+    },      /* key^crypto */
+    { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
+        NVRAM_NONE,
+        0 
+    }, 
+#if ( WL_NUM >= 2 )
+    //{ "wl1_wds_rule_num", xstr(WDS_RULE_MAX),     /* How wds interfaces. */
+     //   NVRAM_NONE,
+     //   0 
+    //},   
+   // { "wl1_wds_rule_max", xstr(WDS_RULE_MAX),     /* Max wds interfaces. */
+   //     NVRAM_NONE,
+   //     0 
+  //  },   
+    //{ "wl1_wds_basic_rule", "^disabled|^disabled|^disabled|^disabled", 
+    //    NVRAM_NONE,
+    //    0 
+    //},      /* mac^secmode */
+    //{ "wl1_wds_sec_wep_rule", "|||", 
+    //    NVRAM_NONE,
+    //    0 
+    //},      /* key */
+   // { "wl1_wds_sec_wpa_rule", "^tkip|^tkip|^tkip|^tkip", 
+   //     NVRAM_NONE,
+   //     0 
+   // },      /* key^crypto */
+    /* apcli related rules */
+    //{ "wl1_apcli_rule_num", xstr(APCLI_RULE_MAX),   /* How apcli interfaces. */
+     //   NVRAM_NONE,
+     //   0 
+   // },   
+    //{ "wl1_apcli_rule_max", xstr(APCLI_RULE_MAX),   /* Max apcli interfaces. */
+    //    NVRAM_NONE,
+    //    0 
+    //},   
+   // { "wl1_apcli_rule", WL1_APCLI_RULE, 
+   //     NVRAM_NONE,
+  //      0 
+  //  },      /* enable^ssid^bssid^secmode */
+  //  { "wl1_apcli_sec_wep_rule", WL1_APCLI_SEC_WEP_RULE, 
+  //      NVRAM_NONE,
+  //      0 
+  //  },      /* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode */
+  //  { "wl1_apcli_sec_wpa_rule", WL1_APCLI_SEC_WPA_RULE, 
+   //     NVRAM_NONE,
+  //      0 
+  //  },      /* key^crypto */
+  //  { "wl1_apcli_sec_wpa2_rule", WL1_APCLI_SEC_WPA2_RULE, 
+  //      NVRAM_NONE,
+  //      0 
+  //  },      /* key^crypto */
+#endif
+#endif
+    /* for firewall */
+    { "fw_rule", "1^1^1^1^1^0^1^0", 
+        NVRAM_NONE,
+        0 
+    },  /* enable^syn_enable^icmp_enable^icmp_redir_enable
+           ^icmp_ping_enable^rpfilter_enable^state_enable^
+           wantolan_enable[0:drop non-DNAT wan-to-lan connection request|1:otherwise] */
+    { "nat_pass_rule", "1^1^1^1^1^1^1", 
+        NVRAM_NONE,
+        0 
+    },  /* enable^ipsec_enable^pptp_enable^l2tp_enable^
+           h323_enable^rtsp_enable^mms_enable */
+    /* TTL */
+    { "ttl_rule", "^0^64", 
+        NVRAM_NONE,
+        0 
+    },        /* TTL name^enable[1|0]^value */
+    /* TOS */
+    { "tos_rule", "1^1^1^1^1^1^1", 
+        NVRAM_NONE,
+        0 
+    },   /* TOS enable^icmp_enable^dns_enable^ssh_enable^
+            telnet_enable^check_enable^ack_enable */
+    /* MSS */
+    { "mss_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },        /* TOS [1|0] */
+
+    /* SNAT */
+    { "snat_enable", "1", 
+        NVRAM_NONE,
+        0 
+    },        /* SNAT [1|0] */
+
+    /* Conntrack max amount */
+    { "ct_max", CT_MAX, 
+        NVRAM_NONE,
+        0 
+    },        /* SNAT [1|0] */
+    /* Web server parameters */
+    { "http_rule_default", "^1^0^admin^1234^guest^1234^admin^80^^5", 
+        NVRAM_NONE,
+        0 
+    }, /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
+    { "http_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    },  /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
+    {"rip_conf_rule_default", "0^0^0^0^0^0^0^0",
+      NVRAM_NONE,
+      0
+    },
+   {"rip_conf_rule", "",
+      NVRAM_DEFAULT,
+      0
+    },
+    {"bridge_rule", "",
+      NVRAM_DEFAULT,
+      0
+    },
+    {"bridge_rule_default", "0",
+      NVRAM_DEFAULT,
+      0
+    },
+    {"wl0_wpa_auth_rule", "^^^",
+      NVRAM_NONE,
+      0
+    },
+    {"wl0_wpa_auth_rule_default", "1^^",
+      NVRAM_DEFAULT,
+      0
+    },
+    {"wl1_wpa_auth_rule", "^^^",
+      NVRAM_NONE,
+      0
+    },
+    {"wl1_wpa_auth_rule_default", "1^^",
+      NVRAM_DEFAULT,
+      0
+    },
+    {"board_model_rule", "",
+      NVRAM_DEFAULT,
+      0
+    },
+    {"board_model_rule_default", "0",
+      NVRAM_DEFAULT,
+      0
+    },
+    { "snmpd_user_rule_default", "1^1^1^0", 
+        NVRAM_NONE,
+        0 
+    }, /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
+    { "snmpd_user_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    }, 
+    { "snmpd_com2sec_rule_default", "com2sec^ro^default""|""com2sec^rw^default", 
+        NVRAM_NONE,
+        0 
+    }, 
+    { "snmpd_com2sec_rule", "", 
+        NVRAM_DEFAULT,
+        0 
+    },/*system status^filename^ipaddr^protocol^server username^server password*/
+    { "snmpd_upgrade_rule", "1^^^1^^", 
+        NVRAM_DEFAULT,
+        0 
+    },/* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
+    { "adtool_rule", "any^^4^any^^4^any^^4",
+        NVRAM_NONE,
+        0
+    }, /* pingiface^pinghost^pingcnt^arpingiface^arpinghost^arpingcnt^tracerouteiface^traceroutehost^traceroutecnt */
+    { "stats_rule", STATS_RULE, 
+        NVRAM_NONE,
+        0 
+    },  /* name^enable[0|1]^stime^ifnames */
+    { "stats_type", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_ifname */
+    { "stats_ifname", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_ifname */
+    { "stats_proto", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_ifname */
+    { "stats_interval", "", 
+        NVRAM_TEMP,
+        0 
+    },  /* stats_time hourly:60, daily:600, weekly: 3600, monthly: 3600*6 */
+    { "no_root_swap", "1", 
+        NVRAM_NONE,
+        0 
+	}, /* no_root_swap */ 
+    /* enable^pptp_enable^ipsec_enable^l2tp_enable */
+    { "smb_vpn_passthrough_rule", "1^1^1", 
+        NVRAM_NONE,
+        0 
+    }, 
+    /* IPsec */
+	{ "ipsec_enable", "0",
+		NVRAM_NONE,
+		0    
+	},   
+#ifdef IPSEC_RULE_MAX
+#undef IPSEC_RULE_MAX
+#define IPSEC_RULE_MAX "32"
+#else 
+#define IPSEC_RULE_MAX "32"
+#endif
+	{ "ipsec_rule_max", IPSEC_RULE_MAX,
+		NVRAM_NONE,
+		0    
+	}, /* value */
+	{ "ipsec_rule_num", "0", 
+		NVRAM_NONE,
+		0    
+	}, /* value */
+	{ "ipsec_rule", "",  
+		NVRAM_NONE,
+		0    
+	},
+	/*
+ name^enable^mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init^ike_keymode^psk^rsa^ca^adv^phase1_mode^phase1_auth^phase1_encrypt^phase1_group^phase1_id^phase2_auth^phase2_encrypt^phase2_group^phase1_lifetime^phase2_lifetime^dpd_enable^dpd_interval^dpd_timeout
+
+	 */
+	{ "ipsec_status_rule", "",
+		NVRAM_TEMP,
+		0
+	}, /* phase1[none|established]^phase2[none|established] */
+
+#undef PPTPD_SESSION_MAX
+#undef PPTPD_USER_RULE_MAX
+#undef L2TPD_SESSION_MAX
+#undef L2TPD_USER_RULE_MAX
+#define PPTPD_SESSION_MAX 32	/* Stringification later!*/
+#define PPTPD_USER_RULE_MAX "32"
+#define L2TPD_SESSION_MAX 32	/* Stringification later!*/
+#define L2TPD_USER_RULE_MAX "32"
+	/*pptpd*/
+    { "pptpd_rule", "0^pptp-server^60^1460^1482^192.168.38.1^" xstr(PPTPD_SESSION_MAX) "^192.168.39.1^" xstr(PPTPD_SESSION_MAX) "^1^^0^0^1^0^0^1^0^1",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^name^redialperiod^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable[0|1]^dns^chap_enable[0|1]^mschap_enable[0|1]^mschapv2_enable[0|1]^eap_enable[0|1]^pap_enable[0|1]^mppe128_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
+
+    { "pptpd_user_rule", "",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^username^provider^passwd^ipaddr */
+    { "pptpd_user_rule_num", "0",
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+    { "pptpd_user_rule_max", PPTPD_USER_RULE_MAX,
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+    { "pptpd_session_max", xstr(PPTPD_SESSION_MAX), 
+        NVRAM_NONE,
+        0 
+    },  /* value */
+    /*l2tpd*/
+    { "l2tpd_rule", "0^l2tp-server^1400^1400^192.168.48.1^" xstr(L2TPD_SESSION_MAX) "^192.168.49.1^" xstr(L2TPD_SESSION_MAX) "^1^^1^0^1^1",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^name^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable^dns^chap_enable[0|1]^pap_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
+    { "l2tpd_user_rule", "",
+        NVRAM_NONE,
+        0 
+    },  /* enable[0|1]^username^provider^passwd^ipaddr */
+    { "l2tpd_user_rule_num", "0",
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+    { "l2tpd_user_rule_max", L2TPD_USER_RULE_MAX,
+        NVRAM_NONE,
+        0 
+    },  /* username^provider^passwd^ipaddr */
+
+	{ "wol_rule", "",
+		NVRAM_NONE,
+		0 
+	},  /* name^enable^bcast^hwaddr^iface^passwd */
+	{ "lang_default", "EN", 
+		NVRAM_NONE,
+		0 
+	},  /* Default web language support */
+	{ "lang", "", 
+		NVRAM_DEFAULT,
+		0 
+	},  /* Web language support */
+	{ "brand", "LITEON", 
+		NVRAM_NONE,
+		0 
+	},  /* Brand name - CSS style and SSID. */
+#define UPNP_FRIENDLYNAME   "LITEON CPE Internet Sharing Gateway"
+#define MANUFACTURER        "LITEON Communications Corp."
+#define MANUFACTURERURL     "http://www.liteon.com"
+#define MODELDESCRIPTION    "LITEON CPE Internet Sharing Gateway"
+#define MODELNAME           "LITEON Internet Sharing Gateway"
+#define MODELNUMBER         "CPE"
+#define MODELURL            ""
+#define SERIALNUMBER        "A19003848"
+#define UDN                 "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e"
+#define PRESENTATIONURL     ""
+    { "upnpxml_rule", UPNP_FRIENDLYNAME"^"MANUFACTURER"^"MANUFACTURERURL"^"MODELDESCRIPTION"^"MODELNAME"^"MODELNUMBER"^"MODELURL"^"SERIALNUMBER"^"UDN"^"PRESENTATIONURL, 
+        NVRAM_NONE,
+        0 
+    },  /* friendlyName^manufacturer^manufacturerURL^modelDescription^
+         * modelName^modelNumber^modelURL^serialNumber^UDN^presentationURL */
+    { "igd", "CPE IGD Version 1.00", 
+        NVRAM_NONE,
+        0 
+    },  /* Brand name - CSS style and SSID. */
+    { "udn", "uuid:75802409-bccb-40e7-8e6c-fa095ecce13e", 
+        NVRAM_NONE,
+        0 
+    },  /* Brand name - CSS style and SSID. */
+    { "model", "CPE Internet Gateway Device", 
+        NVRAM_NONE,
+        0 
+    },              /* Product model */
+    { "license_key", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },              /* Product model */
+    { "hostname", "WP688",
+        NVRAM_NONE,
+        0 
+    },           /* Hostname */
+    { "prod_cat", xstr(EZP_PROD_CAT), 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },           /* Product category */
+    { "prod_subcat", xstr(EZP_PROD_SUBCAT), 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* Product subcategory */
+    { "prod_subsubcat", xstr(EZP_PROD_SUBSUBCAT), 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* Product sub-subcategory */
+    { "machine_id", "", 
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* Machine id */
+    { "arch", ARCH, 
+        NVRAM_PROTECTED,
+        0 
+    },        /* Arch */
+    { "license_invalid", "0",
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* License status */
+    { "bootcount", "",
+        NVRAM_PROTECTED | NVRAM_CUSTOMIZED,
+        0 
+    },        /* License bootcount */
+/* Added by Abocom */
+    { "weather_rule", "1^UKXX1428^c", 
+        NVRAM_NONE,
+        0 
+    },        /* enable^city^degree */
+    { "wl_easy_mode_rule", "0", 
+        NVRAM_NONE,
+        0 
+    },        /* mode 0->2.4g  1->5g */
+    { "FirstConfig", "1", 
+        NVRAM_NONE,
+        0 
+    },        /* FirstConfig for web server */
+     { "zyfw_fw_file", "", 
+        NVRAM_NONE,
+        0 
+    },        /* file name for online FW upgrade */
+    { "zyfw_size", "", 
+        NVRAM_NONE,
+        0 
+    },        /* file size for online FW upgrade */
+    { "WISP_Channel", "0", 
+        NVRAM_NONE,
+        0 
+    },        /* Save WISP's wireless Channel */	
+    { "WISP1_Channel", "0", 
+        NVRAM_NONE,
+        0 
+    },        /* Save WISP's wireless 5g Channel */	
+    { "AP_Channel", "0", 
+        NVRAM_NONE,
+        0 
+    },		/* Save AP's wireless Channel */
+    { "AP1_Channel", "36", 
+        NVRAM_NONE,
+        0 
+    },		/* Save AP's wireless Channel */
+    { "wl_wisp_mode_rule", "wisp^ap", 
+        NVRAM_NONE,
+        0 
+    }, /*wifi 2.4g as wisp,wifi 5g as 
+       ap mode when choose wisp mode*/
+    /* v1_enable[0|1]^v2c_enable[0|1]^usm_enable[0|1]*/
+#ifdef QOS_CONFIG
+
+    /*port_status*/
+    { "direct_multicast_status", DIRECT_MULTICAST_STATUS_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*maxnum*/
+    { "direct_multicast_maxnum", DIRECT_MULTICAST_MAXNUM_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*port_status*/
+    { "tos_classification_status", TOS_CLASSIFICATION_STATUS_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*port_status*/
+    { "cos_classification_status", COS_CLASSIFICATION_STATUS_VALUE, 
+        NVRAM_NONE,
+        0 
+    },    
+    /*port_status*/
+    { "heuristics_classification_status", HEURISTICS_CLASSIFICATION_STATUS_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*level*/
+    { "bwm_level_dl_index", BWM_LEVEL_DL_INDEX_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*level*/
+    { "bwm_level_up_index", BWM_LEVEL_UP_INDEX_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*port_status*/
+    { "qos_rule_status", QOS_RULE_STATUS_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*x*/
+    { "qos_rule_active", QOS_RULE_ACTIVE_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+	/*rule*/
+    { "bwm_level", BWM_LEVEL_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+	/*rule*/
+    { "stream_priority", STREAM_PRIORITY_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+	/*level*/
+    { "sta_priority", STA_PRIORITY_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+	/*rule*/
+    { "qos_rule_record", QOS_RULE_RECORD_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+	/*status^age*/
+    { "igmp_snooping", IGMP_SNOOPING_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*voice^video^data^background*/
+    { "tos_classify", TOS_CLASSIFY_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*voice^video^data^background*/
+    { "cos_classify", COS_CLASSIFY_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+    /*(d_count^b_count^ipg_min^ipg_max^pl_min^pl_max)*/
+    { "heuristics_classify", HEURISTICS_CLASSIFY_VALUE, 
+        NVRAM_NONE,
+        0 
+    },
+/* (status^voice^video^data^background) */
+    { "tos_mark", TOS_MARK_VALUE,        
+        NVRAM_NONE,
+        0 
+    },
+/* (wlantolan^lanto2.4Gwlan^lanto5Gwlan) */
+    { "root_bw", ROOT_BW_VALUE,        
+        NVRAM_NONE,
+        0 
+    },
+#endif
+    { 0, 0, 0 ,0 }
+};
+
+#endif /*_NVRAM_EZPACKET_H */

Property changes on: src/nvram_ezpacket.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/nvram_ezpacket-rt305x.h
===================================================================
--- src/nvram_ezpacket-rt305x.h	(revision 0)
+++ src/nvram_ezpacket-rt305x.h	(revision 7299)
@@ -0,0 +1,295 @@
+#ifdef CONFIG_EZP_ARCH_RT305X
+#define ARCH "RT305X"
+
+#ifndef WL_NUM
+#define WL_NUM 1
+#endif
+
+#ifndef WL_VIRTUAL_NUM
+#define WL_VIRTUAL_NUM 4
+#endif
+
+#ifndef WL_WDS_NUM
+#define WL_WDS_NUM 4
+#endif
+
+#ifndef WL_APCLI_NUM
+#define WL_APCLI_NUM 1
+#endif
+
+#if ( WL_NUM == 1 )
+#define WL_BASIC_RULE "1^9^100^6^1"
+#define WL5G_BASIC_RULE "1^8^100^0^1"
+#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE*/
+#define WL0_IFNAME_RULE "rai0"
+#define WL1_IFNAME_RULE "ra0"
+#elif ( WL_VIRTUAL_NUM == 2 )
+#define WL0_IFNAME_RULE "ra0|ra1"
+#define WL1_IFNAME_RULE "rai0|rai1"
+#elif ( WL_VIRTUAL_NUM == 4 )
+#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
+#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
+#endif /* WL0_IFNAME_RULE*/
+#define WL0_RULE_NUM WL_VIRTUAL_NUM
+#define WL0_RULE_MAX WL_VIRTUAL_NUM
+#if (WL0_RULE_NUM == 2)
+#warning "WL0_RULE_NUM 2"
+#warning "WL0_RULE_MAX 2"
+#elif (WL0_RULE_NUM == 4)
+#warning "WL0_RULE_NUM 4"
+#warning "WL0_RULE_MAX 4"
+#endif
+#define WDS_RULE_MAX WL_WDS_NUM
+#define APCLI_RULE_MAX WL_APCLI_NUM
+#elif ( WL_NUM == 2 )
+#define WL_BASIC_RULE "1^9^100^6^1|1^9^100^6^1"
+#define WL5G_BASIC_RULE "1^8^100^6^1|1^8^100^6^1"
+#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE/WL1_IFNAME_RULE*/
+#define WL0_IFNAME_RULE "rai0"
+#define WL1_IFNAME_RULE "ra0"
+#elif ( WL_VIRTUAL_NUM == 2 )
+#define WL1_IFNAME_RULE "ra0|ra2"
+#define WL0_IFNAME_RULE "rai0|rai2"
+#elif ( WL_VIRTUAL_NUM == 4 )
+#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
+#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
+#endif /* WL0_IFNAME_RULE/WL1_RULE_NUM */
+#define WL0_RULE_NUM WL_VIRTUAL_NUM
+#define WL0_RULE_MAX WL_VIRTUAL_NUM
+#define WL1_RULE_NUM WL_VIRTUAL_NUM
+#define WL1_RULE_MAX WL_VIRTUAL_NUM
+#define WDS_RULE_MAX WL_WDS_NUM
+#define APCLI_RULE_MAX WL_APCLI_NUM
+#elif (WL_NUM == 0 )
+#else
+#error "Undefined amount of WLAN interfaces"
+#endif
+
+#if ( WAN_NUM >= 1 )
+
+/* 3G/4G WAN default interface should be ppp0. */
+#if defined(EZP_PROD_CAT_M)
+#define WAN0_IFNAME "vlan2"
+#else
+#define WAN0_IFNAME "vlan2"
+#endif
+
+#define WAN0_IFNAMES ""
+#define WAN0_HWNAME ""
+#define WAN0_DEVICE "vlan2"
+#define WAN0_PORTS "4"
+#if ( LAN_NUM >= 1 )
+    #define LAN0_IFNAME "br0"
+    #define LAN0_IFNAMES "vlan1 ra0 ra1 apcli0"
+    #define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 apcli0 wds0 wds1 wds2 wds3"
+    #define LAN0_HWNAME ""
+    #define LAN0_DEVICE "vlan1"
+#endif
+#if (LAN_NUM >= 2)
+    #define LAN1_IFNAME "br2"
+    #define LAN1_DEVICE "br2"
+#endif
+
+#if (LAN_NUM == 1)
+    #if (WL_VIRTUAL_NUM == 2)
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
+    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
+    #else
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
+    #endif
+    #define BR_RULE_NUM 2
+    #define BR_RULE_MAX 8
+#elif (LAN_NUM == 2)
+    #define BR_RULE_GUESTLAN "GuestLAN^0^ra1^"
+    #if (WL_VIRTUAL_NUM == 2)
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
+    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
+    #else
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
+    #endif
+    #define BR_RULE_NUM 3
+    #define BR_RULE_MAX 8
+#else
+    #if (WL_VIRTUAL_NUM == 2)
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
+    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
+    #else
+        #define BR_RULE "LAN1^1^vlan1 rai0 rai1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^"
+    #endif
+    #define BR_RULE_NUM 2
+    #define BR_RULE_MAX 8
+#endif
+
+#define STATS_RULE "^1^60^vlan1 vlan2 ppp0 br0 rai0 usb0 eth0"
+#define VLAN_RULE_NUM 2
+#define VLAN_RULE_MAX 8
+#ifdef CONFIG_RAETH_RT3052_P5
+    #warning "P5 enabled, vlan set to 1111011"
+    #define VLAN_RULE "LAN1^1^eth2^1^1111011^|WAN1^1^eth2^2^0000111^"
+#else
+    #warning "P5 disabled, vlan set to 1111001"
+    #define VLAN_RULE "LAN1^1^eth2^1^1111011^|WAN1^1^eth2^2^0000111^"
+#endif /* CONFIG_RAETH_RT3052_P5 : support for GMAC port when using external giga switch. */
+#define VLANPORT_RULE_NUM 5
+#define VLANPORT_RULE_MAX 7
+#define VLANPORT_RULE "PORT1^0^1^0^011101|PORT2^1^1^0^011011|PORT3^2^1^0^010111|PORT4^3^1^0^001111|PORT5^4^2^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
+/* EZP: Old VLAN definition should be Obsolete! */
+#define LAN0_PORTS "0 1 2 3"
+/* WAN0 uses vlan2. XXX: No effect! */
+#define VLAN2_PORTS "4 5"
+/* LAN0 uses vlan1. XXX: No effect! */
+#define VLAN1_PORTS "0 1 2 3 5*"
+#define VLAN_HWNAME "eth2"
+
+#elif ( WAN_NUM == 2 ) 
+
+#define WAN0_IFNAME "vlan2"
+#define WAN0_IFNAMES ""
+#define WAN0_HWNAME ""
+#define WAN0_DEVICE "vlan2"
+#define WAN0_PORTS "4"
+
+/* 3G/4G 2nd WAN default interface should be ppp0. */
+#if defined(EZP_PROD_CAT_N)
+#define WAN1_IFNAME "ppp1"
+#else
+#define WAN1_IFNAME "vlan3"
+#endif
+
+#define WAN1_IFNAMES ""
+#define WAN1_HWNAME ""
+#define WAN1_DEVICE "vlan3"
+#define WAN1_PORTS "3"
+
+#define LAN0_IFNAME "br0"
+#define LAN0_IFNAMES "vlan1 ra0 ra1 apcli0"
+#define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 apcli0 wds0 wds1 wds2 wds3"
+#define LAN0_HWNAME ""
+#define LAN0_DEVICE "vlan1"
+#define LAN0_PORTS "0 1 2"
+
+#define VLAN_RULE_NUM 3
+#define VLAN_RULE_MAX 16 
+#ifdef CONFIG_RAETH_RT3052_P5
+    #define VLAN_RULE "LAN1^1^eth2^1^1110011^|WAN1^1^eth2^2^0000111^|WAN2^1^eth2^3^0001011^"
+#else
+    #define VLAN_RULE "LAN1^1^eth2^1^1110001^|WAN1^1^eth2^2^0000101^|WAN2^1^eth2^3^0001001^"
+#endif /* CONFIG_RAETH_RT3052_P5 : support for GMAC port when using external giga switch. */
+#define VLANPORT_RULE_NUM 5
+#define VLANPORT_RULE_MAX 7
+#define VLANPORT_RULE "PORT1^0^1^0^001101|PORT2^1^1^0^001011|PORT3^2^1^0^000111|PORT4^3^2^0^000001|PORT5^4^3^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
+/* WAN0 uses vlan2. */
+#define VLAN2_PORTS "4 5"
+/* WAN1 uses vlan3. */
+#define VLAN3_PORTS "3 5"
+/* LAN0 uses vlan1. */
+#define VLAN1_PORTS "0 1 2 5"
+
+#define VLAN_HWNAME "eth2"
+
+#if (WL_VIRTUAL_NUM == 2)
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#else
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#endif
+
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#define BR_RULE_NUM 3
+#define BR_RULE_MAX 16
+
+#define STATS_RULE "^1^60^vlan3 vlan1 vlan2 ppp0 ppp1 br0 ra0 usb0 eth0 eth1"
+
+#else
+
+#error "Undefined amount of LAN/WAN interfaces"
+
+#endif
+
+#define HWNAT_RULE "1"
+
+#define BW_TYPE \
+        "A1M64K", "A1.5M640K", "A2M256K", "A2M512K", "A3M640K", "A4M1M", \
+        "A6M256K", "A6M640K", "A8M256K", "A8M640K", "A8M800K", "A10M2M", \
+        "A12M1M", "C1M128K", "C2M128K", "C2M384K", "C3M384K", "C6M640K", \
+        "C8M640K", "C10M1M", "V2M2M", "V4M4M", "V10M10M", "V25M25M", \
+        "V50M50M", "V100M100M","Custom"
+#if ( EZP_PROD_SUBCAT == 0 )
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+#elif ( EZP_PROD_SUBCAT == 1 )
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+#elif ( EZP_PROD_SUBCAT == 2 )
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+#elif ( EZP_PROD_SUBCAT == 3 )
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+#elif ( EZP_PROD_SUBCAT == 4 )
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+#elif ( EZP_PROD_SUBCAT == 5 )
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+#elif ( EZP_PROD_SUBCAT == 6 )
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+#endif /* EZP_PROD_SUBCAT */
+
+#define NVRAM_EZPACKET_DEFAULT_RT305X_LAN_NUM_1   \
+    /* WAN1 uses vlan1. */              \
+    { "vlan1ports", VLAN1_PORTS,        \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 port. */                \
+    { "vlan1hwname", VLAN_HWNAME,       \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 device hwname. */       \
+
+#define NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_1   \
+    /* WAN1 uses vlan2. */              \
+    { "vlan2ports", VLAN2_PORTS,        \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 port. */                \
+    { "vlan2hwname", VLAN_HWNAME,       \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 device hwname. */       \
+
+
+#define NVRAM_EZPACKET_DEFAULT_RT305X_WAN_NUM_2   \
+    /* WAN3 uses vlan3. */              \
+    { "vlan2ports", VLAN3_PORTS,        \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN3 port. */                \
+    { "vlan3hwname", VLAN_HWNAME,       \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN3 device hwname. */       \
+
+
+
+#endif /* CONFIG_EZP_ARCH_RT305X */
+

Property changes on: src/nvram_ezpacket-rt305x.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/wl.c
===================================================================
--- src/wl.c	(revision 0)
+++ src/wl.c	(revision 7299)
@@ -0,0 +1,86 @@
+/*
+ * Wireless network adapter utilities
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: wl.c 1629 2005-08-13 14:22:32Z nbd $
+ */
+#include <string.h>
+
+#include <typedefs.h>
+#include <wlutils.h>
+
+int
+wl_probe(char *name)
+{
+	int ret, val;
+
+	/* Check interface */
+	if ((ret = wl_ioctl(name, WLC_GET_MAGIC, &val, sizeof(val))))
+		return ret;
+	if (val != WLC_IOCTL_MAGIC)
+		return -1;
+	if ((ret = wl_ioctl(name, WLC_GET_VERSION, &val, sizeof(val))))
+		return ret;
+	if (val > WLC_IOCTL_VERSION)
+		return -1;
+
+	return ret;
+}
+
+int
+wl_set_val(char *name, char *var, void *val, int len)
+{
+	char buf[128];
+	int buf_len;
+
+	/* check for overflow */
+	if ((buf_len = strlen(var)) + 1 + len > sizeof(buf))
+		return -1;
+	
+	strcpy(buf, var);
+	buf_len += 1;
+
+	/* append int value onto the end of the name string */
+	memcpy(&buf[buf_len], val, len);
+	buf_len += len;
+
+	return wl_ioctl(name, WLC_SET_VAR, buf, buf_len);
+}
+
+int
+wl_get_val(char *name, char *var, void *val, int len)
+{
+	char buf[128];
+	int ret;
+
+	/* check for overflow */
+	if (strlen(var) + 1 > sizeof(buf) || len > sizeof(buf))
+		return -1;
+	
+	strcpy(buf, var);
+	if ((ret = wl_ioctl(name, WLC_GET_VAR, buf, sizeof(buf))))
+		return ret;
+
+	memcpy(val, buf, len);
+	return 0;
+}
+
+int
+wl_set_int(char *name, char *var, int val)
+{
+	return wl_set_val(name, var, &val, sizeof(val));
+}
+
+int
+wl_get_int(char *name, char *var, int *val)
+{
+	return wl_get_val(name, var, val, sizeof(*val));
+}
+

Property changes on: src/wl.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/base64.c
===================================================================
--- src/base64.c	(revision 0)
+++ src/base64.c	(revision 7299)
@@ -0,0 +1,126 @@
+/*
+
+	Tomato Firmware
+	Copyright (C) 2006 Jonathan Zarate
+
+*/
+#include <stdio.h>
+#include <string.h>
+
+/*
+
+111111  110000  000011  111111
+0         1         2
+
+echo -n "aaa" | uuencode -m -
+begin-base64 644 -
+YWFh
+
+echo -n "a" | uuencode -m -
+begin-base64 644 -
+YQ==
+
+echo -n "aa" | uuencode -m -
+begin-base64 644 -
+YWE=
+
+*/
+
+static const char base64_xlat[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+
+int base64_encode(const unsigned char *in, char *out, int inlen)
+{
+	char *o;
+	
+	o = out;
+	while (inlen >= 3) {
+		*out++ = base64_xlat[*in >> 2];
+		*out++ = base64_xlat[((*in << 4) & 0x3F) | (*(in + 1) >> 4)];
+		++in;	// note: gcc complains if *(++in)
+		*out++ = base64_xlat[((*in << 2) & 0x3F) | (*(in + 1) >> 6)];
+		++in;
+		*out++ = base64_xlat[*in++ & 0x3F];
+		inlen -= 3;
+	}
+	if (inlen > 0) {
+		*out++ = base64_xlat[*in >> 2];
+		if (inlen == 2) {
+			*out++ = base64_xlat[((*in << 4) & 0x3F) | (*(in + 1) >> 4)];
+			++in;
+			*out++ = base64_xlat[((*in << 2) & 0x3F)];
+		}
+		else {
+			*out++ = base64_xlat[(*in << 4) & 0x3F];
+			*out++ = '=';
+		}
+		*out++ = '=';
+	}
+	return out - o;
+}
+
+
+int base64_decode(const char *in, unsigned char *out, int inlen)
+{
+	char *p;
+	int n;
+	unsigned long x;
+	unsigned char *o;
+	char c;
+
+	o = out;
+	n = 0;
+	x = 0;
+	while (inlen-- > 0) {
+		if (*in == '=') break;
+		if ((p = strchr(base64_xlat, c = *in++)) == NULL) {
+//			printf("ignored - %x %c\n", c, c);
+			continue;	// note: invalid characters are just ignored
+		}
+		x = (x << 6) | (p - base64_xlat);
+		if (++n == 4) {
+			*out++ = x >> 16;
+			*out++ = (x >> 8) & 0xFF;
+			*out++ = x & 0xFF;
+			n = 0;
+			x = 0;
+		}
+	}
+	if (n == 3) {
+		*out++ = x >> 10;
+		*out++ = (x >> 2) & 0xFF;
+	}
+	else if (n == 2) {
+		*out++ = x >> 4;
+	}
+	return out - o;
+}
+
+int base64_encoded_len(int len)
+{
+	return ((len + 2) / 3) * 4;
+}
+
+int base64_decoded_len(int len)
+{
+	return ((len + 3) / 4) * 3;
+}
+
+/*
+int main(int argc, char **argv)
+{
+	char *test = "a";
+	char buf[128];
+	char buf2[128];
+	const char *in;
+	int len;
+
+	memset(buf, 0, sizeof(buf));
+	base64_encode(test, buf, strlen(test));
+	printf("buf=%s\n", buf);
+	
+	memset(buf2, 0, sizeof(buf2));
+	base64_decode(buf, buf2, base64_encoded_len(strlen(test)));
+	printf("buf2=%s\n", buf2);
+}
+*/

Property changes on: src/base64.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/nvram_fw.h
===================================================================
--- src/nvram_fw.h	(revision 0)
+++ src/nvram_fw.h	(revision 7299)
@@ -0,0 +1,39 @@
+#ifndef _NVRAM_FW_H_
+#define _NVRAM_FW_H_
+
+typedef enum
+{
+    NVRAM_FW_0_0_0 = 0,
+    NVRAM_FW_1_6_5,
+    NVRAM_FW_1_6_6,
+    NVRAM_FW_1_6_7,
+    NVRAM_FW_1_7_0,
+    NVRAM_FW_1_7_1,
+    NVRAM_FW_1_7_2,
+    NVRAM_FW_1_7_3,
+    NVRAM_FW_1_7_4,
+    NVRAM_FW_1_7_5,
+    NVRAM_FW_1_7_6,
+    NVRAM_FW_1_7_7,
+    NVRAM_FW_1_7_8,
+    NVRAM_FW_1_7_9,
+    NVRAM_FW_1_7_10,
+    NVRAM_FW_1_7_11,
+    NVRAM_FW_2_0_0,
+    NVRAM_FW_2_0_1,
+    NVRAM_FW_2_0_2,
+    NVRAM_FW_2_0_3,
+    NVRAM_FW_2_0_4,
+    NVRAM_FW_2_0_5,
+} nvram_fw_version;
+
+struct nvram_fw_tuple {
+    char *fw_str;
+    nvram_fw_version fw_version;
+    int (*fw_upgrade_func)(void); 
+    int (*fw_downgrade_func)(void); 
+};
+
+
+#endif /* _NVRAM_FW_H_ */
+

Property changes on: src/nvram_fw.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/zconf.h
===================================================================
--- src/zconf.h	(revision 0)
+++ src/zconf.h	(revision 7299)
@@ -0,0 +1,90 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-1998 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id$ */
+
+#ifndef _ZCONF_H
+#define _ZCONF_H
+
+#if defined(__GNUC__) || defined(__386__) || defined(i386)
+#  ifndef __32BIT__
+#    define __32BIT__
+#  endif
+#endif
+
+#if defined(__STDC__) || defined(__cplusplus)
+#  ifndef STDC
+#    define STDC
+#  endif
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  define MAX_MEM_LEVEL 9
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef FAR
+#   define FAR
+#endif
+
+typedef unsigned char  Byte;  /* 8 bits */
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+typedef Byte  FAR Bytef;
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+typedef void FAR *voidpf;
+typedef void     *voidp;
+
+#include <linux/types.h> /* for off_t */
+#include <linux/unistd.h>    /* for SEEK_* and off_t */
+#define z_off_t  off_t
+
+#endif /* _ZCONF_H */

Property changes on: src/zconf.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/ezp-lib6239.c
===================================================================
--- src/ezp-lib6239.c	(revision 0)
+++ src/ezp-lib6239.c	(revision 7299)
@@ -0,0 +1,2235 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <bcmnvram.h>
+#include <assert.h>
+#include "ezp-lib.h"
+
+static char *mask[] = {
+    "255.255.255.0",
+    "255.255.255.128",
+    "255.255.255.192",
+    "255.255.255.224",
+    "255.255.255.240",
+    "255.255.255.248",
+    "255.255.255.252",
+    "255.255.255.254"
+};
+
+struct attr {
+    char *name;
+    int (*func_orig)(char *, char *, char *, int);
+    int (*func_wrap)(char *, char *, char *, int);
+};
+
+static int
+show_enable_value(char *type, char *val, char *buf, int bsize)
+{
+    if (!val) {
+        return EZPLIB_NO_ATTRIBUTE;
+    }
+
+    if (snprintf(buf, bsize, "%s", 
+                !strcmp(val, "1") ? "enabled" : "disabled") >= bsize) {
+        return EZPLIB_VAL_TRUNC;
+    }
+
+    return strlen(buf);
+}
+
+static int
+show_value(char *type, char *val, char *buf, int bsize)
+{
+    if (!val) {
+        return EZPLIB_NO_ATTRIBUTE;
+    }
+
+    if (snprintf(buf, bsize, "%s", val) >= bsize) {
+        return EZPLIB_VAL_TRUNC;
+    }
+    return strlen(buf);
+}
+
+static char *iftype[] = { "wan", "lan", NULL };
+
+static int
+show_if_value(char *type, char *val, char *buf, int bsize)
+{
+    char *ptr;
+    int i, len, idx;
+
+    if (!val) {
+        return EZPLIB_NO_ATTRIBUTE;
+    }
+
+    for (i = 0; iftype[i]; i++) {
+        len = strlen(iftype[i]);
+        if (!strcmp(val, iftype[i])) {
+            break;
+        }
+    }
+
+    if (!iftype[i]) {
+        if (snprintf(buf, bsize, "%s", val) >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    } else {
+        ptr = val + len;
+        /* 1-based index for GUI display. */
+        idx = atoi(ptr) + 1;    
+        if (snprintf(buf, bsize, "%s%d", iftype[i], idx) >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    }
+
+    return strlen(buf);
+}
+
+static int
+show_proto_value(char *type, char *val, char *buf, int bsize)
+{
+    if (!val) {
+        return EZPLIB_NO_ATTRIBUTE;
+    }
+
+    if (!strcmp(val, "both")) {
+        if (snprintf(buf, bsize, "UDP/TCP") >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    } else if (!strcmp(val, "tcp")) {
+        if (snprintf(buf, bsize, "TCP") >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    } else if (!strcmp(val, "udp")) {
+        if (snprintf(buf, bsize, "UDP") >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    } else {
+        if (snprintf(buf, bsize, "%s", val) >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    }
+    return strlen(buf);
+}
+
+static int
+show_mask_value(char *type, char *val, char *buf, int bsize)
+{
+    if (!val) {
+        return EZPLIB_NO_ATTRIBUTE;
+    }
+
+    int idx = atoi(val);
+
+    if (24 <= idx && idx <= 32) {
+        /* 24-based. */
+        if (snprintf(buf, bsize, "%s", mask[idx - 24]) >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    } else {
+        if (snprintf(buf, bsize, "") >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+    }
+
+    return strlen(buf);
+}
+
+/* enable^name^extif^proto^extport_start^extport_end^ipaddr^inport_start^inport_end */
+struct attr fr_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "extif", show_value, show_value },
+    { "proto", show_value, show_proto_value },
+    { "extport_start", show_value, show_value },
+    { "extport_end", show_value, show_value },
+    { "ipaddr", show_value, show_value },
+    { "inport_start", show_value, show_value },
+    { "inport_end", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable^proto[tcp|udp|both]^port_start^port_end^trig_port_start^trig_port_end */
+struct attr pt_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "proto", show_value, show_value },
+    { "port_start", show_value, show_value },
+    { "port_end", show_value, show_value },
+    { "trig_port_start", show_value, show_value },
+    { "trig_port_end", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^extif^index^wan_ipaddr^mapped_ipaddr */
+struct attr vs_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "extif", show_value, show_value },
+    { "index", show_value, show_value },
+    { "wan_ipaddr", show_value, show_value },
+    { "mapped_ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^mtu^stp^upnp^igmp_snooping */
+struct attr wan_main_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "mtu", show_value, show_value },
+    { "stp", show_value, show_value },
+    { "upnp", show_value, show_value },
+    { "snooping", show_value, show_value},
+    { NULL, NULL, NULL }
+};
+
+/* ipaddr^mask^gateway^dns^wins */
+struct attr wan_static_rule_attr[] = {
+    { "ipaddr", show_value, show_value },
+    { "mask", show_value, show_value },
+    { "gateway", show_value, show_value },
+    { "dns1", show_value, show_value },
+    { "dns2", show_value, show_value },
+    { "wins", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* hostname^domain^lease*/
+struct attr wan_dhcp_rule_attr[] = {
+    { "hostname", show_value, show_value },
+    { "domain", show_value, show_value },
+    { "lease", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* auth^username^passwd^demand^idletime^echo_failure^redialperiod^
+ * mru^mtu^pppiptype[isp|custom]^custom_ipaddr^servname */
+struct attr wan_pppoe_rule_attr[] = {
+    { "auth", show_value, show_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "demand", show_value, show_value },
+    { "idletime", show_value, show_value },
+    { "echo_failure", show_value, show_value },
+    { "redialperiod", show_value, show_value },
+    { "mru", show_value, show_value },
+    { "mtu", show_value, show_value },
+    { "pppiptype", show_value, show_value },
+    { "custom_ipaddr", show_value, show_value },
+    { "servname", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* ipaddr^length^gateway^dns1^dns2 */
+struct attr wan_staticv6_rule_attr[] = {
+    { "ipaddr", show_value, show_value },
+    { "length", show_value, show_value },
+    { "gateway", show_value, show_value },
+    { "dns1", show_value, show_value },
+    { "dns2", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* hostname^domain^lease^type[0:stateless|1:stateful] */
+struct attr wan_dhcpv6_rule_attr[] = {
+    { "hostname", show_value, show_value },
+    { "domain", show_value, show_value },
+    { "lease", show_value, show_value },
+    { "type", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* brokerv4addr^v6ipaddr_length^v6gateway */
+struct attr wan_tunnel6_rule_attr[] = {
+    { "brokerv4addr", show_value, show_value },
+    { "v6ipaddr_length", show_value, show_value },
+    { "v6gateway", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* username^passwd^servicename^
+ * demand^idletime^echo_failure^redialperiod^
+ * mru^mtu^pppiptype[isp|custom]^custom_ipaddr */
+struct attr wan_pppoev6_rule_attr[] = {
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "servicename", show_value, show_value },
+    { "demand", show_value, show_value },
+    { "idletime", show_value, show_value },
+    { "echo_failure", show_value, show_value },
+    { "redialperiod", show_value, show_value },
+    { "mru", show_value, show_value },
+    { "mtu", show_value, show_value },
+    { "pppiptype", show_value, show_value },
+    { "custom_ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable^server^username^passwd */
+struct attr wan_bigpond_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "server", show_value, show_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* apn_type^location^isp^apn^pin^mode^username^passwd^demand^idletime^
+ * redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^ctrltty^devname^flag^turbolink
+ */
+struct attr wan_wwan_rule_attr[] = {
+    { "apn_type", show_value, show_value },
+    { "location", show_value, show_value },
+    { "isp", show_value, show_value },
+    { "apn", show_value, show_value },
+    { "pin", show_value, show_value },
+    { "mode", show_value, show_value },
+    { "auth", show_value, show_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "demand", show_value, show_value },
+    { "idletime", show_value, show_value },
+    { "echo_failure", show_value, show_value },
+    { "redialperiod", show_value, show_value },
+    { "mru", show_value, show_value },
+    { "mtu", show_value, show_value },
+    { "dialstr", show_value, show_value },
+    { "brand", show_value, show_value },
+    { "model", show_value, show_value },
+    { "ttynum", show_value, show_value },
+    { "datatty", show_value, show_value },
+    { "ctrltty", show_value, show_value },
+    { "devname", show_value, show_value },
+    { "flag", show_value, show_value },
+    { "turbolink", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+/* serverip^iptype[static|dhcp]^ipaddr^netmask^gateway^username^
+   passwd^nailup^timeout^pppiptype[isp|custom]^custom_ipaddr^
+   encmode[disabled|mppe]^auth[chap|pap|none] */
+struct attr wan_pptp_l2tp_rule_attr[] = {
+    { "serverip", show_value, show_value },
+    { "iptype", show_value, show_value },
+    { "ipaddr", show_value, show_value },
+    { "netmask", show_value, show_value },
+    { "gateway", show_value, show_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "nailup", show_value, show_value },
+    { "timeout", show_value, show_value },
+    { "pppiptype", show_value, show_value },
+    { "custom_ipaddr", show_value, show_value },
+    { "encmode", show_value, show_value },
+    { "auth", show_value, show_value},
+    { NULL, NULL, NULL }
+};
+
+/* brand^model^signal^ttynum^datatty^ctrltty^devname^flag */
+struct attr wan_wwan_probe_rule_attr[] = {
+    { "brand", show_value, show_value },
+    { "model", show_value, show_value },
+    { "signal", show_value, show_value },
+    { "ttynum", show_value, show_value },
+    { "datatty", show_value, show_value },
+    { "ctrltty", show_value, show_value },
+    { "devname", show_value, show_value },
+    { "flag", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* dnstype1[ispdns|custom|none]^dns1^dnstype2^dns2 */
+struct attr wan_dns_rule_attr[] = {
+    { "dnstype1", show_value, show_value },
+    { "dns1", show_value, show_value },
+    { "dnstype2", show_value, show_value },
+    { "dns2", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* dnstype1[ispdns|custom|none]^dns1^dnstype2^dns2 */
+struct attr wan_dnsv6_rule_attr[] = {
+    { "dnstype1", show_value, show_value },
+    { "dns1", show_value, show_value },
+    { "dnstype2", show_value, show_value },
+    { "dns2", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* XX:XX:XX:XX:XX:XX */
+struct attr wan_hwaddr_rule_default_attr[] = {
+    { "hwaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable[0|1]^hwaddr^addrtype[ipaddr|hwaddr]^ipaddr */
+struct attr wan_hwaddr_clone_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "hwaddr", show_value, show_value },
+    { "addrtype", show_value, show_value },
+    { "ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/** 
+ * name^enable[0|1]^type[dyndns|tzo|zoneedit]^
+ * username^passwd^hostname^server
+ */
+struct attr wan_ddns_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "type", show_value, show_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "hostname", show_value, show_value },
+    { "server", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/** 
+ * name^enable[0|1]^
+ * username^passwd^redirect[0|1]
+ */
+struct attr wan_opendns_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "redirect", show_value, show_value },
+    { "label", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+struct attr wan_st_rule_attr[] = {
+    { "uptime", show_value},
+    { NULL, NULL, NULL }
+};
+
+struct attr wan_stv6_rule_attr[] = {
+    { "uptime", show_value},
+    { NULL, NULL, NULL }
+};
+
+struct attr wan_up_down_state_rule_attr[] = {
+    { "v4", show_value},
+    { "v6", show_value},
+    { NULL, NULL, NULL }
+};
+
+struct attr lan_st_rule_attr[] = {
+    { "uptime", show_value},
+    { NULL, NULL, NULL }
+};
+
+struct attr lan_stv6_rule_attr[] = {
+    { "uptime", show_value},
+    { NULL, NULL, NULL }
+};
+
+struct attr wlan_st_rule_attr[] = {
+    { "uptime", show_value},
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^mtu^stp^weight */
+struct attr lan_main_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_value },
+    { "mtu", show_value, show_value },
+    { "stp", show_value, show_value },
+    { "weight", show_value, show_value },
+    { "snooping", show_value, show_value},
+    { NULL, NULL, NULL }
+};
+
+/* XX:XX:XX:XX:XX:XX */
+struct attr lan_hwaddr_rule_default_attr[] = {
+    { "hwaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* [0|1]^XX:XX:XX:XX:XX:XX */
+struct attr lan_hwaddr_clone_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "hwaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* Guest lan rule */
+/* enable^wif[ra0 ~ ra3]^bif[brxx]^lanid^ipaddr^netmask^bwen^bw[in kbits][0:disabled]^prio[1~3]^domain^start^count
+ * domain : domain name for this dns group
+ * start : dhcp offering start ip address
+ * count : total count dhcp server can offer
+ * */
+struct attr guest_lan_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "wif", show_value, show_value },
+    { "bif", show_value, show_value },
+    { "lanid", show_value, show_value },
+    { "ipaddr", show_value, show_value },
+    { "netmask", show_value, show_value },
+    { "bwen", show_value, show_value },
+    { "bw", show_value, show_value },
+    { "prio", show_value, show_value },
+    { "domain", show_value, show_value },
+    { "start", show_value, show_value },
+    { "count", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* ipaddr^mask^gateway^dns^wins^
+ * alias_enable^alias_ipaddr^alias_netmask^
+ * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
+struct attr lan_static_rule_attr[] = {
+    { "ipaddr", show_value, show_value },
+    { "mask", show_value, show_value },
+    { "gateway", show_value, show_value },
+    { "dns", show_value, show_value },
+    { "wins", show_value, show_value },
+    { "alias_enable", show_value, show_enable_value },
+    { "alias_ipaddr", show_value, show_value },
+    { "alias_netmask", show_value, show_value },
+    { "ipaddr_normal", show_value, show_value },
+    { "mask_normal", show_value, show_value },
+    { "ipaddr_ap", show_value, show_value },
+    { "mask_ap", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* pppoe_prefix^pppoe_suffix^static_prefix^static_suffix^dhcp_prefix^dhcp_suffix^
+ * length^gateway^dns^wins^alias_enable^alias_ipaddr^alias_netmask^
+ * ipaddr_normal^mask_normal^ipaddr_ap^mask_ap */
+struct attr lan_staticv6_rule_attr[] = {
+    { "pppoe_prefix", show_value, show_value },
+    { "pppoe_suffix", show_value, show_value },
+    { "static_prefix", show_value, show_value },
+    { "static_suffix", show_value, show_value },
+    { "dhcp_prefix", show_value, show_value },
+    { "dhcp_suffix", show_value, show_value },
+    { "length", show_value, show_value },
+    { "gateway", show_value, show_value },
+    { "dns", show_value, show_value },
+    { "wins", show_value, show_value },
+    { "alias_enable", show_value, show_enable_value },
+    { "alias_ipaddr", show_value, show_value },
+    { "alias_netmask", show_value, show_value },
+    { "ipaddr_normal", show_value, show_value },
+    { "mask_normal", show_value, show_value },
+    { "ipaddr_ap", show_value, show_value },
+    { "mask_ap", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^start^num^lease^domain^wins^
+ * dnstype^dnsaddr1^dnstype2^dnsaddr2^
+ * dnstype3^dnsaddr3^dnstype4^dnsaddr4 */
+struct attr lan_dhcps_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "start", show_value, show_value },
+    { "num", show_value, show_value },
+    { "lease", show_value, show_value },
+    { "domain", show_value, show_value },
+    { "wins", show_value, show_value },
+    { "dnstype", show_value, show_value},
+    { "dnsaddr1", show_value, show_value},
+    { "dnsaddr2", show_value, show_value},
+    { "dnsaddr3", show_value, show_value},   
+    { "dnsaddr4", show_value, show_value},
+    { "dnstype2", show_value, show_value},
+    { "dnstype3", show_value, show_value},
+    { "dnstype4", show_value, show_value},
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^pppoe_prefix^static_prefix^dhcp_prefix
+   ^dnstype[auto|custom]^dnsaddr1^dnsaddr2^type[1|0]^
+   start^end^lifetime" */
+struct attr lan_dhcpsv6_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "pppoe_prefix", show_value, show_value },
+    { "static_prefix", show_value, show_value },
+    { "dhcp_prefix", show_value, show_value },
+    { "domain", show_value, show_value },
+    { "dnstype", show_value, show_value },
+    { "dnsaddr1", show_value, show_value },
+    { "dnsaddr2", show_value, show_value },
+    { "type", show_value, show_enable_value },
+    { "start", show_value, show_value },
+    { "end", show_value, show_value },
+    { "lifetime", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/*interface^protocol
+*/
+struct attr rip_config_rule_attr[] = {
+    {"RIP_enable", show_value, show_value},
+    {"RIPv1_enable", show_value, show_value},
+    {"RIPv2_enable", show_value, show_value},
+	{"RIPng_enable", show_value, show_value},
+	{"RIPlan_enable", show_value, show_value},
+	{"RIPnglan_enable", show_value, show_value},
+	{"RIPwan_enable", show_value, show_value},
+	{"RIPngwan_enable", show_value, show_value},
+	{NULL,NULL,NULL}
+};
+
+
+ /*
+  * hwaddr0^hwaddr1^hwaddr2^hwaddr3
+  */
+struct attr wl0_wds_attr[] = {
+    { "hwaddr0", show_value, show_value },
+    { "hwaddr1", show_value, show_value },
+    { "hwaddr2", show_value, show_value },
+    { "hwaddr3", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable^bw_upload^bw_download */
+struct attr bw_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "bw_upload", show_value, show_value },
+    { "bw_download", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable */
+struct attr bw_monitor_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* catname */
+struct attr bw_ezmodesort_rule_attr[] = {
+    { "catname", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable^index^prio^cat^serv^
+   tcp_port[port|port_beg:port_end]^
+   udp_port[port|port_beg:port_end]^
+   lan_tcp_enable^lan_tcp_bw^lan_tcp_min[0:max bw|1:min bw]^
+   lan_udp_enable^lan_udp_bw^lan_udp_min[0:max bw|1:min bw]^
+   wan_tcp_enable^wan_tcp_bw^wan_tcp_min[0:max bw|1:min bw]^
+   wan_udp_enable^wan_udp_bw^wan_udp_min[0:max bw|1:min bw] */
+struct attr bw_app_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_value },
+    { "index", show_value, show_value },
+    { "prio", show_value, show_value },
+    { "cat", show_value, show_value },
+    { "serv", show_value, show_value },
+    { "tcp_port", show_value, show_value },
+    { "udp_port", show_value, show_value },
+    { "lan_tcp_enable", show_value, show_value },
+    { "lan_tcp_bw", show_value, show_value },
+    { "lan_tcp_min", show_value, show_value },
+    { "lan_udp_enable", show_value, show_value },
+    { "lan_udp_bw", show_value, show_value },
+    { "lan_udp_min", show_value, show_value },
+    { "wan_tcp_enable", show_value, show_value },
+    { "wan_tcp_bw", show_value, show_value },
+    { "wan_tcp_min", show_value, show_value },
+    { "wan_udp_enable", show_value, show_value },
+    { "wan_udp_bw", show_value, show_value },
+    { "wan_udp_min", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+struct attr snmpd_access_rule_attr[] = {
+    { "access_name", show_value, show_value },
+    { "group_name", show_value, show_value },
+    { "context", show_value, show_value },
+    { "mode", show_value, show_value },
+    { "levle", show_value, show_value },
+    { "match", show_value, show_value },
+    { "read", show_value, show_value },
+    { "write", show_value, show_value },
+    { "notify", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+struct attr snmpd_group_rule_attr[] = {
+	{ "group", show_value, show_value },
+    { "name", show_value, show_value },
+    { "version", show_value, show_value },
+    { "access", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+struct attr snmpd_view_rule_attr[] = {
+	{ "view", show_value, show_value },
+    { "name", show_value, show_value },
+    { "subtree", show_value, show_value },
+    { "mask", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable^inipaddr_start^inipaddr_end^proto^extif^
+   bw_towan^bw_tolan^apptype^prio^
+   outipaddr_start^outipaddr_end^inport^outport^reserve_bw */
+struct attr bw_sbm_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_value },
+    { "inipaddr_start", show_value, show_value },
+    { "inipaddr_end", show_value, show_value },
+    { "proto", show_value, show_value },
+    { "extif", show_value, show_value },
+    { "bw_towan", show_value, show_value },
+    { "bw_tolan", show_value, show_value },
+    { "apptype", show_value, show_value },
+    { "prio", show_value, show_value },
+    { "outipaddr_start", show_value, show_value },
+    { "outipaddr_end", show_value, show_value },
+    { "inport", show_value, show_value },
+    { "outport", show_value, show_value },
+    { "reserve_bw", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^srcipaddr_start^srcipaddr_end^dstipaddr_start^
+    dstipaddr_end^proto^srcport_start^srcport_end^dstport_start^
+    dstport_end^extif^routing_type[default|static]^gateway_ipaddr^
+    netmask^matric */
+struct attr rt_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "srcipaddr_start", show_value, show_value },
+    { "srcipaddr_end", show_value, show_value },
+    { "dstipaddr_start", show_value, show_value },
+    { "dstipaddr_end", show_value, show_value },
+    { "proto", show_value, show_proto_value },
+    { "srcport_start", show_value, show_value },
+    { "srcport_end", show_value, show_value },
+    { "dstport_start", show_value, show_value },
+    { "dstport_end", show_value, show_value },
+    { "extif", show_value, show_value },
+    { "routing_type", show_value, show_value },
+    { "gateway_ipaddr", show_value, show_value },
+    { "netmask", show_value, show_value },
+    { "matrix", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* rip[v1/v2/none] */
+struct attr rt_rip_rule_attr[] = {
+    { "rip", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable */
+struct attr nat_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+#ifdef CONFIG_EZP_ARCH_RT305X
+/* enable */
+struct attr hwnat_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+#endif
+
+/* activex_enable^java_enable^proxy_enable^cookie_enable^trustipaddr */
+struct attr wf_content_rule_attr[] = {
+    { "activex_enable", show_value, show_enable_value },
+    { "java_enable", show_value, show_enable_value },
+    { "proxy_enable", show_value, show_enable_value },
+    { "cookie_enable", show_value, show_enable_value },
+    { "url_enable", show_value, show_enable_value },
+    { "trustipaddr", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+ /* enable^keyword^type^access */
+struct attr wf_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "keyword", show_value, show_value },
+    { "type", show_value, show_value },
+    { "access", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable */
+struct attr igmp_proxy_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable^p1^p2^p3^p4 */
+struct attr igmp_snoop_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "p1", show_value, show_value },
+    { "p2", show_value, show_value },
+    { "p3", show_value, show_value },
+    { "p4", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^cat^month^date^wkday^beghr^begmin^endhr^endmin^wlanstatus */
+struct attr sched_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "cat", show_value, show_value },
+    { "month", show_value, show_value },
+    { "date", show_value, show_value },
+    { "wkday", show_value, show_value },
+    { "beghr", show_value, show_value },
+    { "begmin", show_value, show_value },
+    { "endhr", show_value, show_value },
+    { "endmin", show_value, show_value },
+    { "wlanstatus", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* method^server^path^inf_filename */
+ /* rule set 0 for default online firmware upgrade settings */
+struct attr fw_upgrade_rule_attr[] = {
+    { "method", show_value, show_value },
+    { "server", show_value, show_value },
+    { "path", show_value, show_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "inf_filename", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* method^server^path^inf_filename^release_note^filename
+    info_ok[1:got fw info | 0:no info]^
+    fw_ok[1:got fw | 0:no fw]^
+    relnote_ok[1:got release note | 0:no release note] */
+ /* rule set 0 for default online firmware upgrade settings */
+struct attr fw_info_rule_attr[] = {
+    { "model", show_value, show_value },
+    { "version", show_value, show_value },
+    { "revision", show_value, show_value },
+    { "date", show_value, show_value },
+    { "size", show_value, show_value },
+    { "filename", show_value, show_value },
+    { "release_note", show_value, show_value },
+    { "info_ok", show_value, show_value },
+    { "fw_ok", show_value, show_value },
+    { "relnote_ok", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* enable^ntp_enable[0|1]^ntp_interval */
+struct attr cron_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "ntp_enable", show_value, show_enable_value },
+    { "ntp_interval", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^type[pool|ipaddr]^pool^ipaddr^zone
+    custom_time^year^mon^date^hour^min^sec^
+    daylight_saving^
+    ds_start_mon^ds_start_day^ds_start_hour^
+    ds_end_mon^ds_end_day^ds_end_hour^customized^
+    custom_server[0|1]^serv_ipaddr */
+
+struct attr ntp_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "type", show_value, show_value },
+    { "pool", show_value, show_value },
+    { "ipaddr", show_value, show_value },
+    { "zone", show_value, show_value },
+    { "custom_time", show_value, show_value },
+    { "year", show_value, show_value },
+    { "mon", show_value, show_value },
+    { "date", show_value, show_value },
+    { "hour", show_value, show_value },
+    { "min", show_value, show_value },
+    { "sec", show_value, show_value },
+    { "daylight_saving", show_value, show_value },
+    { "ds_start_mon", show_value, show_value },
+    { "ds_start_day", show_value, show_value },
+    { "ds_start_hour", show_value, show_value },
+    { "ds_end_mon", show_value, show_value },
+    { "ds_end_day", show_value, show_value },
+    { "ds_end_hour", show_value, show_value },
+    { "customized", show_value, show_value },
+    { "custom_server", show_value, show_value },
+    { "serv_ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^ifname^vid^portmember^flag */
+struct attr vlan_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "ifname", show_value, show_value },
+    { "vid", show_value, show_value },
+    { "portmember", show_value, show_value },
+    { "flag", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^portid^pvid^tag^gmemb */
+struct attr vlanport_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "portid", show_value, show_value },
+    { "pvid", show_value, show_value },
+    { "tag", show_value, show_value },
+    { "gmemb", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^ifnames^flag */
+struct attr br_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "ifnames", show_value, show_value },
+    { "flag", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^port */
+struct attr ssh_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "port", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^ipaddr^ipt_enable^web_mgmt^dns^ppp^
+    upnp^wireless^ntp^sys_warning^dhcp_serv^dhcp_cli^
+    ddns^firewall */
+struct attr log_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "ipaddr", show_value, show_value },
+    { "ipt_enable", show_value, show_enable_value },
+    { "web_mgmt", show_value, show_enable_value },
+    { "dns", show_value, show_enable_value },
+    { "ppp", show_value, show_enable_value },
+    { "upnp", show_value, show_enable_value },
+    { "wireless", show_value, show_enable_value },
+    { "ntp", show_value, show_enable_value },
+    { "sys_warning", show_value, show_enable_value },
+    { "dhcp_serv", show_value, show_enable_value },
+    { "dhcp_cli", show_value, show_enable_value },
+    { "ddns", show_value, show_enable_value },
+    { "firewall", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^extif^inif^port */
+struct attr upnp_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "pmp_enable", show_value, show_enable_value },
+    { "extif", show_value, show_value },
+    { "inif", show_value, show_value },
+    { "port", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* friendlyName^manufacturer^manufacturerURL^modelDescription^
+  * modelName^modelNumber^modelURL^serialNumber^UDN^presentationURL */
+struct attr upnpxml_rule_attr[] = {
+    { "friendlyName", show_value, show_value },
+    { "manufacturer", show_value, show_value },
+    { "manufacturerURL", show_value, show_value },
+    { "modelDescription", show_value, show_value },
+    { "modelName", show_value, show_value },
+    { "modelNumber", show_value, show_value },
+    { "modelURL", show_value, show_value },
+    { "serialNumber", show_value, show_value },
+    { "UDN", show_value, show_value },
+    { "presentationURL", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* 
+ * name^enable[0|1]^extif^inif^proto^srcip^srcmask^dstip^dstmask^srcport^
+ * dstport^action[(0)DROP|(1)ACCEPT]^mark^bw_idx^sched_idx
+ */
+struct attr fl_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "extif", show_value, show_if_value },
+    { "inif", show_value, show_if_value },
+    { "srcipaddr_start", show_value, show_value },
+    { "srcipaddr_end", show_value, show_mask_value },
+    { "dstipaddr_start", show_value, show_value },
+    { "dstipaddr_end", show_value, show_mask_value},
+    { "proto", show_value, show_proto_value },
+    { "srcport_start", show_value, show_value },
+    { "srcport_end", show_value, show_value },
+    { "dstport_start", show_value, show_value },
+    { "dstport_end", show_value, show_value },
+    { "action", show_value, show_value },
+    { "mark", show_value, show_value },
+    { "bw_idx", show_value, show_value },
+    { "sched_idx", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^hwaddr^action^acl_enable^dhcp_enable^arp_enable^
+ * ipaddr */
+struct attr fl_hwaddr_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "hwaddr", show_value, show_value },
+    { "action", show_value, show_value },
+    { "acl_enable", show_value, show_enable_value },
+    { "arp_enable", show_value, show_enable_value },
+    { "dhcp_enable", show_value, show_enable_value },
+    { "ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable[0|1]^ipaddr */
+struct attr fr_dmz_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* TOS enable^icmp_enable^dns_enable^ssh_enable^
+   telnet_enable^check_enable^ack_enable */
+struct attr tos_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "icmp_enable", show_value, show_enable_value },
+    { "dns_enable", show_value, show_enable_value },
+    { "ssh_enable", show_value, show_enable_value },
+    { "telnet_enable", show_value, show_enable_value },
+    { "check_enable", show_value, show_enable_value },
+    { "ack_enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^value */
+struct attr ttl_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "value", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^rmgt_enable[0|1]^username^passwd^port^secipaddr^adm_timeout */
+struct attr http_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "rmgt_enable", show_value, show_enable_value },
+    { "username", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "port", show_value, show_value },
+    { "secipaddr", show_value, show_value },
+    { "adm_timeout", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+struct attr snmpd_user_rule_attr[] = {
+    {"enable",show_value, show_enable_value },
+    { "v1_enable", show_value, show_enable_value },
+    { "v2c_enable", show_value, show_enable_value },
+    { "usm_enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+struct attr snmpd_com2sec_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "access", show_value, show_value },
+    { "address", show_value, show_value },
+    { NULL, NULL, NULL }
+}; 
+ /* pingiface^pinghost^pingcnt^arpingiface^arpinghost^arpingcnt^tracerouteiface^traceroutehost^traceroutecnt */
+struct attr adtool_rule_attr[] = {
+    { "pingiface", show_value, show_value },
+    { "pinghost", show_value, show_value },
+    { "pingcnt", show_value, show_value },
+    { "arpingiface", show_value, show_value },
+    { "arpinghost", show_value, show_value },
+    { "arpingcnt", show_value, show_value },
+    { "tracerouteiface", show_value, show_value },
+    { "traceroutehost", show_value, show_value },
+    { "traceroutecnt", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* name^enable[0|1]^stime^ifnames */
+struct attr stats_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "stime", show_value, show_value },
+    { "ifnames", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+
+struct attr wol_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_value },
+    { "bcast", show_value, show_value },
+    { "hwaddr", show_value, show_value },
+    { "iface", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+ /* enable^syn_enable^icmp_enable^icmp_redir_enable
+    ^rpfilter_enable^state_enable */
+struct attr fw_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "syn_enable", show_value, show_enable_value },
+    { "icmp_enable", show_value, show_enable_value },
+    { "icmp_redir_enable", show_value, show_enable_value },
+    { "icmp_ping_enable", show_value, show_enable_value },
+    { "rpfilter_enable", show_value, show_enable_value },
+    { "state_enable", show_value, show_enable_value },
+    { "wantolan_enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+ /* enable^ipsec_enable^pptp_enable^l2tp_enable^
+    h323_enable^rtsp_enable^mms_enable */
+struct attr nat_pass_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "ipsec_enable", show_value, show_enable_value },
+    { "pptp_enable", show_value, show_enable_value },
+    { "l2tp_redir_enable", show_value, show_enable_value },
+    { "h323_enable", show_value, show_enable_value },
+    { "rtsp_enable", show_value, show_enable_value },
+    { "mms_enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+ /* ipsec_enable^pptp_enable^l2tp_enable
+    */
+struct attr smb_vpn_passthrough_rule_attr[] = {
+    { "ipsec_enable", show_value, show_enable_value },
+    { "pptp_enable", show_value, show_enable_value },
+    { "l2tp_enable", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+/* For new added wireless rules */
+/* Physical interface related rules*/
+/* enable^net_mode^txpower^channel^bisolation */
+struct attr wl_basic_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "net_mode", show_value, show_value },
+    { "txpower", show_value, show_value },
+    { "channel", show_value, show_value },
+    { "bisolation", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable */
+struct attr wl_origset_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+/*                                                                                                name^enable^mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init^ike_keymode^psk^rsa^ca^adv^phase1_mode^phase1_auth^phase1_encrypt^phase1_group^phase1_id^phase2_auth^phase2_encrypt^phase2_group^phase1_lifetime^phase2_lifetime^dpd_enable^dpd_interval^dpd_timeout */
+struct attr ipsec_rule_attr[] = {
+	{ "name", show_value, show_value },
+	{ "enable", show_value, show_value },
+	{ "mode", show_value, show_value },
+	{ "l2tp", show_value, show_value },
+	{ "local_extif", show_value, show_value },
+	{ "local_inipaddr", show_value, show_value },
+	{ "local_netmask", show_value, show_value },
+	{ "remote_gateway", show_value, show_value },
+	{ "remote_inipaddr", show_value, show_value },
+	{ "remote_netmask", show_value, show_value },
+	{ "conn_init", show_value, show_value },
+	{ "ike_keymode", show_value, show_value },
+	{ "psk", show_value, show_value },
+	{ "rsa", show_value, show_value },
+	{ "ca", show_value, show_value },
+	{ "adv", show_value, show_value },
+	{ "phase1_mode", show_value, show_value },
+	{ "phase1_id", show_value, show_value },
+	{ "phase1_lifetime", show_value, show_value },
+	{ "phase2_lifetime", show_value, show_value },
+	{ "phase1_auth", show_value, show_value },
+	{ "phase1_encrypt", show_value, show_value },
+	{ "phase1_group", show_value, show_value },
+	{ "phase2_auth", show_value, show_value },
+	{ "phase2_encrypt", show_value, show_value },
+	{ "phase2_group", show_value, show_value },
+	{ "dpd_enable", show_value, show_value },
+	{ "dpd_interval", show_value, show_value },
+	{ "dpd_timeout", show_value, show_value },
+	{ NULL, NULL, NULL }
+};
+
+/* phase1[none|established]^phase2[none|established] */
+struct attr ipsec_status_rule_attr[] = {
+	{ "phase1", show_value, show_value },
+	{ "phase2", show_value, show_value },
+	{ NULL, NULL, NULL }
+};
+
+/* enable[0|1]^name^redialperiod^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns_auto_enable[0|1]^dns^chap_enable[0|1]^mschap_enable[0|1]^mschapv2_enable[0|1]^eap_enable[0|1]^pap_enable[0|1]^mppe128_enable[0|1]^proxyarp_enable[0|1]^nat_enable[0|1] */
+struct attr pptpd_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "name", show_value, show_value },
+    { "redialperiod", show_value, show_value },
+    { "mtu", show_value, show_value },
+    { "mru", show_value, show_value },
+    { "localip", show_value, show_value },
+    { "localip_range", show_value, show_value },
+    { "remoteip", show_value, show_value },
+    { "remoteip_range", show_value, show_value },
+    { "dns_auto_enable", show_value, show_value },
+    { "dns", show_value, show_value },
+    { "chap_enable", show_value, show_value },
+    { "mschap_enable", show_value, show_value },
+    { "mschapv2_enable", show_value, show_value },
+    { "eap_enable", show_value, show_value },
+    { "pap_enable", show_value, show_value },
+    { "mppe128_enable", show_value, show_value },
+    { "proxyarp_enable", show_value, show_value },
+    { "nat_enable", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+struct attr pptpd_user_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "username", show_value, show_value },
+    { "provider", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable[0|1]^name^mtu^mru^localip^localip_range^remoteip^remoteip_range^dns^proxyarp_enable[0|1]^nat_enable[0|1] */
+struct attr l2tpd_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "name", show_value, show_value },
+    { "mtu", show_value, show_value },
+    { "mru", show_value, show_value },
+    { "localip", show_value, show_value },
+    { "localip_range", show_value, show_value },
+    { "remoteip", show_value, show_value },
+    { "remoteip_range", show_value, show_value },
+    { "dns_auto_enable", show_value, show_value },
+    { "dns", show_value, show_value },
+    { "chap_enable", show_value, show_value },
+    { "pap_enable", show_value, show_value },
+    { "proxyarp_enable", show_value, show_value },
+    { "nat_enable", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+struct attr l2tpd_user_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "username", show_value, show_value },
+    { "provider", show_value, show_value },
+    { "passwd", show_value, show_value },
+    { "ipaddr", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* infra^ap_mode^rateset^mrate^frag^rts^dtim^bcn^plcphdr^
+   antdiv^gmode^gmode_protection^afterburner^frameburst
+   txburst[0:disable|1:enable->1]^
+   pktaggr[0:disable|1:enable->0]^
+   txmode[0:None|1:CCK|2:OFDM->0]^
+
+   rdg[0:disable|1:enablei->0]^
+   linkadapt[0:disable|1:enable->0]^
+   htc[0:disable|1:enable->0]^
+
+   htbw[0:20|1:20/40->1]^
+   gi[0:long|1:short->1]^
+   opmode[0:mixed|1:GreenField->0]^
+   mcs[0~15,32,33=auto->33]^
+   mpdu[0 none, 1~7 -> 5]^
+   amsdu[0:disable|1:enable->0]^
+
+   autoba[0:disable|1:enable->1]^
+   bawinsize[1~64,default=8,iot=64->64]^
+   badecline[0:disable|1:enable->1->0]^
+   extcha^wdstxmode[CCK|OFDM|HTMIX|GREENFIELD]
+   antennamode [1:external0:internal]*/
+struct attr wl_advanced_rule_attr[] = {
+    { "infra", show_value, show_value },
+    { "ap_mode", show_value, show_value },
+    { "rateset", show_value, show_value },
+    { "mrate", show_value, show_value },
+    { "frag", show_value, show_value },
+    { "rts", show_value, show_value },
+    { "dtim", show_value, show_value },
+    { "bcn", show_value, show_value },
+    { "plcphdr", show_value, show_value },
+    { "antdiv", show_value, show_value },
+    { "gmode", show_value, show_value },
+    { "gmode_protection", show_value, show_value },
+    { "afterburner", show_value, show_value },
+    { "frameburst", show_value, show_value },
+    { "txburst", show_value, show_enable_value},
+    { "pktaggr", show_value, show_enable_value},
+    { "txmode", show_value, show_value},
+
+    { "rdg", show_value, show_enable_value},
+    { "linkadapt", show_value, show_enable_value},
+    { "htc", show_value, show_enable_value},
+
+    { "htbw", show_value, show_enable_value},
+    { "gi", show_value, show_enable_value},
+    { "opmode", show_value, show_value},
+    { "mcs", show_value, show_value},
+    { "mpdu", show_value, show_value},
+    { "amsdu", show_value, show_enable_value},
+    { "autoba", show_value, show_enable_value},
+    { "bawinsize", show_value, show_value},
+    { "badecline", show_value, show_enable_value},
+    { "extcha", show_value, show_value},
+    { "wdstxmode", show_value, show_value},
+    { "antennamode", show_value, show_value},
+    { NULL, NULL, NULL }
+};
+
+/* mode^peer_list^timeout */
+/* mode:0 disabled 1:restrict 2:bridge 3:repeater 4:lazy*/
+struct attr wl_wds_rule_attr[] = {
+    { "mode", show_value, show_value },
+    { "timeout", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* sta_bk^Sta_be^sta_vi^sta_vo^ap_bk^ap_be^ap_vi^ap_vo^no_ack^max_assoc */
+struct attr wl_wme_rule_attr[] = {
+    { "sta_bk", show_value, show_value },
+    { "sta_be", show_value, show_value },
+    { "sta_vi", show_value, show_value },
+    { "sta_vo", show_value, show_value },
+    { "ap_bk", show_value, show_value },
+    { "ap_be", show_value, show_value },
+    { "ap_vi", show_value, show_value },
+    { "ap_vo", show_value, show_value },
+    { "no_ack", show_value, show_value },
+    { "max_assoc", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* mode[normal|ap|ur|wisp]^
+ * auto_bridge[0: normal mode|1:auto bridge mode|2:auto ip mode]^
+ * ab_status[0:auto bridge/ip not change|1:auto bridge/ip changed] */
+struct attr wl_mode_rule_attr[] = {
+    { "mode", show_value, show_value },
+    { "auto_bridge", show_value, show_enable_value },
+    { "ab_status", show_value, show_enable_value },
+    { NULL, NULL, NULL }
+};
+
+/* mode[0:disabled|7:enabled]^pin^configured[0:unconfigured|1:configured] */
+struct attr wl_wps_rule_attr[] = {
+    { "mode", show_value, show_value },
+    { "pin", show_value, show_value },
+    { "configured", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* mode[0:disabled|1:pin mode|2:PBC mode]^pin^reg_ssid^reg_auth^reg_enc^reg_keyindex^reg_key */
+struct attr wl_wps_sta_rule_attr[] = {
+    { "mode", show_value, show_value },
+    { "pin", show_value, show_value },
+    { "reg_ssid", show_value, show_value },
+    { "reg_auth", show_value, show_value },
+    { "reg_enc", show_value, show_value },
+    { "reg_keyindex", show_value, show_value },
+    { "reg_key", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* wl^wps */
+struct attr wl_led_status_rule_attr[] = {
+    { "wl", show_value, show_value },
+    { "wps", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* Virtual interface related rules for wl0/wl1/wl2/wl3 */
+/* enable^hidden^rate^wme^isolation */
+struct attr wlv_basic_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "hidden", show_value, show_value },
+    { "rate", show_value, show_value },
+    { "wme", show_value, show_value },
+    { "isolation", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* ifname */
+struct attr wlv_ifname_rule_attr[] = {
+    { "ifname", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* ssid */
+struct attr wlv_ssid_rule_attr[] = {
+    { "ssid", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* secmode */
+struct attr wlv_sec_rule_attr[] = {
+    { "secmode", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* key_index^key1^key2^key3^key4^
+ * keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+struct attr wlv_sec_wep_rule_attr[] = {
+    { "key_index", show_value, show_value },
+    { "key1", show_value, show_value },
+    { "key2", show_value, show_value },
+    { "key3", show_value, show_value },
+    { "key4", show_value, show_value },
+    { "keytype", show_value, show_value },
+    { "encmode", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+ * rekey_time_interval^rekey_pkt_interval^session_timeout */
+struct attr wlv_sec_wpa_rule_attr[] = {
+    { "key", show_value, show_value },
+    { "crypto", show_value, show_value },
+    { "radius_key", show_value, show_value },
+    { "radius_ipaddr", show_value, show_value },
+    { "radius_port", show_value, show_value },
+    { "rekey_mode", show_value, show_value },
+    { "rekey_time_interval", show_value, show_value },
+    { "rekey_pkt_interval", show_value, show_value },
+    { "session_timeout", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^
+ * rekey_time_interval^rekey_pkt_interval^preauth^pmkperiod^session_timeout */
+struct attr wlv_sec_wpa2_rule_attr[] = {
+    { "key", show_value, show_value },
+    { "crypto", show_value, show_value },
+    { "radius_key", show_value, show_value },
+    { "radius_ipaddr", show_value, show_value },
+    { "radius_port", show_value, show_value },
+    { "rekey_mode", show_value, show_value },
+    { "rekey_time_interval", show_value, show_value },
+    { "rekey_pkt_interval", show_value, show_value },
+    { "preauth", show_value, show_value },
+    { "pmkperiod", show_value, show_value },
+    { "session_timeout", show_value, show_value },
+    { "wpacap", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable^defpolicy */
+struct attr wlv_acl_basic_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "defpolicy", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* name^enable^mac^policy */
+struct attr wlv_acl_rule_attr[] = {
+    { "name", show_value, show_value },
+    { "enable", show_value, show_enable_value },
+    { "mac", show_value, show_value },
+    { "policy", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* wds related rules */
+/* hwaddr^secmode */
+struct attr wl_wds_basic_rule_attr[] = {
+    { "hwaddr", show_value, show_value },
+    { "secmode", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* key */
+struct attr wl_wds_sec_wep_rule_attr[] = {
+    { "key", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* key^crypto */
+struct attr wl_wds_sec_wpa_rule_attr[] = {
+    { "key", show_value, show_value },
+    { "crypto", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable^ssid^bssid^secmode */
+struct attr wl_apcli_rule_attr[] = {
+    { "enable", show_value, show_value },
+    { "ssid", show_value, show_value },
+    { "bssid", show_value, show_value },
+    { "secmode", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* key_index^key1^key2^key3^key4^keytype[0:hex|1:ascii]^encmode[open|shared|auto] */
+struct attr wl_apcli_sec_wep_rule_attr[] = {
+    { "key_index", show_value, show_value },
+    { "key1", show_value, show_value },
+    { "key2", show_value, show_value },
+    { "key3", show_value, show_value },
+    { "key4", show_value, show_value },
+    { "keytype", show_value, show_value },
+    { "encmode", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* key^crypto */
+struct attr wl_apcli_sec_wpa_rule_attr[] = {
+    { "key", show_value, show_value },
+    { "crypto", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+
+/* enable^city^degree */
+struct attr weather_rule_attr[] = {
+    { "enable", show_value, show_enable_value },
+    { "city", show_value, show_value },
+    { "degree", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+/* mode 2.4g or 5g */
+struct attr wl_ezsy_mode_rule_attr[] = {
+    { "mode", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+/* wisp mode 2.4g as wisp,5g as Ap or 2.4g as AP,5g as wisp */
+struct attr wl_wisp_mode_rule_attr[] = {
+    { "mode2.4g", show_value, show_value },
+    { "mode5g", show_value, show_value },
+    { NULL, NULL, NULL }
+};
+struct rule {
+    char *name;
+    struct attr *attr;
+};
+
+struct rule rules[] = {
+    {"rip_conf_rule", rip_config_rule_attr},
+    {"rip_conf_rule_default", rip_config_rule_attr},	
+    { "fr_rule", fr_rule_attr },
+    { "vs_rule", vs_rule_attr },
+    { "pt_rule", pt_rule_attr },
+    { "fl_rule", fl_rule_attr },
+    { "fr_dmz_rule", fr_dmz_rule_attr },
+    { "fl_hwaddr_rule", fl_hwaddr_rule_attr },
+    { "wan_main_rule", wan_main_rule_attr },
+    { "wan_static_rule", wan_static_rule_attr },
+    { "wan_dhcp_rule", wan_dhcp_rule_attr },
+    { "wan_pppoe_rule", wan_pppoe_rule_attr },
+    { "wan_staticv6_rule", wan_staticv6_rule_attr },
+    { "wan_dhcpv6_rule", wan_dhcpv6_rule_attr },
+    { "wan_tunnel6_rule", wan_tunnel6_rule_attr },
+    { "wan_pppoev6_rule", wan_pppoev6_rule_attr },
+    { "wan_wwan_rule", wan_wwan_rule_attr },
+    { "wan_pptp_l2tp_rule", wan_pptp_l2tp_rule_attr },
+    { "wan_wwan_probe_rule", wan_wwan_probe_rule_attr },
+    { "wan_bigpond_rule", wan_bigpond_rule_attr },
+    { "wan_dns_rule", wan_dns_rule_attr },
+    { "wan_dnsv6_rule", wan_dnsv6_rule_attr },
+    { "wan_hwaddr_rule_default", wan_hwaddr_rule_default_attr},
+    { "wan_hwaddr_clone_rule", wan_hwaddr_clone_rule_attr },
+    { "wan_ddns_rule", wan_ddns_rule_attr },
+    { "wan_opendns_rule", wan_opendns_rule_attr },
+    { "wan_st_rule", wan_st_rule_attr },
+    { "wan_stv6_rule", wan_stv6_rule_attr },
+    { "wan_up_down_state_rule", wan_up_down_state_rule_attr },
+    { "lan_st_rule", lan_st_rule_attr },
+    { "lan_stv6_rule", lan_stv6_rule_attr },
+    { "wlan_st_rule", wlan_st_rule_attr },
+    { "lan_main_rule", lan_main_rule_attr },
+    { "lan_hwaddr_rule_default", lan_hwaddr_rule_default_attr },
+    { "lan_hwaddr_clone_rule", lan_hwaddr_clone_rule_attr },
+    { "guest_lan_rule", guest_lan_rule_attr },
+    { "guest1_lan_rule", guest_lan_rule_attr },
+    { "lan_static_rule", lan_static_rule_attr },
+    { "lan_staticv6_rule", lan_staticv6_rule_attr },
+    { "lan_static_rule_default", lan_static_rule_attr },
+    { "lan_dhcps_rule", lan_dhcps_rule_attr },
+    { "lan_dhcpsv6_rule", lan_dhcpsv6_rule_attr },
+    /* XXX: TODO: Fix this in the future. */
+    { "wl0_wds", wl0_wds_attr },
+    { "bw_rule", bw_rule_attr },
+    { "bw_monitor_rule", bw_monitor_rule_attr },
+    { "bw_ezmodesort_rule", bw_ezmodesort_rule_attr },
+    { "bw_app_rule", bw_app_rule_attr },
+    { "snmpd_access_rule", snmpd_access_rule_attr },
+    { "snmpd_group_rule", snmpd_group_rule_attr },
+    { "snmpd_view_rule", snmpd_view_rule_attr },
+    { "bw_sbm_rule", bw_sbm_rule_attr },
+    { "rt_rule", rt_rule_attr },
+    { "rt_rip_rule" , rt_rip_rule_attr },
+    { "nat_rule" , nat_rule_attr },
+#ifdef CONFIG_EZP_ARCH_RT305X
+    { "hwnat_rule" , nat_rule_attr },
+#endif
+    { "wf_content_rule", wf_content_rule_attr },
+    { "wf_rule", wf_rule_attr },
+    { "igmp_proxy_rule", igmp_proxy_rule_attr },
+    { "igmp_snoop_rule", igmp_snoop_rule_attr },
+    { "sched_rule", sched_rule_attr },
+    { "sched1_rule", sched_rule_attr },
+    { "fw_upgrade_rule", fw_upgrade_rule_attr },
+    { "fw_info_rule", fw_info_rule_attr },
+    { "cron_rule", cron_rule_attr },
+    { "vlan_rule", vlan_rule_attr },
+    { "vlanport_rule", vlanport_rule_attr },
+    { "br_rule", br_rule_attr },
+    { "ntp_rule", ntp_rule_attr },
+    { "ssh_rule", ssh_rule_attr },
+    { "log_rule", log_rule_attr },
+    { "ttl_rule", ttl_rule_attr },
+    { "tos_rule", tos_rule_attr },
+    { "upnp_rule", upnp_rule_attr },
+    { "upnpxml_rule", upnpxml_rule_attr },
+    { "http_rule", http_rule_attr },
+	{ "snmpd_user_rule", snmpd_user_rule_attr},
+	{ "snmpd_com2sec_rule", snmpd_com2sec_rule_attr},
+    { "adtool_rule", adtool_rule_attr },
+    { "http_rule_default", http_rule_attr },
+	{ "snmpd_user_rule_default", snmpd_user_rule_attr},
+	{ "snmpd_com2sec_rule_default", snmpd_com2sec_rule_attr},
+    { "stats_rule", stats_rule_attr },
+    { "wol_rule", wol_rule_attr },
+/* add by william for ipsec start*/
+	/*ipsec*/
+	{ "ipsec_rule", ipsec_rule_attr },
+	{ "ipsec_status_rule", ipsec_status_rule_attr },
+	/*pptpd*/
+    { "pptpd_rule", pptpd_rule_attr },
+    { "pptpd_user_rule", pptpd_user_rule_attr },
+	/*l2tpd*/
+    { "l2tpd_rule", l2tpd_rule_attr },
+    { "l2tpd_user_rule", pptpd_user_rule_attr },
+
+    { "smb_vpn_passthrough_rule", smb_vpn_passthrough_rule_attr },
+/* add by william for ipsec end*/
+    { "fw_rule", fw_rule_attr },
+    { "nat_pass_rule", nat_pass_rule_attr },
+    { "wl_basic_rule", wl_basic_rule_attr },
+    { "wl5g_basic_rule", wl_basic_rule_attr },
+    { "wl_origset_rule", wl_origset_rule_attr },
+    { "wl1_origset_rule", wl_origset_rule_attr },
+    { "wl_advanced_rule", wl_advanced_rule_attr },
+    { "wl1_advanced_rule", wl_advanced_rule_attr },
+    { "wl_wds_rule", wl_wds_rule_attr },
+    { "wl1_wds_rule", wl_wds_rule_attr },
+    { "wl_wme_rule", wl_wme_rule_attr },
+    { "wl_mode_rule", wl_mode_rule_attr },
+    { "wl1_mode_rule", wl_mode_rule_attr },
+    { "wl_wps_rule", wl_wps_rule_attr },
+    { "wl1_wps_rule", wl_wps_rule_attr },
+    { "wl_wps_sta_rule", wl_wps_sta_rule_attr },
+    { "wl1_wps_sta_rule", wl_wps_sta_rule_attr },
+    { "wl_led_status_rule", wl_led_status_rule_attr },
+    { "wl0_basic_rule", wlv_basic_rule_attr },
+    { "wl1_basic_rule", wlv_basic_rule_attr },
+    { "wl0_ifname_rule", wlv_ifname_rule_attr },
+    { "wl0_ssid_rule", wlv_ssid_rule_attr },
+    { "wl0_sec_rule", wlv_sec_rule_attr },
+    { "wl0_sec_wep_rule", wlv_sec_wep_rule_attr },
+    { "wl0_sec_wpa_rule", wlv_sec_wpa_rule_attr },
+    { "wl0_sec_wpa2_rule", wlv_sec_wpa2_rule_attr },
+    { "wl00_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl00_acl_rule", wlv_acl_rule_attr },
+    { "wl01_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl01_acl_rule", wlv_acl_rule_attr },
+    { "wl02_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl02_acl_rule", wlv_acl_rule_attr },
+    { "wl03_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl03_acl_rule", wlv_acl_rule_attr },
+    { "wl1_ifname_rule", wlv_ifname_rule_attr },
+    { "wl1_ssid_rule", wlv_ssid_rule_attr },
+    { "wl1_sec_rule", wlv_sec_rule_attr },
+    { "wl1_sec_wep_rule", wlv_sec_wep_rule_attr },
+    { "wl1_sec_wpa_rule", wlv_sec_wpa_rule_attr },
+    { "wl1_sec_wpa2_rule", wlv_sec_wpa2_rule_attr },
+    { "wl10_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl10_acl_rule", wlv_acl_rule_attr },
+    { "wl11_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl11_acl_rule", wlv_acl_rule_attr },
+    { "wl12_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl12_acl_rule", wlv_acl_rule_attr },
+    { "wl13_acl_basic_rule", wlv_acl_basic_rule_attr },
+    { "wl13_acl_rule", wlv_acl_rule_attr },
+    { "wl0_wds_basic_rule", wl_wds_basic_rule_attr },
+    { "wl0_wds_sec_wep_rule", wl_wds_sec_wep_rule_attr },
+    { "wl0_wds_sec_wpa_rule", wl_wds_sec_wpa_rule_attr },
+    { "wl1_wds_basic_rule", wl_wds_basic_rule_attr },
+    { "wl1_wds_sec_wep_rule", wl_wds_sec_wep_rule_attr },
+    { "wl1_wds_sec_wpa_rule", wl_wds_sec_wpa_rule_attr },
+    { "wl0_apcli_rule", wl_apcli_rule_attr },
+    { "wl0_apcli_sec_wep_rule", wl_apcli_sec_wep_rule_attr },
+    { "wl0_apcli_sec_wpa_rule", wl_apcli_sec_wpa_rule_attr },
+    { "wl0_apcli_sec_wpa2_rule", wl_apcli_sec_wpa_rule_attr },
+    { "wl1_wds_basic_rule", wl_wds_basic_rule_attr },
+    { "wl1_wds_sec_wep_rule", wl_wds_sec_wep_rule_attr },
+    { "wl1_wds_sec_wpa_rule", wl_wds_sec_wpa_rule_attr },
+    { "wl1_apcli_rule", wl_apcli_rule_attr },
+    { "wl1_apcli_sec_wep_rule", wl_apcli_sec_wep_rule_attr },
+    { "wl1_apcli_sec_wpa_rule", wl_apcli_sec_wpa_rule_attr },
+    { "wl1_apcli_sec_wpa2_rule", wl_apcli_sec_wpa_rule_attr },
+    { "weather_rule", weather_rule_attr },
+    { "wl_easy_mode_rule", wl_ezsy_mode_rule_attr },
+    { "wl_wisp_mode_rule", wl_wisp_mode_rule_attr },
+	{ NULL, NULL }
+};
+
+#define MAX_ATTR_NUM    32
+static int
+sep_string(char *word, const char *delim, char **idx_arr, int max_tok)
+{
+    char *str = word;
+    char *ptr;
+    int pos = 0;
+    int i;
+
+    for (i = 0; i < max_tok; i++) {
+        idx_arr[i] = NULL;
+    }
+
+    while (str) {
+        ptr = strsep(&str, delim);
+        if (ptr && pos < max_tok) {
+            idx_arr[pos++] = ptr;
+        } else {
+            break;
+        }
+    }
+    return pos;
+}
+
+/**
+ * \brief Get a specified rule set from nvram, parse it by '|' character, 
+ * and copy the obtained rule into the given buffer.
+ * \return Return the length of the rule if successful. Otherwise, a negative
+ * indicates an error.
+ * NOTE: If the return value is larger than or equal to bsize, it means the 
+ * rule is truncated.
+ * \param[in] rule_set: a point to the specific rule name. Eg., fr_rule
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[out] buf: a pointer to a buffer for copying the parsed data.
+ * \param[in] bsize: to specify the size of the imported area.
+ */
+int
+ezplib_get_rule(char *rule_set, int nth, char *buf, int bsize)
+{
+    char tmp[EZPLIB_BUF_LEN];
+    char *next;
+    char *wordlist;
+    char *str, *ptr;
+    int ret;
+
+    assert(strlen(RULE_SEP) == 1);
+
+    if (!buf) {
+        return EZPLIB_INVALID;
+    }
+
+    /* Clean up the buffer that carries the retrieved value. */
+    memset(buf, '\0', bsize);
+
+    if (!rule_set || !*rule_set) {
+        return EZPLIB_INVALID;
+    }
+
+    wordlist = nvram_get(rule_set);
+    if (!wordlist) {
+        return EZPLIB_NO_RULE_SET;
+    }
+
+    if (!*wordlist) {
+        return EZPLIB_NO_RULE;
+    }
+
+    ret = snprintf(tmp, EZPLIB_BUF_LEN, "%s", wordlist);
+    if (ret >= EZPLIB_BUF_LEN) {
+        return EZPLIB_VAL_TRUNC;
+    }
+
+    str = tmp;
+    while (str) {
+        ptr = strsep(&str, RULE_SEP);
+        if (!ptr) {
+            return EZPLIB_NO_RULE;
+        }
+
+        if (nth != 0) {
+            nth --;
+            continue;
+        }
+        ret = snprintf(buf, bsize, ptr);
+        if (ret >= bsize) {
+            return EZPLIB_VAL_TRUNC;
+        }
+        return ret;
+    }
+
+    if (nth >= 0) {
+        return EZPLIB_NO_RULE;
+    }
+    return 0;
+}
+
+/**
+ * \brief Get a specified rule set from nvram, parse it by '|' character, 
+ * and copy the obtained rule into the given buffer.
+ * \return Return the length of the rule if successful. Otherwise, a negative
+ * indicates an error.
+ * NOTE: If the return value is larger than or equal to bsize, it means the 
+ * rule is truncated.
+ * \param[in] rule_set: a point to the specific rule name. Eg., fr_rule
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[in] start: to specify the position of the start attribute 
+ *                   in the rule set.
+ * \param[in] end: to specify the position of the end attribute 
+ *                 in the rule set.
+ * \param[out] buf: a pointer to a buffer for copying the parsed data.
+ * \param[in] bsize: to specify the size of the imported area.
+ */
+int
+ezplib_get_subrule(char *rule_set, int nth, int start, int end,
+        char *buf, int bsize)
+{
+    char *ptr_array[MAX_ATTR_NUM];
+    char word[EZPLIB_BUF_LEN];
+    int ret, i, j, len;
+
+    if (!rule_set || !*rule_set || !buf) {
+        return EZPLIB_INVALID;
+    }
+
+    if (start > end) {
+        return EZPLIB_INVALID;
+    }
+
+    /**
+     * Clean up the buffer for carrying on the retrieved value, in case errors
+     * happen while processing of attribute.
+     */
+    memset(buf, '\0', bsize);
+
+    ret = ezplib_get_rule(rule_set, nth, word, EZPLIB_BUF_LEN);
+    if (ret < 0) {
+        return ret;
+    }
+
+    sep_string(word, ATTR_SEP, ptr_array, MAX_ATTR_NUM);
+    for (i = j = 0; i < MAX_ATTR_NUM; i++) {
+        if (!ptr_array[i]) {
+            break;
+        }
+        if (start <= i && i <= end) {
+            len = snprintf(buf + j, bsize - j, "%s%s", ptr_array[i], ATTR_SEP);
+            j += len;
+        }
+    }
+
+    if (j > 0 && buf[j-1]) {
+        /* Remove the last ATTR_SEP. */
+        buf[j-1] = '\0'; 
+    }
+
+    return 0;
+}
+
+/**
+ * \brief Get a specified attribute of the given rule from the rule set in 
+ * nvram. The rules are separated by RULE_SEP character and the attributes
+ * in a rule are separated by ATTR_SEP character.
+ * \return Return the length of the attribute if successful. Otherwise, a 
+ * negative indicates an error.
+ * \param[in] rule_set: a point to the specific rule name. Eg., fr_rule
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[in] type: a pointer to the specified type of attribute.
+ * \param[out] buf: a pointer to a buffer for copying the parsed data.
+ * \param[in] bsize: to specify the size of the imported area.
+ */
+int 
+ezplib_get_attr_val(char *rule_set, int nth, char *type, char *buf, int bsize, 
+                    int use)
+{
+    char *ptr_array[MAX_ATTR_NUM];
+    char word[EZPLIB_BUF_LEN];
+    int ret, i;
+
+
+    if (!rule_set || !*rule_set || !type || !*type || !buf) {
+        return EZPLIB_INVALID;
+    }
+
+    /**
+     * Clean up the buffer for carrying on the retrieved value, in case errors
+     * happen while processing of attribute.
+     */
+    memset(buf, '\0', bsize);
+
+    ret = ezplib_get_rule(rule_set, nth, word, EZPLIB_BUF_LEN);
+    if (ret < 0) {
+        return ret;
+    }
+
+    sep_string(word, ATTR_SEP, ptr_array, MAX_ATTR_NUM);
+    for (i = 0; rules[i].name; i++) {
+        struct attr *attr;
+        int j;
+        if (strcmp(rules[i].name, rule_set) != 0) {
+            continue;
+        }
+    
+        attr = rules[i].attr;
+        for (j = 0; attr[j].name && ptr_array[j]; j++) {
+            if (strcmp(attr[j].name, type) == 0) {
+                if (use == EZPLIB_USE_CLI && attr[j].func_orig) {
+                    /* Don't wrap. Just get the value stored in nvram. */
+                    return attr[j].func_orig(type, ptr_array[j], 
+                                             buf, bsize);
+                } else if (use == EZPLIB_USE_WEB && attr[j].func_wrap) {
+                    /* Wrap the value from nvram. Eg., the attribute
+                     * <enable> is 1 will be wrapped to 'checked'.
+                     */
+                    return attr[j].func_wrap(type, ptr_array[j], buf, 
+                                             bsize);
+                }
+            }
+        }
+    }
+
+    return EZPLIB_NO_ATTRIBUTE;
+}
+
+enum opcode {
+    ADD_RULE = 0,
+    DELETE_RULE = 1,
+    REPLACE_RULE = 2
+};
+
+static int 
+ezplib_op_rule(char *rule_set, enum opcode op, int nth, char *new_rule)
+{
+    char buf[EZPLIB_BUF_LEN];
+    char word[EZPLIB_BUF_LEN];
+    char *wordlist;
+    char *ptr;
+    int len, ret, i, rule_num;
+    char *rule_sep = RULE_SEP;
+
+    /* Get the number of rules in the rule set. */
+    rule_num = ezplib_get_rule_num(rule_set);
+    if (rule_num < 0) {
+        return EZPLIB_NO_RULE_SET;
+    }
+    
+    len = EZPLIB_BUF_LEN;
+    ptr = buf;
+    for (i = 0; i < rule_num; i++) {
+        char *rule;
+        ret = ezplib_get_rule(rule_set, i, word, EZPLIB_BUF_LEN);
+        if (ret < 0) {
+            return ret;
+        }
+
+        if (i != nth) {
+            ret = snprintf(ptr, len, "%s%s", word, RULE_SEP);
+            if (ret >= len) {
+                return EZPLIB_VAL_TRUNC;
+            }
+        } else {
+            switch (op) {
+                case ADD_RULE:
+                    ret = snprintf(ptr, len, "%s%s", new_rule, RULE_SEP);
+                    if (ret >= len) {
+                        return EZPLIB_VAL_TRUNC;
+                    }
+
+                    /**
+                     * Disable nth so that the following flow will only go
+                     * through the block of 'if (i != nth)'.
+                     */
+                    nth = -1;
+
+                    /* Re-fetch the ith rule for the next round loop. */
+                    i--;
+                    break;
+                case DELETE_RULE:
+                    /* Do nothing but ignore on the old, fetched rule. */
+                    continue;
+                    break;
+                case REPLACE_RULE:
+                    ret = snprintf(ptr, len, "%s%s", new_rule, RULE_SEP);
+                    if (ret >= len) {
+                        return EZPLIB_VAL_TRUNC;
+                    }
+                    break;
+                default:
+                    return EZPLIB_INVALID;
+                    break;
+            }
+        }
+
+        ptr += ret;
+        len -= ret;
+    }
+
+    /* Calculate the length of the rule set. */
+    len = EZPLIB_BUF_LEN - len;
+
+    /* Remove the last whitespace. */
+    assert(strlen(RULE_SEP) == 1);
+    if (buf[len - 1] == rule_sep[0]) {
+        buf[--len] = '\0';
+    }
+
+    nvram_set(rule_set, buf);
+    return len;
+}
+
+/**
+ * \brief Replace the nth rule in the rule set.
+ * parameter.
+ * \return The total length of the rule set.
+ * \param[in] rule_set: to specify the rule_set.
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[in] new_rule: the replacing rule.
+ */
+int 
+ezplib_replace_rule(char *rule_set, int nth, char *new_rule)
+{
+    int rule_num;
+
+    if (!rule_set || !*rule_set || !new_rule) {
+        return EZPLIB_INVALID;
+    }
+
+    rule_num = ezplib_get_rule_num(rule_set);
+    if (rule_num < 0) {
+        return EZPLIB_NO_RULE_SET;
+    }
+
+    if (nth > rule_num || nth < 0) {
+        return EZPLIB_IDX_OUT_RANGE;
+    }
+
+    ezplib_op_rule(rule_set, REPLACE_RULE, nth, new_rule);
+    return 0;
+}
+
+/**
+ * \brief Replace the specific attribute in the nth rule in the rule set.
+ * parameter.
+ * \return The total length of the rule set.
+ * \param[in] rule_set: to specify the rule_set.
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[in] new_rule: the replacing rule.
+ */
+int 
+ezplib_replace_attr(char *rule_set, int nth, char *attr_name, char *new_attr)
+{
+    char *ptr_array[MAX_ATTR_NUM];
+    char word[EZPLIB_BUF_LEN];
+    char tmp[EZPLIB_BUF_LEN];
+    int ret, i, bytes, attr_len;
+    char *val, *str, *sep = ATTR_SEP;
+
+    if (!rule_set || !*rule_set || !attr_name || !*attr_name || !new_attr) {
+        return EZPLIB_INVALID;
+    }
+
+    ret = ezplib_get_rule(rule_set, nth, word, EZPLIB_BUF_LEN);
+    if (ret < 0) {
+        return ret;
+    }
+
+    sep_string(word, ATTR_SEP, ptr_array, MAX_ATTR_NUM);
+    for (i = 0; rules[i].name; i++) {
+        struct attr *attr;
+        int j;
+        if (strcmp(rules[i].name, rule_set) != 0) {
+            continue;
+        }
+    
+        attr = rules[i].attr;
+        bytes = EZPLIB_BUF_LEN;
+        str = tmp;
+        for (j = 0; attr[j].name && ptr_array[j]; j++) {
+            if (strcmp(attr[j].name, attr_name) == 0) {
+                val = new_attr;  
+            } else {
+                val = ptr_array[j];
+            }
+
+            /* include the separator */
+            attr_len = strlen(val) + 1;
+            ret = snprintf(str, bytes, "%s%s", val, sep);
+            if (ret >= bytes) {
+                return EZPLIB_VAL_TRUNC;
+            }
+
+            assert(ret == attr_len);
+
+            bytes -= attr_len;
+            str += attr_len;
+        }
+
+        /* remove the last separator */
+        if (*(--str) == sep[0]) {
+            *str = '\0';
+        }
+
+        return ezplib_replace_rule(rule_set, nth, tmp);
+    }
+
+    return EZPLIB_NO_ATTRIBUTE;
+}
+
+/**
+ * \brief Delete the nth rule in the rule set.
+ * parameter.
+ * \return 0 for success; otherwise a negtive value would be returned.
+ * \param[in] rule_set: to specify the rule_set.
+ * \param[in] nth: to specify the nth rule in the rule set.
+ */
+int 
+ezplib_delete_rule(char *rule_set, int nth)
+{
+    if (!rule_set || !*rule_set) {
+        return EZPLIB_INVALID;
+    }
+
+    ezplib_op_rule(rule_set, DELETE_RULE, nth, NULL);
+    return 0;
+}
+
+/**
+ * \brief Add a new rule into the nth position in the rule set.
+ * parameter.
+ * \return 0 for success; otherwise a negtive value would be returned.
+ * \param[in] rule_set: to specify the rule_set.
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[in] new_rule: the replacing rule.
+ */
+int 
+ezplib_add_rule(char *rule_set, int nth, char *new_rule)
+{
+    int rule_num;
+
+    if (!rule_set || !*rule_set || !new_rule) {
+        return EZPLIB_INVALID;
+    }
+
+    rule_num = ezplib_get_rule_num(rule_set);
+    if (rule_num < 0) {
+        return EZPLIB_NO_RULE_SET;
+    }
+
+    if (nth > rule_num || nth < 0) {
+        return EZPLIB_IDX_OUT_RANGE;
+    }
+
+    if (nth == rule_num) {
+        ezplib_append_rule(rule_set, new_rule);
+    } else {
+        ezplib_op_rule(rule_set, ADD_RULE, nth, new_rule);
+    }
+    return 0;
+}
+
+/**
+ * \brief Prepend a new rule into the head of the rule set.
+ * parameter.
+ * \return The total length of the rule set.
+ * \param[in] rule_set: to specify the rule_set.
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[in] new_rule: the replacing rule.
+ */
+int 
+ezplib_prepend_rule(char *rule_set, char *new_rule)
+{
+    if (!rule_set || !*rule_set || !new_rule) {
+        return EZPLIB_INVALID;
+    }
+
+    return ezplib_op_rule(rule_set, ADD_RULE, 0, new_rule);
+}
+
+/**
+ * \brief append a new rule into the tail of the rule set.
+ * parameter.
+ * \return The total length of the rule set.
+ * \param[in] rule_set: to specify the rule_set.
+ * \param[in] nth: to specify the nth rule in the rule set.
+ * \param[in] new_rule: the replacing rule.
+ */
+int 
+ezplib_append_rule(char *rule_set, char *new_rule)
+{
+    char buf[EZPLIB_BUF_LEN];
+    int len;
+    char *old_rules;
+
+    if (!rule_set || !*rule_set || !new_rule) {
+        return EZPLIB_INVALID;
+    }
+
+    old_rules = nvram_get(rule_set);
+    if (!old_rules) {
+        return EZPLIB_NO_RULE_SET;
+    }
+
+    if (!*old_rules) {
+        /* Empty rule set. */
+        len = snprintf(buf, EZPLIB_BUF_LEN, "%s", new_rule);
+    } else {
+        /* Existing rule(s). */
+        len = snprintf(buf, EZPLIB_BUF_LEN, "%s%s%s", old_rules, 
+                       RULE_SEP, new_rule);
+    }
+
+    if (len >= EZPLIB_BUF_LEN) {
+        return EZPLIB_VAL_TRUNC;
+    }
+    nvram_set(rule_set, buf);
+
+    return len;
+}
+
+/**
+ * \brief 
+ * \return The number of rule in the rule set.
+ * \param[in] rule_set: to specify the rule_set.
+ */
+int
+ezplib_get_rule_num(char *rule_set)
+{
+    char *delim;
+    char *sep = RULE_SEP;
+    int i;
+    int count;
+
+    assert(strlen(RULE_SEP) == 1);
+
+    rule_set = nvram_get(rule_set);
+    if (!rule_set) {
+        return EZPLIB_NO_RULE_SET;
+    }
+
+    /* Empty */
+    if (!*rule_set) {
+        return 0;
+    }
+
+    for (i =  0, count = 0; rule_set[i] != '\0'; i++) {
+        if (rule_set[i] == sep[0]) {
+           count++;
+        }
+    }
+
+    /* The number of rules will one more than the count of the separators. */
+    return count+1;
+}
Index: src/nvram_ezpacket-rt3883.h
===================================================================
--- src/nvram_ezpacket-rt3883.h	(revision 0)
+++ src/nvram_ezpacket-rt3883.h	(revision 7299)
@@ -0,0 +1,272 @@
+#ifdef CONFIG_EZP_ARCH_RT3883
+#define ARCH "RT3883"
+
+#ifndef WL_NUM
+#define WL_NUM 1
+#endif
+
+#ifndef WL_VIRTUAL_NUM
+#define WL_VIRTUAL_NUM 4
+#endif
+
+#ifndef WL_WDS_NUM
+#define WL_WDS_NUM 4
+#endif
+
+#ifndef WL_APCLI_NUM
+#define WL_APCLI_NUM 1
+#endif
+
+#if ( WL_NUM == 1 )
+#define WL_BASIC_RULE "1^9^100^6^1"
+#define WL_AP_BASIC_RULE "1^9^100^6^1"
+#define WL5G_BASIC_RULE "1^8^100^0^1"
+#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE*/
+#define WL0_IFNAME_RULE "rai0"
+#define WL1_IFNAME_RULE "ra0"
+#elif ( WL_VIRTUAL_NUM == 2 )
+#define WL0_IFNAME_RULE "rai0|rai1"
+#define WL1_IFNAME_RULE "ra0|ra1"
+#elif ( WL_VIRTUAL_NUM == 4 )
+#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
+#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
+#endif /* WL0_IFNAME_RULE*/
+#define WL0_RULE_NUM WL_VIRTUAL_NUM
+#define WL0_RULE_MAX WL_VIRTUAL_NUM
+#if (WL0_RULE_NUM == 2)
+#warning "WL0_RULE_NUM 2"
+#warning "WL0_RULE_MAX 2"
+#elif (WL0_RULE_NUM == 4)
+#warning "WL0_RULE_NUM 4"
+#warning "WL0_RULE_MAX 4"
+#endif
+#define WDS_RULE_MAX WL_WDS_NUM
+#define APCLI_RULE_MAX WL_APCLI_NUM
+#elif ( WL_NUM == 2 )
+#define WL_BASIC_RULE "1^9^100^6^1|1^9^100^6^1"
+#define WL_AP_BASIC_RULE "1^9^100^6^1|1^9^100^6^1"
+#define WL5G_BASIC_RULE "1^8^100^6^1|1^8^100^6^1"
+#if ( WL_VIRTUAL_NUM == 1 ) /* WL0_IFNAME_RULE/WL1_IFNAME_RULE*/
+#define WL0_IFNAME_RULE "rai0"
+#define WL1_IFNAME_RULE "ra0"
+#elif ( WL_VIRTUAL_NUM == 2 )
+#define WL0_IFNAME_RULE "rai0|rai2"
+#define WL1_IFNAME_RULE "ra0|ra2"
+#elif ( WL_VIRTUAL_NUM == 4 )
+#define WL0_IFNAME_RULE "rai0|rai1|rai2|rai3"
+#define WL1_IFNAME_RULE "ra0|ra1|ra2|ra3"
+#endif /* WL0_IFNAME_RULE/WL1_RULE_NUM */
+#define WL0_RULE_NUM WL_VIRTUAL_NUM
+#define WL0_RULE_MAX WL_VIRTUAL_NUM
+#define WL1_RULE_NUM WL_VIRTUAL_NUM
+#define WL1_RULE_MAX WL_VIRTUAL_NUM
+#define WDS_RULE_MAX WL_WDS_NUM
+#define APCLI_RULE_MAX WL_APCLI_NUM
+#elif (WL_NUM == 0 )
+#else
+#error "Undefined amount of WLAN interfaces"
+#endif
+
+#if ( WAN_NUM >= 1 )
+
+/* 3G/4G WAN default interface should be ppp0. */
+#if defined(EZP_PROD_CAT_M)
+#define WAN0_IFNAME "vlan2"
+#else
+#define WAN0_IFNAME "vlan2"
+#endif
+
+#define WAN0_IFNAMES ""
+#define WAN0_HWNAME ""
+#define WAN0_DEVICE "vlan2"
+#define WAN0_PORTS "4"
+#if ( LAN_NUM >= 1 )
+    #define LAN0_IFNAME "br0"
+    #define LAN0_IFNAMES "vlan1 ra0 ra1 apcli0 apclii0"
+    #define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 rai0 rai1 apcli0 apclii0 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3"
+    #define LAN0_HWNAME ""
+    #define LAN0_DEVICE "vlan1"
+#endif
+#if (LAN_NUM >= 2)
+    #define LAN1_IFNAME "br2"
+    #define LAN1_DEVICE "br2"
+#endif
+
+#if (LAN_NUM == 1)
+    #if (WL_VIRTUAL_NUM == 2)
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 rai0 rai1 wds0 wds1 apcli0 apclii0^|WAN1^0^vlan2^"
+    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
+    #else
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
+    #endif
+    #define BR_RULE_NUM 2
+    #define BR_RULE_MAX 8
+#elif (LAN_NUM == 2)
+    #define BR_RULE_GUESTLAN "GuestLAN^0^ra1^"
+    #if (WL_VIRTUAL_NUM == 2)
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 rai0 rai1 wds0 wds1 apcli0 apclii0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
+    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0 ^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
+    #else
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^|"BR_RULE_GUESTLAN
+    #endif
+    #define BR_RULE_NUM 3
+    #define BR_RULE_MAX 8
+#else
+    #if (WL_VIRTUAL_NUM == 2)
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 rai0 rai1 wds0 wds1 apcli0 apclii0^|WAN1^0^vlan2^"
+    #elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
+    #else
+        #define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 rai0 rai1 rai2 rai3 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3 apcli0 apclii0^|WAN1^0^vlan2^"
+    #endif
+    #define BR_RULE_NUM 2
+    #define BR_RULE_MAX 8
+#endif
+
+#define STATS_RULE "^1^60^vlan1 vlan2 ppp0 br0 ra0 rai0 usb0 eth0"
+#define VLAN_RULE_NUM 2
+#define VLAN_RULE_MAX 8
+#ifdef CONFIG_RAETH_RT3883_P5
+    #warning "P5 enabled, vlan set to 1111011"
+    /* Disable vlan, Sean@liteon, 2012-12-25-----> */
+    #define VLAN_RULE "LAN1^0^eth2^1^1111011^|WAN1^0^eth2^2^0000111^"
+    /* <-----Sean@liteon, 2012-12-25 */
+#else
+    #warning "P5 disabled, vlan set to 1111001"
+    /* Disable vlan, Sean@liteon, 2012-12-25-----> */
+    #define VLAN_RULE "LAN1^0^eth2^1^1111011^|WAN1^0^eth2^2^0000111^"
+    /* <-----Sean@liteon, 2012-12-25 */
+#endif /* CONFIG_RAETH_RT3883_P5 : support for GMAC port when using external giga switch. */
+#define VLANPORT_RULE_NUM 5
+#define VLANPORT_RULE_MAX 7
+#define VLANPORT_RULE "PORT1^0^1^0^011101|PORT2^1^1^0^011011|PORT3^2^1^0^010111|PORT4^3^1^0^001111|PORT5^4^2^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
+/* EZP: Old VLAN definition should be Obsolete! */
+#define LAN0_PORTS "0 1 2 3"
+/* WAN0 uses vlan2. XXX: No effect! */
+#define VLAN2_PORTS "4 5"
+/* LAN0 uses vlan1. XXX: No effect! */
+#define VLAN1_PORTS "0 1 2 3 5*"
+#define VLAN_HWNAME "eth2"
+
+#elif ( WAN_NUM == 2 ) 
+
+#define WAN0_IFNAME "vlan2"
+#define WAN0_IFNAMES ""
+#define WAN0_HWNAME ""
+#define WAN0_DEVICE "vlan2"
+#define WAN0_PORTS "4"
+
+/* 3G/4G 2nd WAN default interface should be ppp0. */
+#if defined(EZP_PROD_CAT_N)
+#define WAN1_IFNAME "ppp1"
+#else
+#define WAN1_IFNAME "vlan3"
+#endif
+
+#define WAN1_IFNAMES ""
+#define WAN1_HWNAME ""
+#define WAN1_DEVICE "vlan3"
+#define WAN1_PORTS "3"
+
+#define LAN0_IFNAME "br0"
+#define LAN0_IFNAMES "vlan1 ra0 ra1 rai0 rai1 apcli0 apclii0"
+#define LAN0_IFNAMES_WDS "vlan1 ra0 ra1 rai0 rai1 apcli0 apclii0 wds0 wds1 wds2 wds3 wdsi0 wdsi1 wdsi2 wdsi3"
+#define LAN0_HWNAME ""
+#define LAN0_DEVICE "vlan1"
+#define LAN0_PORTS "0 1 2"
+
+#define VLAN_RULE_NUM 3
+#define VLAN_RULE_MAX 16 
+#ifdef CONFIG_RAETH_RT3883_P5
+    #define VLAN_RULE "LAN1^1^eth2^1^1110011^|WAN1^1^eth2^2^0000111^|WAN2^1^eth2^3^0001011^"
+#else
+    #define VLAN_RULE "LAN1^1^eth2^1^1110001^|WAN1^1^eth2^2^0000101^|WAN2^1^eth2^3^0001001^"
+#endif /* CONFIG_RAETH_RT3883_P5 : support for GMAC port when using external giga switch. */
+#define VLANPORT_RULE_NUM 5
+#define VLANPORT_RULE_MAX 7
+#define VLANPORT_RULE "PORT1^0^1^0^001101|PORT2^1^1^0^001011|PORT3^2^1^0^000111|PORT4^3^2^0^000001|PORT5^4^3^0^000001|PORT6^5^1^1^|PORT7^6^0^1^"
+/* WAN0 uses vlan2. */
+#define VLAN2_PORTS "4 5"
+/* WAN1 uses vlan3. */
+#define VLAN3_PORTS "3 5"
+/* LAN0 uses vlan1. */
+#define VLAN1_PORTS "0 1 2 5"
+
+#define VLAN_HWNAME "eth2"
+
+#if (WL_VIRTUAL_NUM == 2)
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#elif (WL_VIRTUAL_NUM == 4) /* Added all wlan interfaces into bridge */
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 ra2 ra3 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#else
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#endif
+
+#define BR_RULE "LAN1^1^vlan1 ra0 ra1 wds0 wds1 wds2 wds3 apcli0^|WAN1^0^vlan2^|WAN2^0^vlan3^"
+#define BR_RULE_NUM 3
+#define BR_RULE_MAX 16
+
+#define STATS_RULE "^1^60^vlan3 vlan1 vlan2 ppp0 ppp1 br0 ra0 usb0 eth0 eth1"
+
+#else
+
+#error "Undefined amount of LAN/WAN interfaces"
+
+#endif
+
+#define HWNAT_RULE "1"
+
+#define BW_TYPE \
+        "A1M64K", "A1.5M640K", "A2M256K", "A2M512K", "A3M640K", "A4M1M", \
+        "A6M256K", "A6M640K", "A8M256K", "A8M640K", "A8M800K", "A10M2M", \
+        "A12M1M", "C1M128K", "C2M128K", "C2M384K", "C3M384K", "C6M640K", \
+        "C8M640K", "C10M1M", "V2M2M", "V4M4M", "V10M10M", "V25M25M", \
+        "V50M50M", "V100M100M","Custom"
+
+/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
+#define BW_DOWNLOAD_MAX "102400"
+#define BW_UPLOAD_MAX "102400"
+#define BW_DOWNLOAD_MIN "64"
+#define BW_UPLOAD_MIN "64"
+/* TODO by frankzhou, depending on EZP_PROD_SUBCAT=2 */
+
+#define NVRAM_EZPACKET_DEFAULT_RT3883_LAN_NUM_1   \
+    /* WAN1 uses vlan1. */              \
+    { "vlan1ports", VLAN1_PORTS,        \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 port. */                \
+    { "vlan1hwname", VLAN_HWNAME,       \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 device hwname. */       \
+
+#define NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_1   \
+    /* WAN1 uses vlan2. */              \
+    { "vlan2ports", VLAN2_PORTS,        \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 port. */                \
+    { "vlan2hwname", VLAN_HWNAME,       \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN1 device hwname. */       \
+
+
+#define NVRAM_EZPACKET_DEFAULT_RT3883_WAN_NUM_2   \
+    /* WAN3 uses vlan3. */              \
+    { "vlan2ports", VLAN3_PORTS,        \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN3 port. */                \
+    { "vlan3hwname", VLAN_HWNAME,       \
+        NVRAM_NONE,                     \
+        0                               \
+    }, /* VLAN3 device hwname. */       \
+
+
+
+#endif /* CONFIG_EZP_ARCH_RT3883 */
+

Property changes on: src/nvram_ezpacket-rt3883.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/nvram.h
===================================================================
--- src/nvram.h	(revision 0)
+++ src/nvram.h	(revision 7299)
@@ -0,0 +1,88 @@
+#ifndef _NVRAM_H
+#define _NVRAM_H 	1
+
+//TODO masked by frankzhou
+//#include <linux/autoconf.h>
+
+#ifdef CONFIG_DUAL_IMAGE
+
+#define UBOOT_NVRAM	0
+#define RT2860_NVRAM    1
+#define RTDEV_NVRAM    	2
+#define CERT_NVRAM    	3
+#define WAPI_NVRAM    	4
+#else
+#define RT2860_NVRAM    0
+#define RTDEV_NVRAM    	1
+#define CERT_NVRAM    	2
+#define WAPI_NVRAM    	3
+#endif
+
+#define NV_DEV "/dev/nvram"
+#define RALINK_NVRAM_IOCTL_GET		0x01
+#define RALINK_NVRAM_IOCTL_GETALL	 0x02
+#define RALINK_NVRAM_IOCTL_SET		0x03
+#define RALINK_NVRAM_IOCTL_COMMIT	0x04
+#define RALINK_NVRAM_IOCTL_CLEAR	0x05
+
+typedef struct environment_s {
+	unsigned long crc;		//CRC32 over data bytes
+	char *data;
+} env_t;
+
+typedef struct cache_environment_s {
+	char *name;
+	char *value;
+} cache_t;
+
+#define MAX_CACHE_ENTRY 500
+typedef struct block_s {
+	char *name;
+	env_t env;			//env block
+	cache_t	cache[MAX_CACHE_ENTRY];	//env cache entry by entry
+	unsigned long flash_offset;
+	unsigned long flash_max_len;	//ENV_BLK_SIZE
+
+	char valid;
+	char dirty;
+} block_t;
+
+#define MAX_NAME_LEN 128
+#define MAX_VALUE_LEN (ENV_BLK_SIZE * 5)
+typedef struct nvram_ioctl_s {
+	int index;
+	int ret;
+	char *name;
+	char *value;
+} nvram_ioctl_t;
+
+
+#ifdef CONFIG_DUAL_IMAGE
+#define FLASH_BLOCK_NUM	5
+#else
+#define FLASH_BLOCK_NUM	1
+#endif
+
+
+int nvram_init_ralink(int index,int * nvram_fd);
+void nvram_close_ralink(int index);
+
+int	nvram_set_ralink(int index, char *name, char *value);
+char *nvram_get_ralink(int index, const char *name);
+int nvram_getall_ralink(int index, char *buf,int count);
+int nvram_bufset(int index, char *name, char *value);
+char *nvram_bufget(int index, char *name);
+void nvram_buflist(int index);
+int nvram_commit_ralink(int index);
+
+int nvram_clear(int index);
+int nvram_erase(int index);
+
+int getNvramNum(void);
+unsigned int getNvramOffset(int index);
+unsigned int getNvramBlockSize(int index);
+char *getNvramName(int index);
+unsigned int getNvramIndex(char *name);
+void toggleNvramDebug(void);
+
+#endif

Property changes on: src/nvram.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/strings.c
===================================================================
--- src/strings.c	(revision 0)
+++ src/strings.c	(revision 7299)
@@ -0,0 +1,44 @@
+/*
+	
+	Tomato Firmware
+	Copyright (C) 2006 Jonathan Zarate
+	
+*/
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+
+#include <bcmnvram.h>
+#include "shutils.h"
+#include "shared.h"
+
+int find_word(const char *buffer, const char *word)
+{
+	const char *p, *q;
+	int n;
+	
+	n = strlen(word);
+	p = buffer;
+	while ((p = strstr(p, word)) != NULL) {
+		if ((p == buffer) || (*(p - 1) == ' ') || (*(p - 1) == ',')) {
+			q = p + n;
+			if ((*q == ' ') || (*q == ',') || (*q == 0)) return 1;
+		}
+		++p;
+	}	
+	return 0;
+}
+
+/*
+static void add_word(char *buffer, const char *word, int max)
+{
+	if ((*buffer != 0) && (buffer[strlen(buffer) - 1] != ' '))
+		strlcat(buffer, " ", max);
+	strlcat(buffer, word, max);
+}
+*/

Property changes on: src/strings.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/flash_api.h
===================================================================
--- src/flash_api.h	(revision 0)
+++ src/flash_api.h	(revision 7299)
@@ -0,0 +1,7 @@
+#ifndef __FLASH_API
+#define __FLASH_API
+
+int flash_read(char *buf, off_t from, size_t len);
+int flash_write(char *buf, off_t to, size_t len);
+
+#endif

Property changes on: src/flash_api.h
___________________________________________________________________
Added: svn:executable
   + *

Index: src/shutils.c
===================================================================
--- src/shutils.c	(revision 0)
+++ src/shutils.c	(revision 7299)
@@ -0,0 +1,348 @@
+/*
+ * Shell-like utility functions
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: shutils.c 1629 2005-08-13 14:22:32Z nbd $
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <error.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <unistd.h>
+#include <signal.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <net/ethernet.h>
+
+#include <shutils.h>
+
+/*
+ * Reads file and returns contents
+ * @param	fd	file descriptor
+ * @return	contents of file or NULL if an error occurred
+ */
+char *
+fd2str(int fd)
+{
+	char *buf = NULL;
+	size_t count = 0, n;
+
+	do {
+		buf = realloc(buf, count + 512);
+		n = read(fd, buf + count, 512);
+		if (n < 0) {
+			free(buf);
+			buf = NULL;
+		}
+		count += n;
+	} while (n == 512);
+
+	close(fd);
+	if (buf)
+		buf[count] = '\0';
+	return buf;
+}
+
+/*
+ * Reads file and returns contents
+ * @param	path	path to file
+ * @return	contents of file or NULL if an error occurred
+ */
+char *
+file2str(const char *path)
+{
+	int fd;
+
+	if ((fd = open(path, O_RDONLY)) == -1) {
+		perror(path);
+		return NULL;
+	}
+
+	return fd2str(fd);
+}
+
+/* 
+ * Waits for a file descriptor to change status or unblocked signal
+ * @param	fd	file descriptor
+ * @param	timeout	seconds to wait before timing out or 0 for no timeout
+ * @return	1 if descriptor changed status or 0 if timed out or -1 on error
+ */
+int
+waitfor(int fd, int timeout)
+{
+	fd_set rfds;
+	struct timeval tv = { timeout, 0 };
+
+	FD_ZERO(&rfds);
+	FD_SET(fd, &rfds);
+	return select(fd + 1, &rfds, NULL, NULL, (timeout > 0) ? &tv : NULL);
+}
+
+/* 
+ * Concatenates NULL-terminated list of arguments into a single
+ * commmand and executes it
+ * @param	argv	argument list
+ * @param	path	NULL, ">output", or ">>output"
+ * @param	timeout	seconds to wait before timing out or 0 for no timeout
+ * @param	ppid	NULL to wait for child termination or pointer to pid
+ * @return	return value of executed command or errno
+ */
+int
+_eval(char *const argv[], char *path, int timeout, int *ppid)
+{
+	pid_t pid;
+	int status;
+	int fd;
+	int flags;
+	int sig;
+	char buf[254]="";
+	int i;
+
+	switch (pid = fork()) {
+	case -1:	/* error */
+		perror("fork");
+		return errno;
+	case 0:		/* child */
+		/* Reset signal handlers set for parent process */
+		for (sig = 0; sig < (_NSIG-1); sig++)
+			signal(sig, SIG_DFL);
+
+		/* Clean up */
+		ioctl(0, TIOCNOTTY, 0);
+		close(STDIN_FILENO);
+		close(STDOUT_FILENO);
+		close(STDERR_FILENO);
+		setsid();
+
+		/* We want to check the board if exist UART? , add by honor 2003-12-04 */
+		if ((fd = open("/dev/console", O_RDWR)) < 0) {
+                        (void) open("/dev/null", O_RDONLY);
+                        (void) open("/dev/null", O_WRONLY);
+                        (void) open("/dev/null", O_WRONLY);
+		}
+		else{
+			close(fd);
+                        (void) open("/dev/console", O_RDONLY);
+                        (void) open("/dev/console", O_WRONLY);
+                        (void) open("/dev/console", O_WRONLY);
+		}
+
+		/* Redirect stdout to <path> */
+		if (path) {
+			flags = O_WRONLY | O_CREAT;
+			if (!strncmp(path, ">>", 2)) {
+				/* append to <path> */
+				flags |= O_APPEND;
+				path += 2;
+			} else if (!strncmp(path, ">", 1)) {
+				/* overwrite <path> */
+				flags |= O_TRUNC;
+				path += 1;
+			}
+			if ((fd = open(path, flags, 0644)) < 0)
+				perror(path);
+			else {
+				dup2(fd, STDOUT_FILENO);
+				close(fd);
+			}
+		}
+
+		/* execute command */
+		for(i=0 ; argv[i] ; i++)
+			snprintf(buf+strlen(buf), sizeof(buf), "%s ", argv[i]);
+		dprintf("cmd=[%s]\n", buf);
+		setenv("PATH", "/sbin:/bin:/usr/sbin:/usr/bin", 1);
+		alarm(timeout);
+		execvp(argv[0], argv);
+		perror(argv[0]);
+		exit(errno);
+	default:	/* parent */
+		if (ppid) {
+			*ppid = pid;
+			return 0;
+		} else {
+			waitpid(pid, &status, 0);
+			if (WIFEXITED(status))
+				return WEXITSTATUS(status);
+			else
+				return status;
+		}
+	}
+}
+
+/* 
+ * Concatenates NULL-terminated list of arguments into a single
+ * commmand and executes it
+ * @param	argv	argument list
+ * @return	stdout of executed command or NULL if an error occurred
+ */
+char *
+_backtick(char *const argv[])
+{
+	int filedes[2];
+	pid_t pid;
+	int status;
+	char *buf = NULL;
+
+	/* create pipe */
+	if (pipe(filedes) == -1) {
+		perror(argv[0]);
+		return NULL;
+	}
+
+	switch (pid = fork()) {
+	case -1:	/* error */
+		return NULL;
+	case 0:		/* child */
+		close(filedes[0]);	/* close read end of pipe */
+		dup2(filedes[1], 1);	/* redirect stdout to write end of pipe */
+		close(filedes[1]);	/* close write end of pipe */
+		execvp(argv[0], argv);
+		exit(errno);
+		break;
+	default:	/* parent */
+		close(filedes[1]);	/* close write end of pipe */
+		buf = fd2str(filedes[0]);
+		waitpid(pid, &status, 0);
+		break;
+	}
+	
+	return buf;
+}
+
+/* 
+ * Kills process whose PID is stored in plaintext in pidfile
+ * @param	pidfile	PID file
+ * @return	0 on success and errno on failure
+ */
+int
+kill_pidfile(char *pidfile)
+{
+	FILE *fp = fopen(pidfile, "r");
+	char buf[256];
+
+	if (fp && fgets(buf, sizeof(buf), fp)) {
+		pid_t pid = strtoul(buf, NULL, 0);
+		fclose(fp);
+		return kill(pid, SIGTERM);
+  	} else
+		return errno;
+}
+
+int
+process_is_running(char *program)
+{
+    FILE *fp;
+    char buf[256];
+    pid_t pid = 0;
+    
+    snprintf(buf, sizeof(buf), "pidof %s", program);
+    fp = popen(buf, "r");
+    if (fp && fgets(buf, sizeof(buf), fp)) {
+        pid = strtoul(buf, NULL, 0);
+    }
+
+    if (fp) {
+        pclose(fp);
+    }
+    return (pid > 0) ? 1 : 0;
+}
+
+/*
+ * fread() with automatic retry on syscall interrupt
+ * @param	ptr	location to store to
+ * @param	size	size of each element of data
+ * @param	nmemb	number of elements
+ * @param	stream	file stream
+ * @return	number of items successfully read
+ */
+int
+safe_fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
+{
+	size_t ret = 0;
+
+	do {
+		clearerr(stream);
+		ret += fread((char *)ptr + (ret * size), size, nmemb - ret, stream);
+	} while (ret < nmemb && ferror(stream) && errno == EINTR);
+
+	return ret;
+}
+
+/*
+ * fwrite() with automatic retry on syscall interrupt
+ * @param	ptr	location to read from
+ * @param	size	size of each element of data
+ * @param	nmemb	number of elements
+ * @param	stream	file stream
+ * @return	number of items successfully written
+ */
+int
+safe_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
+{
+	size_t ret = 0;
+
+	do {
+		clearerr(stream);
+		ret += fwrite((char *)ptr + (ret * size), size, nmemb - ret, stream);
+	} while (ret < nmemb && ferror(stream) && errno == EINTR);
+
+	return ret;
+}
+
+/*
+ * Convert Ethernet address string representation to binary data
+ * @param	a	string in xx:xx:xx:xx:xx:xx notation
+ * @param	e	binary data
+ * @return	TRUE if conversion was successful and FALSE otherwise
+ */
+int
+ether_atoe(const char *a, unsigned char *e)
+{
+	char *c = (char *) a;
+	int i = 0;
+
+	memset(e, 0, ETHER_ADDR_LEN);
+	for (;;) {
+		e[i++] = (unsigned char) strtoul(c, &c, 16);
+		if (!*c++ || i == ETHER_ADDR_LEN)
+			break;
+	}
+	return (i == ETHER_ADDR_LEN);
+}
+
+/*
+ * Convert Ethernet address binary data to string representation
+ * @param	e	binary data
+ * @param	a	string in xx:xx:xx:xx:xx:xx notation
+ * @return	a
+ */
+char *
+ether_etoa(const unsigned char *e, char *a)
+{
+	char *c = a;
+	int i;
+
+	for (i = 0; i < ETHER_ADDR_LEN; i++) {
+		if (i)
+			*c++ = ':';
+		c += sprintf(c, "%02X", e[i] & 0xff);
+	}
+	return a;
+}

Property changes on: src/shutils.c
___________________________________________________________________
Added: svn:executable
   + *

Index: src/Makefile
===================================================================
--- src/Makefile	(revision 7302)
+++ src/Makefile	(revision 7299)
@@ -3,18 +3,52 @@
 include $(INCLUDE_DIR)/package.mk
 include $(INCLUDE_DIR)/kernel.mk
 
-EXTRA_CFLAGS := -c -I. -I../include -I $(LINUX_DIR)/include
+EXTRA_CFLAGS := -c -I. -I../include
+LIBSHARED_OBJS := shutils.o wl.o wl_linux.o linux_timer.o base64.o strings.o files.o process.o crc32.o
 LIBNVRAM_OBJS := crc32.o nvram_env.o flash_api.o nvram_linux.o ezp-lib.o
+
+#NVDIR = $(BUILD_DIR)/ralink-nvram
+SPECIAL_CFLAGS+=-I $(LINUX_DIR)/include
 all: libnvram.so nvram
 
-%.o: %.c
+#%.o: %.c
+#	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+
+shutils.o: shutils.c
 	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+wl.o: wl.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+wl_linux.o: wl_linux.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+linux_timer.o: linux_timer.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+base64.o: base64.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+strings.o: strings.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+files.o: files.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+process.o: process.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^
+crc32.o: crc32.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^	
+nvram_env.o: nvram_env.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(SPECIAL_CFLAGS) -o $@ $^	
+flash_api.o: flash_api.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^	
+nvram_linux.o: nvram_linux.c 
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^	
+ezp-lib.o: ezp-lib.c 
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $^	
 
+
+libshared.so: $(LIBSHARED_OBJS)
+	$(CC) -shared -o $@ $^
+
 libnvram.so: $(LIBNVRAM_OBJS)
 	$(CC) -shared -o $@ $^
 
 nvram: main.o
-	@echo -e "\r\n LINUX_DIR=$(LINUX_DIR) \r\n"
 	$(CC) -o $@ $^ -L. -lnvram
 
 clean:
Index: Makefile
===================================================================
--- Makefile	(revision 7302)
+++ Makefile	(revision 7299)
@@ -64,6 +64,8 @@
 define Build/Prepare
 	mkdir -p $(PKG_BUILD_DIR)
 	$(CP) ./src/* $(PKG_BUILD_DIR)
+	mkdir -p $(STAGING_DIR)/usr/include
+	$(CP) ./include/[a-z]* $(STAGING_DIR)/usr/include
 endef
 
 define Build/Compile
