diff --git a/HOWTO b/HOWTO
index af94cb9..ba4006c 100644
--- a/HOWTO
+++ b/HOWTO
@@ -118,8 +118,8 @@ After doing this you can use attribute related functions as followings:
 
 	@(none):/tmp# nvram show lan_main_rule 0 name
 	LAN1
-	@(none):/tmp# nvram replace attr lan_main_rule 0 name HELLO_WORLD
-	@(none):/tmp# nvram show lan_main_rule 0 name 
+	@(none):/tmp# nvram replace attribute lan_main_rule 0 name HELLO_WORLD
+	@(none):/tmp# nvram show lan_main_rule 0 name HELLO_WORLD
 	HELLO_WORLD	
 	@(none):/tmp# nvram get lan_main_rule
 	HELLO_WORLD^1^1500^1^1^0|GuestLAN^0^1500^1^1^0
diff --git a/cli.c b/cli.c
index bb9a4fa..ab34341 100644
--- a/cli.c
+++ b/cli.c
@@ -1,5 +1,3 @@
-#include <sys/types.h>
-#include <signal.h>
 #include "cli.h"
 #include "nvram_rule.h"
 
@@ -332,7 +330,8 @@ int main( int argc, const char *argv[] )
 {
 	int stat = 1;
 	int done = 0;
-	char res[NVRAM_BUF_LEN];
+	char res[EZPLIB_BUF_LEN];
+	int i;
 
 	if( argc > 1 )
 	{
@@ -348,27 +347,29 @@ int main( int argc, const char *argv[] )
 			}
 			/* nvram show <rule-set> <nth> */
 			else if (argc == 2) {
-				stat = nvram_get_rule(argv[0], atoi(argv[1]), 
-						res, NVRAM_BUF_LEN);
+				ezplib_get_rule(argv[0], atoi(argv[1]), res, EZPLIB_BUF_LEN);
 				puts_trim_cr(res);
+				/* TODO: fix the return value. */
 				done++;
+				return 0;
 			} 
 			/* nvram show <rule-set> <nth> <attr-type> */
 			else if (argc == 3) {
-				stat = nvram_get_attr_val(argv[0], atoi(argv[1]), 
-					argv[2], res, NVRAM_BUF_LEN, NVRAM_USE_CLI);
+				ezplib_get_attr_val(argv[0], atoi(argv[1]), argv[2], res,
+						EZPLIB_BUF_LEN, EZPLIB_USE_CLI);
 				puts_trim_cr(res);
+				/* TODO: fix the return value. */
 				done++;
+				return 0;
 			} 
 			/* nvram show <rule-set> <nth> subrule <start> <end> */
 			else if (argc == 5 && !strncmp(argv[2], "subrule", strlen(argv[1]))) {
-				stat = nvram_get_subrule(argv[0], atoi(argv[1]), atoi(argv[3]),
-						atoi(argv[4]), res, NVRAM_BUF_LEN);
+				ezplib_get_subrule(argv[0], atoi(argv[1]), atoi(argv[3]),
+						atoi(argv[4]), res, EZPLIB_BUF_LEN);
 				puts_trim_cr(res);
+				/* TODO: fix the return value. */
 				done++;
-			}
-			else {
-				done = 0;
+				return 0;
 			}
 
 		}
@@ -474,7 +475,7 @@ int main( int argc, const char *argv[] )
 					int ret;
 
 					ret =
-						nvram_replace_rule(argv[0], atoi(argv[1]),
+						ezplib_replace_rule(argv[0], atoi(argv[1]),
 								argv[2]);
 					if (ret < 0) {
 						printf("NVRAM replace rule failed: %s\n", ret);
@@ -484,15 +485,15 @@ int main( int argc, const char *argv[] )
 					}
 				}
 			} 
-			/* nvram replace attr <rule-set> <nth> <attr> <new-rule> */
-			else if (!strncmp(argv[1], "attr", strlen(argv[1]))) {
+			/* nvram replace attribute <rule-set> <nth> <attr> <new-rule> */
+			else if (!strncmp(argv[1], "attribute", strlen(argv[1]))) {
 				argc -= 2;
 				argv += 2;
 				if (argc == 4) {
 					int ret;
 
 					ret =
-						nvram_replace_attr(argv[0], atoi(argv[1]), argv[2],
+						ezplib_replace_attr(argv[0], atoi(argv[1]), argv[2],
 								argv[3]);
 					if (ret < 0) {
 						printf("NVRAM replace attribute failed: %d\n", ret);
@@ -511,7 +512,7 @@ int main( int argc, const char *argv[] )
 			if (argc == 2) {
 				int ret;
 
-				ret = nvram_append_rule(argv[0], argv[1]);
+				ret = ezplib_append_rule(argv[0], argv[1]);
 				if (ret < 0) {
 					printf("NVRAM append rule failed: %s\n", ret);
 					return 1;
@@ -528,7 +529,7 @@ int main( int argc, const char *argv[] )
 			if (argc == 2) {
 				int ret;
 
-				ret = nvram_prepend_rule(argv[0], argv[1]);
+				ret = ezplib_prepend_rule(argv[0], argv[1]);
 				if (ret < 0) {
 					printf("NVRAM prepend rule failed: %s\n", ret);
 					return 1;
@@ -545,7 +546,7 @@ int main( int argc, const char *argv[] )
 			if (argc == 3) {
 				int ret;
 
-				ret = nvram_add_rule(argv[0], atoi(argv[1]), argv[2]);
+				ret = ezplib_add_rule(argv[0], atoi(argv[1]), argv[2]);
 				if (ret < 0) {
 					printf("NVRAM add rule failed: %s\n", ret);
 					return 1;
@@ -562,7 +563,7 @@ int main( int argc, const char *argv[] )
 			if (argc == 2) {
 				int ret;
 
-				ret = nvram_delete_rule(argv[0], atoi(argv[1]));
+				ret = ezplib_delete_rule(argv[0], atoi(argv[1]));
 				if (ret < 0) {
 					printf("NVRAM delete rule failed: %s\n", ret);
 					return 1;
@@ -579,12 +580,11 @@ int main( int argc, const char *argv[] )
 			if (argc == 1) {
 				int ret;
 
-				ret = nvram_get_rule_num(argv[0]);
+				ret = ezplib_get_rule_num(argv[0]);
 				if (ret < 0) {
-					printf("NVRAM rule num failed: %s\n", ret);
+					printf("NVRAM delete rule failed: %s\n", ret);
 					return ret;
 				} else  {
-					printf("%d\n", ret);
 					return 0;
 				}
 			}
@@ -621,12 +621,6 @@ int main( int argc, const char *argv[] )
 			stat = nvram_commit();
 			done++;
 		}
-		/* nvram commit */
-		else if( !strncmp(*argv, "dump", 4) )
-		{
-			stat = nvram_dump();
-			done++;
-		}
 		else
 		{
 			fprintf(stderr, "Unknown option '%s' !\n", *argv);
@@ -649,7 +643,7 @@ int main( int argc, const char *argv[] )
 				"	nvram downgrade/upgrade <version>\n"
 
 				"	nvram replace rule <rule-set> <nth> <new-rule>\n"
-				"	nvram replace attr <rule-set> <nth> <attr> <new-attr> \n"
+				"	nvram replace attr <rule-set> <nth> <attr>\n"
 				"	nvram append rule <rule-set> <new-rule>\n"
 				"	nvram prepend rule <rule-set> <new-rule>\n"
 				"	nvram add rule <rule-set> <nth> <new-rule>\n"
@@ -661,7 +655,6 @@ int main( int argc, const char *argv[] )
 				"	nvram factory\n"
 
 				"	nvram commit\n"
-				"	nvram dump\n"
 			   );
 	}
 	return stat;
diff --git a/nvram.h b/nvram.h
index 79b7190..8a81bff 100644
--- a/nvram.h
+++ b/nvram.h
@@ -166,8 +166,5 @@ int nvram_import(char *filename);
 //TODO
 int nvram_upgrade(char *source);
 int nvram_downgrade(char *target);
-
-//helper function
-int nvram_dump(void);
 /********************************************************/
 #endif /* _nvram_h_ */
diff --git a/nvram_fw.c b/nvram_fw.c
index d0697b1..dc84905 100644
--- a/nvram_fw.c
+++ b/nvram_fw.c
@@ -36,16 +36,102 @@
 #if defined(NVRAM_MMAP) && NVRAM_MMAP > 0
 static char *nvram_buf = NULL;
 #endif
+static int nvram_fd = -1;
 int check_action(void);
 int file_to_buf(char *path, char *buf, int len);
 
 /* Firmware. */
 int fw_func_1_6_5_to_0_0_0(void);
 int fw_func_0_0_0_to_1_6_5(void);
+/* 1.6.6 */
+int fw_func_1_6_5_to_1_6_6(void);
+int fw_func_1_6_6_to_1_6_5(void);
+/* 1.6.7 */
+int fw_func_1_6_6_to_1_6_7(void);
+int fw_func_1_6_7_to_1_6_6(void);
+/* 1.7.0 */
+int fw_func_1_6_7_to_1_7_0(void);
+int fw_func_1_7_0_to_1_6_7(void);
+/* 1.7.1 */
+int fw_func_1_7_0_to_1_7_1(void);
+int fw_func_1_7_1_to_1_7_0(void);
+/* 1.7.2 */
+int fw_func_1_7_1_to_1_7_2(void);
+int fw_func_1_7_2_to_1_7_1(void);
+/* 1.7.3 */
+int fw_func_1_7_2_to_1_7_3(void);
+int fw_func_1_7_3_to_1_7_2(void);
+/* 1.7.4 */
+int fw_func_1_7_3_to_1_7_4(void);
+int fw_func_1_7_4_to_1_7_3(void);
+/* 1.7.5 */
+int fw_func_1_7_4_to_1_7_5(void);
+int fw_func_1_7_5_to_1_7_4(void);
+/* 1.7.5 */
+int fw_func_1_7_4_to_1_7_5(void);
+int fw_func_1_7_5_to_1_7_4(void);
+/* 1.7.6 */
+int fw_func_1_7_5_to_1_7_6(void);
+int fw_func_1_7_6_to_1_7_5(void);
+/* 1.7.7 */
+int fw_func_1_7_6_to_1_7_7(void);
+int fw_func_1_7_7_to_1_7_6(void);
+/* 1.7.8 */
+int fw_func_1_7_7_to_1_7_8(void);
+int fw_func_1_7_8_to_1_7_7(void);
+/* 1.7.9 */
+int fw_func_1_7_8_to_1_7_9(void);
+int fw_func_1_7_9_to_1_7_8(void);
+/* 1.7.10 */
+int fw_func_1_7_9_to_1_7_10(void);
+int fw_func_1_7_10_to_1_7_9(void);
+/* 1.7.11 */
+int fw_func_1_7_10_to_1_7_11(void);
+int fw_func_1_7_11_to_1_7_10(void);
+/* 2.0.0 */
+int fw_func_1_7_11_to_2_0_0(void);
+int fw_func_2_0_0_to_1_7_11(void);
+/* 2.0.1 */
+int fw_func_2_0_0_to_2_0_1(void);
+int fw_func_2_0_1_to_2_0_0(void);
+/* 2.0.2 */
+int fw_func_2_0_1_to_2_0_2(void);
+int fw_func_2_0_2_to_2_0_1(void);
+/* 2.0.3 */
+int fw_func_2_0_2_to_2_0_3(void);
+int fw_func_2_0_3_to_2_0_2(void);
+/* 2.0.4 */
+int fw_func_2_0_3_to_2_0_4(void);
+int fw_func_2_0_4_to_2_0_3(void);
+/* 2.0.5 */
+int fw_func_2_0_4_to_2_0_5(void);
+int fw_func_2_0_5_to_2_0_4(void);
 
 struct nvram_fw_tuple nvram_fw_table[] = {
     { "0.0.0", NVRAM_FW_0_0_0, NULL, NULL },   
     { "1.6.5", NVRAM_FW_1_6_5, fw_func_0_0_0_to_1_6_5, fw_func_1_6_5_to_0_0_0 },
+    { "1.6.6", NVRAM_FW_1_6_6, fw_func_1_6_5_to_1_6_6, fw_func_1_6_6_to_1_6_5 },
+    { "1.6.7", NVRAM_FW_1_6_7, fw_func_1_6_6_to_1_6_7, fw_func_1_6_7_to_1_6_6 },
+    { "1.7.0", NVRAM_FW_1_7_0, fw_func_1_6_7_to_1_7_0, fw_func_1_7_0_to_1_6_7 },
+    { "1.7.1", NVRAM_FW_1_7_1, fw_func_1_7_0_to_1_7_1, fw_func_1_7_1_to_1_7_0 },
+    { "1.7.2", NVRAM_FW_1_7_2, fw_func_1_7_1_to_1_7_2, fw_func_1_7_2_to_1_7_1 },
+    { "1.7.3", NVRAM_FW_1_7_3, fw_func_1_7_2_to_1_7_3, fw_func_1_7_3_to_1_7_2 },
+    { "1.7.4", NVRAM_FW_1_7_4, fw_func_1_7_3_to_1_7_4, fw_func_1_7_4_to_1_7_3 },
+    { "1.7.5", NVRAM_FW_1_7_5, fw_func_1_7_4_to_1_7_5, fw_func_1_7_5_to_1_7_4 },
+    { "1.7.6", NVRAM_FW_1_7_6, fw_func_1_7_5_to_1_7_6, fw_func_1_7_6_to_1_7_5 },
+    { "1.7.7", NVRAM_FW_1_7_7, fw_func_1_7_6_to_1_7_7, fw_func_1_7_7_to_1_7_6 },
+    { "1.7.8", NVRAM_FW_1_7_8, fw_func_1_7_7_to_1_7_8, fw_func_1_7_8_to_1_7_7 },
+    { "1.7.9", NVRAM_FW_1_7_9, fw_func_1_7_8_to_1_7_9, fw_func_1_7_9_to_1_7_8 },
+    { "1.7.10", NVRAM_FW_1_7_10, fw_func_1_7_9_to_1_7_10,
+        fw_func_1_7_10_to_1_7_9 },
+    { "1.7.11", NVRAM_FW_1_7_11, fw_func_1_7_10_to_1_7_11,
+        fw_func_1_7_11_to_1_7_10 },
+    { "2.0.0", NVRAM_FW_2_0_0, fw_func_1_7_11_to_2_0_0, fw_func_2_0_0_to_1_7_11 },
+    { "2.0.1", NVRAM_FW_2_0_1, fw_func_2_0_0_to_2_0_1, fw_func_2_0_1_to_2_0_0 },
+    { "2.0.2", NVRAM_FW_2_0_2, fw_func_2_0_1_to_2_0_2, fw_func_2_0_2_to_2_0_1 },
+    { "2.0.3", NVRAM_FW_2_0_3, fw_func_2_0_2_to_2_0_3, fw_func_2_0_3_to_2_0_2 },
+    { "2.0.4", NVRAM_FW_2_0_4, fw_func_2_0_3_to_2_0_4, fw_func_2_0_4_to_2_0_3 },
+    { "2.0.5", NVRAM_FW_2_0_5, fw_func_2_0_4_to_2_0_5, fw_func_2_0_5_to_2_0_4 },
     { NULL, 0, NULL, NULL }
 };
 
@@ -75,20 +161,20 @@ int fw_func_0_0_0_to_1_6_5(void)
          */
 		for (i = 0, j = 0, len = 0; i < WAN_NUM; i++) {
             /* Removed expert_dl/expert_ul. */
-            nvram_get_attr_val(rule_set, i, "type", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "type", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "dl", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dl", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "ul", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "ul", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
@@ -102,50 +188,50 @@ int fw_func_0_0_0_to_1_6_5(void)
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "expert_dl", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "expert_dl", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "expert_ul", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "expert_ul", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "link_percent", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "link_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "global_percent", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "global_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "user_percent", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "user_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "dbm_upmax", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dbm_upmax", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
             /* No ending "^". */ 
-            nvram_get_attr_val(rule_set, i, "dbm_upmin", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dbm_upmin", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s", tmp);
             j += len;
             str += len;
 
-            nvram_replace_rule(rule_set, i, new);
+            ezplib_replace_rule(rule_set, i, new);
         }
     }
     return 0;
@@ -170,70 +256,1935 @@ int fw_func_1_6_5_to_0_0_0(void)
     if (value && *value) {
         for (i = 0, j = 0, len = 0; i < WAN_NUM; i++) {
             /* Removed expert_dl/expert_ul. */
-            nvram_get_attr_val(rule_set, i, "type", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "type", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "dl", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dl", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "ul", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "ul", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "link_percent", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "link_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "global_percent", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "global_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "user_percent", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "user_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "dbm_upmax", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dbm_upmax", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "dbm_upmin", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dbm_upmin", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
-            nvram_get_attr_val(rule_set, i, "dbm_downmax", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dbm_downmax", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s^", tmp);
             j += len;
             str += len;
 
             /* No ending "^". */ 
-            nvram_get_attr_val(rule_set, i, "dbm_downmin", tmp, sizeof(tmp),
-                    NVRAM_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dbm_downmin", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
             len = snprintf(str, 1024 - j, "%s", tmp);
             j += len;
             str += len;
 
-            nvram_replace_rule(rule_set, i, new);
+            ezplib_replace_rule(rule_set, i, new);
         }
     }
     return 0;
 }
 
+int fw_func_1_6_5_to_1_6_6(void)
+{
+    int i, j, len;
+    char new[1024];
+    char tmp[64];
+    char *str = &new[0];
+    char *rule_set = "upnp_rule";
+    char *value = nvram_safe_get(rule_set);
+
+    printf("fw_func_1_6_5_to_1_6_6\n");
+    /* If empty, nvram boot will create it. */ 
+    /* Check the existence of the value. */
+    if (value && *value) {
+        /* 
+         * upnp_rule is changed in the format. 
+         *
+         * Old: name^enable[0|1]^extif^inif^port
+         * New: name^enable[0|1]^pmp_enable[0|1]^extif^inif^port
+         */
+
+        i = j = 0;
+        /* Added pmp_enable. */
+        ezplib_get_attr_val(rule_set, i, "name", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "enable", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* pmp_enable */
+        len = snprintf(str, 1024 - j, "0^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "pmp_enable", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "extif", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* No ending "^". */ 
+        ezplib_get_attr_val(rule_set, i, "inif", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, i, new);
+    }
+    return 0;
+}
+
+int fw_func_1_6_6_to_1_6_5(void)
+{
+    int i, j, len;
+    char new[1024];
+    char tmp[128];
+    char *str = &new[0];
+    char *rule_set = "upnp_rule";
+    char *value = nvram_safe_get(rule_set);
+
+    printf("fw_func_1_6_6_to_1_6_5\n");
+
+    /* Check the existence of the value. */
+    if (value && *value) {
+        i = 0;
+        /* Removed pmp_enable. */
+        ezplib_get_attr_val(rule_set, i, "name", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "enable", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "extif", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "inif", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* No ending "^". */ 
+        ezplib_get_attr_val(rule_set, i, "port", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, i, new);
+    }
+    return 0;
+}
+
+int fw_func_1_6_6_to_1_6_7(void)
+{
+    int i, j, len;
+    char new[1024];
+    char tmp[64];
+    char *str = &new[0];
+    char *rule_set = "wan_bw_rule";
+    char *value = nvram_safe_get(rule_set);
+
+    printf("fw_func_1_6_6_to_1_6_7\n");
+    /* If empty, nvram boot will create it. */ 
+    /* Check the existence of the value. */
+    if (value && *value) {
+        /* 
+         * wan_bw_rule is changed in the value in the attribute "type". 
+         *
+         * e.g.,
+         * Old: 2M256K
+         * New: A2M256K
+         */
+
+        for (i = 0, j = 0, len = 0; i < WAN_NUM; i++) {
+            /* Modified the value of "type". */
+            ezplib_get_attr_val(rule_set, i, "type", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            /* Set the type default as ADSL */
+            len = snprintf(str, 1024 - j, "A%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dl", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "ul", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "expert_dl", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "expert_ul", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "link_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "global_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "user_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_upmax", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_upmin", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_downmax", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_downmin", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s", tmp);
+            j += len;
+            str += len;
+
+            ezplib_replace_rule(rule_set, i, new);
+        }
+    }
+    return 0;
+}
+
+int fw_func_1_6_7_to_1_6_6(void)
+{
+    int i, j, k, len;
+    char new[1024];
+    char tmp[128];
+    char *str = &new[0];
+    char *rule_set = "wan_bw_rule";
+    char *value = nvram_safe_get(rule_set);
+    char *type;
+    char tmp_dl[128], tmp_ul[128];
+    char *bw_type[] = {
+        "1M64K", "2M256K", "2M512K", "3M640K", "4M1M", "8M640K", "10M2M", 
+        "12M1M", NULL
+    };
+
+    printf("fw_func_1_6_7_to_1_6_6\n");
+
+    /* Check the existence of the value. */
+    if (value && *value) {
+        for (i = 0, j = 0, len = 0; i < WAN_NUM; i++) {
+            ezplib_get_attr_val(rule_set, i, "type", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "dl", tmp_dl, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            ezplib_get_attr_val(rule_set, i, "ul", tmp_ul, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            /* Ignore the bandwidth type: ADSL, Cable or VDSL */
+            if (!strcmp(tmp, "Custom")) {
+                type = "Custom";
+            } else {
+                type = &tmp[1];
+                for (k = 0; bw_type[k]; k++) {
+                    if (!strcmp(type, bw_type[k])) {
+                        break;
+                    }
+                }
+                if (!bw_type[k]) {
+                    /* No matched type */
+                    type = "2M256K";
+                    strcpy(tmp_dl, "2048");
+                    strcpy(tmp_ul, "256");
+                }
+            }
+            len = snprintf(str, 1024 - j, "%s^%s^%s^", type, tmp_dl, tmp_ul);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "expert_dl", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "expert_ul", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "link_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "global_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "user_percent", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_upmax", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_upmin", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_downmax", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "dbm_downmin", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s", tmp);
+            j += len;
+            str += len;
+
+            ezplib_replace_rule(rule_set, i, new);
+        }
+    }
+    return 0;
+}
+
+int fw_func_1_6_7_to_1_7_0(void)
+{
+    printf("fw_func_1_6_7_to_1_7_0\n");
+    return 0;
+}
+
+int fw_func_1_7_0_to_1_6_7(void)
+{
+    printf("fw_func_1_7_0_to_1_6_7\n");
+    return 0;
+}
+
+int fw_func_1_7_0_to_1_7_1(void)
+{
+    printf("fw_func_1_7_0_to_1_7_1\n");
+    return 0;
+}
+
+int fw_func_1_7_1_to_1_7_0(void)
+{
+    printf("fw_func_1_7_1_to_1_7_0\n");
+    return 0;
+}
+
+int fw_func_1_7_1_to_1_7_2(void)
+{
+    printf("fw_func_1_7_1_to_1_7_2\n");
+    return 0;
+}
+
+int fw_func_1_7_2_to_1_7_1(void)
+{
+    printf("fw_func_1_7_2_to_1_7_1\n");
+    return 0;
+}
+
+int fw_func_1_7_2_to_1_7_3(void)
+{
+    printf("fw_func_1_7_2_to_1_7_3\n");
+    return 0;
+}
+
+int fw_func_1_7_3_to_1_7_2(void)
+{
+    printf("fw_func_1_7_3_to_1_7_2\n");
+    return 0;
+}
+
+int fw_func_1_7_3_to_1_7_4(void)
+{
+    printf("fw_func_1_7_3_to_1_7_4\n");
+    return 0;
+}
+
+int fw_func_1_7_4_to_1_7_3(void)
+{
+    printf("fw_func_1_7_4_to_1_7_3\n");
+    return 0;
+}
+
+int fw_func_1_7_4_to_1_7_5(void)
+{
+    char *rule_set = "upnp_rule";
+    char tmp[32];
+
+    printf("fw_func_1_7_4_to_1_7_5\n");
+
+    /* Disable NAT-PMP by default since now! */
+    ezplib_get_attr_val(rule_set, 0, "pmp_enable", tmp, sizeof(tmp),
+		    EZPLIB_USE_CLI);
+    if (!strcmp(tmp, "1")) {
+        ezplib_replace_attr(rule_set, 0, "pmp_enable", "0");
+    } 
+
+    /* Change UPnP listen port from 5000 to 5555.  */
+    ezplib_get_attr_val(rule_set, 0, "port", tmp, sizeof(tmp), EZPLIB_USE_CLI);
+    if (!strcmp(tmp, "5000")) {
+        ezplib_replace_attr(rule_set, 0, "port", "5555");
+    } 
+
+    return 0;
+}
+
+int fw_func_1_7_5_to_1_7_4(void)
+{
+    printf("fw_func_1_7_5_to_1_7_4\n");
+    /* Do nothing since we perfer NAT-PMP disabled and port 5555. */
+    return 0;
+}
+
+int fw_func_1_7_5_to_1_7_6(void)
+{
+//TODO
+#if 0
+    int i, j, len, rule_num, max;
+    char new[1024], old[1024];
+    char tmp[64], tmp2[64], tmp3[64];
+    char *str = &new[0];
+    char *rule_set = "ntp_rule";
+    char *value = nvram_safe_get(rule_set), *value2;
+    char *wl_enable, *ptr;
+
+	char ModeTmpBuf[32];
+	ezplib_get_attr_val("wl_mode_rule", 0, "mode", ModeTmpBuf, 32, EZPLIB_USE_CLI);
+
+    printf("fw_func_1_7_5_to_1_7_6\n");
+
+    /* If empty, nvram boot will create it. */ 
+    /* Check the existence of the value. */
+    if (value && *value) {
+        /* 
+         * upnp_rule is changed in the format. 
+         *
+         * Old: name^enable[0|1]^pool^zone
+         * New: name^enable[0|1]^type[pool|ipaddr]^pool^ipaddr^zone
+         */
+
+        i = j = 0;
+        ezplib_get_attr_val(rule_set, i, "name", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "enable", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* type */
+        len = snprintf(str, 1024 - j, "pool^", tmp);
+        j += len;
+        str += len;
+        /* pool: use new "type" to get old "pool". */
+        ezplib_get_attr_val(rule_set, i, "type", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* ipaddr */
+        len = snprintf(str, 1024 - j, "^", tmp);
+        j += len;
+        str += len;
+
+        /* No ending "^". */ 
+        /* zone: use new "pool" to get old "zone". */
+        ezplib_get_attr_val(rule_set, i, "pool", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, i, new);
+    }
+
+    rule_num = atoi(nvram_safe_get("ipsec_rule_num"));
+    rule_set = "ipsec_rule";
+    
+    for (i = j = 0; i < rule_num; i++) {
+        str = &new[0];
+        ezplib_get_rule(rule_set, i, old, 1024);
+        /* If empty, nvram boot will create it. */ 
+        /* Check the existence of the value. */
+        if (old[0]) {
+            /* 
+             * Old: name^enable^adv^mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init^phase1_mode^phase1_auth_md5^phase1_auth_sha1^phase1_encrypt_des^phase1_encrypt_3des^phase1_encrypt_aes^phase1_id^phase2_auth_md5^phase2_auth_sha1^phase2_encrypt_des^phase2_encrypt_3des^phase2_encrypt_aes^phase1_lifetime^phase2_lifetime^pfs^ike_keymode^psk^rsa^ca
+             * New: name^enable^mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init^ike_keymode^psk^rsa^ca^adv^phase1_mode^phase1_id^phase1_lifetime^phase2_lifetime^phase1_auth^phase1_encrypt^phase1_group^phase2_auth^phase2_encrypt^phase2_group
+             */
+
+            /* name^enable */
+            ezplib_get_subrule(rule_set, i, 0, 1, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init */
+            ezplib_get_subrule(rule_set, i, 3, 11, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* ike_keymode^psk^rsa^ca */
+            ezplib_get_subrule(rule_set, i, 27, 30, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* adv */
+            ezplib_get_subrule(rule_set, i, 2, 2, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* phase1_mode */
+            ezplib_get_subrule(rule_set, i, 12, 12, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* phase1_id */
+            ezplib_get_subrule(rule_set, i, 18, 18, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* phase1_lifetime^phase2_lifetime */
+            ezplib_get_subrule(rule_set, i, 24, 25, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* phase1_auth */
+            ezplib_get_subrule(rule_set, i, 13, 13, tmp, sizeof(tmp));
+            ezplib_get_subrule(rule_set, i, 14, 14, tmp2, sizeof(tmp));
+            if (tmp[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "md5");
+            } else if (tmp2[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "sha1");
+            } else {
+                /* default MD5 */
+                len = snprintf(str, 1024 - j, "%s^", "md5");
+            }
+            j += len;
+            str += len;
+
+            /* phase1_encrypt */
+            ezplib_get_subrule(rule_set, i, 15, 15, tmp, sizeof(tmp));
+            ezplib_get_subrule(rule_set, i, 16, 16, tmp2, sizeof(tmp));
+            ezplib_get_subrule(rule_set, i, 17, 17, tmp3, sizeof(tmp));
+            if (tmp2[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "3des");
+            } else if (tmp3[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "aes");
+            } else if (tmp[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "des");
+            } else {
+                /* default 3DES */
+                len = snprintf(str, 1024 - j, "%s^", "3des");
+            }
+            j += len;
+            str += len;
+
+            /* phase1_group */
+            len = snprintf(str, 1024 - j, "dh2^");
+            j += len;
+            str += len;
+
+            /* phase2_auth */
+            ezplib_get_subrule(rule_set, i, 19, 19, tmp, sizeof(tmp));
+            ezplib_get_subrule(rule_set, i, 20, 20, tmp2, sizeof(tmp));
+            if (tmp[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "md5");
+            } else if (tmp2[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "sha1");
+            } else {
+                /* default MD5 */
+                len = snprintf(str, 1024 - j, "%s^", "md5");
+            }
+            j += len;
+            str += len;
+
+            /* phase2_encrypt */
+            ezplib_get_subrule(rule_set, i, 21, 21, tmp, sizeof(tmp));
+            ezplib_get_subrule(rule_set, i, 22, 22, tmp2, sizeof(tmp));
+            ezplib_get_subrule(rule_set, i, 23, 23, tmp3, sizeof(tmp));
+            if (tmp2[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "3des");
+            } else if (tmp3[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "aes");
+            } else if (tmp[0] == '1') {
+                len = snprintf(str, 1024 - j, "%s^", "des");
+            } else {
+                /* default 3DES */
+                len = snprintf(str, 1024 - j, "%s^", "3des");
+            }
+            j += len;
+            str += len;
+
+            /* phase2_group */
+            len = snprintf(str, 1024 - j, "dh2");
+            j += len;
+            str += len;
+
+            ezplib_replace_rule(rule_set, i, new);
+        }
+    }
+
+#if (WL_NUM > 0 )
+    /* wireless */
+    value = nvram_safe_get("wl0_radio");
+	if (!strcmp(ModeTmpBuf, "ap")){
+    	value2 = nvram_safe_get("wl_ap_basic_rule");
+	} else {
+		value2 = nvram_safe_get("wl_basic_rule");
+	}
+
+    /* wl0_radio exists, nvram is still of old version. */
+    if (*value && !*value2) {
+        /* wl_basic_rule: enable^net_mode^txpower^channel */
+        i = j = 0;
+		if (!strcmp(ModeTmpBuf, "ap")){
+        	rule_set = "wl_ap_basic_rule";
+		} else {
+			rule_set = "wl_basic_rule";
+		}
+        /* wl_basic_rule requires default value. */
+        nvram_fset(rule_set, WL_BASIC_RULE);
+        str = &new[0];
+
+        /* enable */
+        ptr = nvram_safe_get("wl0_radio");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* net_mode */
+        ezplib_get_attr_val(rule_set, i, "net_mode", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* net_mode */
+        ezplib_get_attr_val(rule_set, i, "txpower", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* channel */
+        ezplib_get_attr_val(rule_set, i, "channel", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s", tmp);
+        j += len;
+        str += len;
+		
+        ezplib_replace_rule(rule_set, 0, new);
+
+        /* wl0_basic_rule: enable^hidden^rate^wme */
+        i = j = 0;
+        rule_set = "wl0_basic_rule";
+        /* wl0_basic_rule requires default value. */
+        nvram_fset(rule_set, WL0_BASIC_RULE);
+        str = &new[0];
+
+        /* enable */
+        ptr = nvram_safe_get("wl0_radio");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* hidden */
+        ezplib_get_attr_val(rule_set, i, "hidden", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* rate */
+        ezplib_get_attr_val(rule_set, i, "rate", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* wme */
+        ezplib_get_attr_val(rule_set, i, "wme", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, 0, new);
+
+        /* wl0_ssid: ssid */
+        rule_set = "wl0_ssid_rule";
+        /* wl0_ssid_rule requires default value. */
+        nvram_fset(rule_set, WL0_SSID_RULE);
+
+        ptr = nvram_safe_get("wl0_ssid");
+        ezplib_replace_rule(rule_set, 0, ptr);
+
+        /* wl0_sec_rule: secmode */
+        rule_set = "wl0_sec_rule";
+        /* wl0_sec_rule requires default value. */
+        nvram_fset(rule_set, WL0_SEC_RULE);
+
+        ptr = nvram_safe_get("wl0_sec_mode");
+        ezplib_replace_rule(rule_set, 0, ptr);
+
+        /* wl0_sec_wep_rule: key_index^key1^key2^key3^key4 */
+        i = j = 0;
+        rule_set = "wl0_sec_wep_rule";
+        /* wl0_sec_wep_rule requires default value. */
+        nvram_fset(rule_set, WL0_SEC_WEP_RULE);
+        str = &new[0];
+
+        /* key_index */
+        ptr = nvram_safe_get("wl0_key");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        ptr = nvram_safe_get("wl0_key1");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        ptr = nvram_safe_get("wl0_key2");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        ptr = nvram_safe_get("wl0_key3");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        ptr = nvram_safe_get("wl0_key4");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, 0, new);
+
+        /* wl0_sec_wpa_rule: key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^rekey_time_interval^rekey_pkt_interval */
+        i = j = 0;
+        rule_set = "wl0_sec_wpa_rule";
+        /* wl0_sec_wap_rule requires default value. */
+        nvram_fset(rule_set, WL0_SEC_WPA_RULE);
+        str = &new[0];
+
+        /* key */ 
+        ptr = nvram_safe_get("wl0_wpa_psk");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* crypto */
+        ptr = nvram_safe_get("wl0_crypto");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* radius_key */
+        ptr = nvram_safe_get("wl0_radius_key");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* radius_ipaddr */
+        ptr = nvram_safe_get("wl0_radius_ipaddr");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* radius_port */
+        ptr = nvram_safe_get("wl0_radius_port");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* rekey_mode */
+        ezplib_get_attr_val(rule_set, i, "rekey_mode", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* rekey_time_interval */
+        ezplib_get_attr_val(rule_set, i, "rekey_time_interval", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* rekey_pkt_interval */
+        ezplib_get_attr_val(rule_set, i, "rekey_pkt_interval", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, 0, new);
+
+        /* wl0_sec_wpa2_rule: key^crypto^radius_key^radius_ipaddr^radius_port^rekey_mode^rekey_time_interval^rekey_pkt_interval^preauth */
+        i = j = 0;
+        rule_set = "wl0_sec_wpa2_rule";
+        /* wl0_sec_wap2_rule requires default value. */
+        nvram_fset(rule_set, WL0_SEC_WPA2_RULE);
+        str = &new[0];
+
+        /* key */ 
+        ptr = nvram_safe_get("wl0_wpa_psk");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* crypto */
+        ptr = nvram_safe_get("wl0_crypto");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* radius_key */
+        ptr = nvram_safe_get("wl0_radius_key");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* radius_ipaddr */
+        ptr = nvram_safe_get("wl0_radius_ipaddr");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* radius_port */
+        ptr = nvram_safe_get("wl0_radius_port");
+        len = snprintf(str, 1024 - j, "%s^", ptr);
+        j += len;
+        str += len;
+
+        /* rekey_mode */
+        ezplib_get_attr_val(rule_set, i, "rekey_mode", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* rekey_time_interval */
+        ezplib_get_attr_val(rule_set, i, "rekey_time_interval", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* rekey_pkt_interval */
+        ezplib_get_attr_val(rule_set, i, "rekey_pkt_interval", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* preauth */
+        ezplib_get_attr_val(rule_set, i, "preauth", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, 0, new);
+
+        /* wl_wds_rule: mode^time */
+        i = j = 0;
+        rule_set = "wl_wds_rule";
+        /* wl0_wds_rule requires default value. */
+        nvram_fset(rule_set, WL_WDS_RULE);
+        str = &new[0];
+
+        ptr = nvram_safe_get("wl0_wds_enable");
+        len = snprintf(str, 1024 - j, "%s^1",
+                (ptr[0] == '0') ? "disabled" : "repeater");
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, 0, new);
+
+        /* wl0_wds_basic_rule: mac^secmode */
+        i = j = 0;
+        rule_set = "wl0_wds_basic_rule";
+        /* wl0_wds_basic_rule requires a default value. */
+        nvram_fset(rule_set, WL0_WDS_BASIC_RULE);
+
+        /* wl0_wds_rule_num requires a default value. */
+        nvram_set("wl0_wds_rule_num", xstr(WDS_RULE_MAX));
+        max = atoi(nvram_safe_get("wl0_wds_rule_num"));
+
+        for (i = 0; i < max; i++) {
+            ezplib_get_subrule("wl0_wds", 0, i, i, tmp, sizeof(tmp));
+            snprintf(new, sizeof(new), "%s^disabled", tmp);
+            ezplib_replace_rule(rule_set, i, new);
+        }
+
+        /* Unset the old and unused nvram variables. */
+        /* XXX */
+        nvram_unset("wl0_radio");
+    }
+#endif
+
+#endif //#if 0
+    return 0;
+}
+
+int fw_func_1_7_6_to_1_7_5(void)
+{
+    int i, j, len, rule_num;
+    char new[1024], old[1024];
+    char tmp[64];
+    char *str = &new[0];
+    char *rule_set = "ntp_rule";
+    char *value = nvram_safe_get(rule_set), *value2;
+
+	char ModeTmpBuf[32];
+	ezplib_get_attr_val("wl_mode_rule", 0, "mode", ModeTmpBuf, 32, EZPLIB_USE_CLI);
+
+    printf("fw_func_1_7_6_to_1_7_5\n");
+    /* Check the existence of the value. */
+    if (value && *value) {
+        i = j = 0;
+        ezplib_get_attr_val(rule_set, i, "name", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "enable", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "pool", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_attr_val(rule_set, i, "zone", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        len = snprintf(str, 1024 - j, "%s", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule(rule_set, i, new);
+    }
+
+    rule_num = atoi(nvram_safe_get("ipsec_rule_num"));
+    rule_set = "ipsec_rule";
+    
+    for (i = j = 0; i < rule_num; i++) {
+        str = &new[0];
+        ezplib_get_rule(rule_set, i, old, 1024);
+        /* If empty, nvram boot will create it. */ 
+        /* Check the existence of the value. */
+        if (old[0]) {
+            /* name^enable */
+            ezplib_get_subrule(rule_set, i, 0, 1, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* adv */
+            ezplib_get_attr_val(rule_set, i, "adv", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* mode^l2tp^local_extif^local_inipaddr^local_netmask^remote_gateway^remote_inipaddr^remote_netmask^conn_init */
+            ezplib_get_subrule(rule_set, i, 2, 10, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* phase1_mode */
+            ezplib_get_attr_val(rule_set, i, "phase1_mode", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* phase1_auth */
+            ezplib_get_attr_val(rule_set, i, "phase1_auth", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            if (!strcmp(tmp, "md5")) {
+                len = snprintf(str, 1024 - j, "1^0^");
+            } else if (!strcmp(tmp, "sha1")) {
+                len = snprintf(str, 1024 - j, "0^1^");
+            } else {
+                len = snprintf(str, 1024 - j, "1^1^");
+            }
+            j += len;
+            str += len;
+
+            /* phase1_encrypt */
+            ezplib_get_attr_val(rule_set, i, "phase1_encrypt", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            if (!strcmp(tmp, "des")) {
+                len = snprintf(str, 1024 - j, "1^0^0^");
+            } else if (!strcmp(tmp, "3des")) {
+                len = snprintf(str, 1024 - j, "0^1^0^");
+            } else if (!strcmp(tmp, "aes")) {
+                len = snprintf(str, 1024 - j, "0^0^1^");
+            } else {
+                len = snprintf(str, 1024 - j, "1^1^1^");
+            }
+            j += len;
+            str += len;
+
+            ezplib_get_attr_val(rule_set, i, "phase1_id", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* phase2_auth */
+            ezplib_get_attr_val(rule_set, i, "phase2_auth", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            if (!strcmp(tmp, "md5")) {
+                len = snprintf(str, 1024 - j, "1^0^");
+            } else if (!strcmp(tmp, "sha1")) {
+                len = snprintf(str, 1024 - j, "0^1^");
+            } else {
+                len = snprintf(str, 1024 - j, "1^1^");
+            }
+            j += len;
+            str += len;
+
+            /* phase2_encrypt */
+            ezplib_get_attr_val(rule_set, i, "phase2_encrypt", tmp, sizeof(tmp),
+                    EZPLIB_USE_CLI);
+            if (!strcmp(tmp, "des")) {
+                len = snprintf(str, 1024 - j, "1^0^0^");
+            } else if (!strcmp(tmp, "3des")) {
+                len = snprintf(str, 1024 - j, "0^1^0^");
+            } else if (!strcmp(tmp, "aes")) {
+                len = snprintf(str, 1024 - j, "0^0^1^");
+            } else {
+                len = snprintf(str, 1024 - j, "0^0^0^");
+            }
+            j += len;
+            str += len;
+
+            /* phase1_lifetime^phase2_lifetime */
+            ezplib_get_subrule(rule_set, i, 18, 19, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s^", tmp);
+            j += len;
+            str += len;
+
+            /* pfs */
+            len = snprintf(str, 1024 - j, "0^", tmp);
+            j += len;
+            str += len;
+
+            /* ike_keymode^psk^rsa^ca */
+            ezplib_get_subrule(rule_set, i, 11, 14, tmp, sizeof(tmp));
+            len = snprintf(str, 1024 - j, "%s", tmp);
+            j += len;
+            str += len;
+
+            ezplib_replace_rule(rule_set, i, new);
+        }
+    }
+
+    value = nvram_safe_get("wl0_radio");
+	if (!strcmp(ModeTmpBuf, "ap")){
+    	value2 = nvram_safe_get("wl_ap_basic_rule");
+	} else {
+		value2 = nvram_safe_get("wl_basic_rule");
+	}
+
+    if (!*value && *value2) {
+        /* wl0_radio */
+		if (!strcmp(ModeTmpBuf, "ap")){
+        	rule_set = "wl_ap_basic_rule";
+		}else {
+			rule_set = "wl_basic_rule";
+		}
+        ezplib_get_attr_val(rule_set, 0, "enable", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_fset("wl0_radio", tmp);
+
+        /* wl0_ssid */
+        rule_set = "wl0_ssid_rule";
+        ezplib_get_attr_val(rule_set, 0, "ssid", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_fset("wl0_ssid", tmp);
+
+#if 0
+        /* wl0_sec_mode */
+        rule_set = "wl0_sec_rule";
+        ezplib_get_attr_val(rule_set, 0, "secmode", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_set("wl0_sec_mode", tmp);
+
+        /* wl0_key */
+        rule_set = "wl0_sec_wep_rule";
+        ezplib_get_attr_val(rule_set, 0, "key_index", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_set("wl0_key", tmp);
+
+        /* wl0_key1 */
+        rule_set = "wl0_sec_wep_rule";
+        ezplib_get_attr_val(rule_set, 0, "key1", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_set("wl0_key1", tmp);
+
+        /* wl0_key2 */
+        rule_set = "wl0_sec_wep_rule";
+        ezplib_get_attr_val(rule_set, 0, "key2", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_set("wl0_key1", tmp);
+
+        /* wl0_key3 */
+        rule_set = "wl0_sec_wep_rule";
+        ezplib_get_attr_val(rule_set, 0, "key3", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_set("wl0_key1", tmp);
+
+        /* wl0_key4 */
+        rule_set = "wl0_sec_wep_rule";
+        ezplib_get_attr_val(rule_set, 0, "key4", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        nvram_set("wl0_key1", tmp);
+
+        /* wl0_wpa_psk */
+#endif
+        /* Unset the unused nvram variables. */
+		if (!strcmp(ModeTmpBuf, "ap")){
+			nvram_unset("wl_ap_basic_rule");
+		}else {
+			nvram_unset("wl_basic_rule");
+		}
+    }
+    return 0;
+}
+
+//TODO
+int fw_func_1_7_6_to_1_7_7(void)
+{
+#if 0 
+    char *rule_set;
+    char new[1024], old[1024];
+    char tmp[64];
+    char *str = &new[0];
+    int i, j, num, vnum;
+
+	char ModeTmpBuf[32];
+	ezplib_get_attr_val("wl_mode_rule", 0, "mode", ModeTmpBuf, 32, EZPLIB_USE_CLI);
+
+    printf("fw_func_1_7_6_to_1_7_7\n");
+
+#if (WL_NUM >0)
+    rule_set = "wl_wds_rule";
+    ezplib_get_attr_val(rule_set, 0, "mode", tmp, sizeof(tmp), EZPLIB_USE_CLI);
+    if (tmp[0] == '0') {
+        /* This is due to correct the error in fw_func_1_7_5_to_1_7_6(). */
+        ezplib_get_attr_val(rule_set, 0, "timeout", tmp, sizeof(tmp),
+                            EZPLIB_USE_CLI);
+        snprintf(new, sizeof(new), "disabled^%s", tmp);
+        ezplib_replace_rule(rule_set, 0, new);
+    }
+
+    rule_set = "wl0_wds_basic_rule";
+    str = nvram_safe_get(rule_set);
+    if (!strcmp(str, "0^1")) {
+        /* This is due to correct the error in the original 
+         * fw_func_1_7_5_to_1_7_6(). 
+         */
+        nvram_set(rule_set, WL0_WDS_BASIC_RULE);
+    }
+
+    /* wl_basic_rule:
+     * From old format: enable^net_mode^txpower^channel
+     * To new format: enable^net_mode^txpower^channel^bisolation
+     */
+    if (!strcmp(ModeTmpBuf, "ap")){
+		rule_set = "wl_ap_basic_rule";
+	}else {
+		rule_set = "wl_basic_rule";
+	}
+    num = atoi(nvram_safe_get("wl_num"));
+    for (i = 0; i < num; i++) {
+        ezplib_get_rule(rule_set, i, old, sizeof(old));
+        snprintf(new, sizeof(new), "%s^0", old);
+        ezplib_replace_rule(rule_set, i, new);
+    }
+
+    /* wlX_basic_rule:
+     * From old format: enable^hidden^rate^wme
+     * To new format: enable^hidden^rate^wme^isolation
+     */
+    num = atoi(nvram_safe_get("wl_num"));
+    /* From 1.7.5 to 1.7.7 directly, wlv_rule_set hasn't been set. */
+    vnum = atoi(xstr(WL0_RULE_NUM));
+    for (i = 0; i < num; i++) {
+        snprintf(tmp, sizeof(tmp), "wl%d_basic_rule", i);
+
+        for (j = 0; j < vnum; j++) {
+            ezplib_get_rule(tmp, j, old, sizeof(old));
+            snprintf(new, sizeof(new), "%s^0", old);
+            ezplib_replace_rule(tmp, j, new);
+        }
+    }
+#endif
+
+    /* Unset upnp_rule. So it falls back to default. */
+    nvram_unset("upnp_rule");
+#endif
+	return 0;
+}
+
+int fw_func_1_7_7_to_1_7_6(void)
+{
+    char *rule_set;
+    char new[1024], old[1024];
+    char tmp[64];
+    char *str = &new[0];
+    int i, j, num, vnum;
+
+	char ModeTmpBuf[32];
+	ezplib_get_attr_val("wl_mode_rule", 0, "mode", ModeTmpBuf, 32, EZPLIB_USE_CLI);
+
+    printf("fw_func_1_7_7_to_1_7_6\n");
+
+    /* wl_basic_rule:
+     * From new format: enable^net_mode^txpower^channel^bisolation
+     * To old format: enable^net_mode^txpower^channel
+     */
+    if (!strcmp(ModeTmpBuf, "ap")){
+		rule_set = "wl_ap_basic_rule";
+	}else {
+		rule_set = "wl_basic_rule";
+	}
+    num = atoi(nvram_safe_get("wl_num"));
+    for (i = 0; i < num; i++) {
+        ezplib_get_subrule(rule_set, i, 0, 3, new, sizeof(new));
+        ezplib_replace_rule(rule_set, i, new);
+    }
+
+    /* wlX_basic_rule:
+     * From new format: enable^hidden^rate^wme^isolation
+     * To old format: enable^hidden^rate^wme
+     */
+    num = atoi(nvram_safe_get("wl_num"));
+    vnum = atoi(nvram_safe_get("wlv_rule_num"));
+    for (i = 0; i < num; i++) {
+        snprintf(tmp, sizeof(tmp), "wl%d_basic_rule", i);
+
+        for (j = 0; j < vnum; j++) {
+            ezplib_get_subrule(tmp, i, 0, 3, new, sizeof(new));
+            ezplib_replace_rule(tmp, j, new);
+        }
+    }
+
+    /* Unset upnp_rule. So it falls back to default. */
+    nvram_unset("upnp_rule");
+
+    /* Rewind the MAC address. */
+    system("echo 1 > /proc/ezp_rewind");
+}
+
+int fw_func_1_7_7_to_1_7_8(void)
+{
+    printf("fw_func_1_7_7_to_1_7_8\n");
+    return 0;
+}
+
+int fw_func_1_7_8_to_1_7_7(void)
+{
+    printf("fw_func_1_7_8_to_1_7_7\n");
+    return 0;
+}
+
+int fw_func_1_7_8_to_1_7_9(void)
+{
+    char tmp[1024], name[1024], ipaddr_start[64], ipaddr_end[64];
+    char new[1024], old[1024];
+    char *str;
+    int nrule, i, j, dbm_nrule, len, start, end, num;
+
+    printf("fw_func_1_7_8_to_1_7_9\n");
+
+    nvram_fset("bw_dbm_rule", "");
+    nvram_fset("bw_dbm_rule_num", "0");
+    nvram_fset("bw_sbm_rule", "");
+    nvram_fset("bw_sbm_rule_num", "0");
+
+    nrule = atoi(nvram_safe_get("fl_rule_num"));
+    for (i = 0; i < nrule; i++) {
+        /* dbm_enable */
+        ezplib_get_subrule("fl_rule", i, 14, 14, tmp, sizeof(tmp));
+        if (tmp[0] == '1') {
+            /* The rule with DBM enabled. */
+            ezplib_get_attr_val("fl_rule", i, "name", name, sizeof(name),
+                    EZPLIB_USE_CLI);
+            ezplib_get_attr_val("fl_rule", i, "srcipaddr_start", ipaddr_start,
+                    sizeof(ipaddr_start), EZPLIB_USE_CLI);
+            ezplib_get_attr_val("fl_rule", i, "srcipaddr_end", ipaddr_end,
+                    sizeof(ipaddr_end), EZPLIB_USE_CLI);
+            /* 1.7.8 had a bug in L4 that the dbm_num is mistaken as 32.
+             * Therefore, we cannot directly use this attribute in fl_rule.
+             */
+            start = ntohl((int)inet_addr(ipaddr_start));
+            end = ntohl((int)inet_addr(ipaddr_end));
+            num = end - start + 1;
+            snprintf(tmp, sizeof(tmp), "%s^1^%s^%s^%d^", name, ipaddr_start, ipaddr_end, num);
+            ezplib_append_rule("bw_dbm_rule", tmp);
+
+            /* Increase the number of DBM rules. */
+            dbm_nrule = atoi(nvram_safe_get("bw_dbm_rule_num"));
+            snprintf(tmp, sizeof(tmp), "%d", dbm_nrule+1);
+            nvram_set("bw_dbm_rule_num", tmp);
+        }
+
+        /* Remove the attribute 'dbm_enable' and 'dbm_num' from fl_rule */
+        j = 0;
+        str = &new[0];
+
+        ezplib_get_subrule("fl_rule", i, 0, 13, tmp, sizeof(tmp));
+        len = snprintf(str, sizeof(new) - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_subrule("fl_rule", i, 16, 18, tmp, sizeof(tmp));
+        len = snprintf(str, sizeof(new) - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule("fl_rule", i, new);
+    }
+
+    return 0;
+}
+
+int fw_func_1_7_9_to_1_7_8(void)
+{
+    char tmp[1024], name[1024], start[64], end[64], num[64], mark[64];
+    char new[1024];
+    int nrule, i, j, fl_nrule, len;
+    char *str;
+
+    printf("fw_func_1_7_9_to_1_7_8\n");
+
+    /* Add back the attribute 'dbm_enable' and 'dbm_num' into fl_rule. */
+    nrule = atoi(nvram_safe_get("fl_rule_num"));
+    for (i = 0; i < nrule; i++, j += atoi(num)) {
+        char ipaddr_start[64], ipaddr_end[64];
+
+        j = 0;
+        str = &new[0];
+
+        ezplib_get_subrule("fl_rule", i, 0, 13, tmp, sizeof(tmp));
+        len = snprintf(str, sizeof(new) - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        /* 'dbm_enable' and 'dbm_num' */
+        /* dbm_num would be updated as a correct value when executing
+         * save_fl().
+         */
+        len = snprintf(str, sizeof(new) - j, "0^0^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_get_subrule("fl_rule", i, 14, 16, tmp, sizeof(tmp));
+        len = snprintf(str, sizeof(new) - j, "%s^", tmp);
+        j += len;
+        str += len;
+
+        ezplib_replace_rule("fl_rule", i, new);
+    }
+
+    /* Move the rules in bw_dbm_rule to fl_rule. */
+    nrule = atoi(nvram_safe_get("bw_dbm_rule_num"));
+    for (i = 0, j = 0; i < nrule; i++, j += atoi(num)) {
+        ezplib_get_attr_val("bw_dbm_rule", i, "enable", tmp, sizeof(tmp),
+                EZPLIB_USE_CLI);
+        if (tmp[0] == '0') {
+            continue;
+        }
+
+        ezplib_get_attr_val("bw_dbm_rule", i, "name", name, sizeof(name),
+                EZPLIB_USE_CLI);
+        ezplib_get_attr_val("bw_dbm_rule", i, "inipaddr_start", start,
+                sizeof(start), EZPLIB_USE_CLI);
+        ezplib_get_attr_val("bw_dbm_rule", i, "inipaddr_end", end,
+                sizeof(end), EZPLIB_USE_CLI);
+        ezplib_get_attr_val("bw_dbm_rule", i, "inipaddr_num", num,
+                sizeof(num), EZPLIB_USE_CLI);
+
+        snprintf(mark, sizeof(mark), "%04X", j+1);
+        snprintf(tmp, sizeof(tmp), "%s^1^^^%s^%s^^^^^^^^1^1^%s^%s^0^0", name, start,
+                end, num, mark);
+
+        ezplib_append_rule("fl_rule", tmp);
+
+        fl_nrule = atoi(nvram_safe_get("fl_rule_num"));
+        snprintf(tmp, sizeof(tmp), "%d", fl_nrule+1);
+
+        nvram_set("fl_rule_num", tmp);
+    }
+        
+    /* Roll back the wan_bw_rule. */
+    nrule = atoi(nvram_safe_get("wan_num"));
+    for (i = 0; i < nrule; i++) {
+        char dl[64], ul[64], dl_max[64], dl_min[64], ul_max[64], ul_min[64];
+        char *p_link_percent = "75";
+        int link_percent = 75;
+        int global_percent = 90;
+        int user_percent = 90;
+        int bw_num, used_ul, used_dl, ulmax, ulmin, dlmax, dlmin;
+
+        bw_num = atoi(nvram_safe_get("dbm_max"));
+
+        ezplib_get_attr_val("wan_bw_rule", i, "dl", dl, sizeof(dl),
+                EZPLIB_USE_CLI);
+        ezplib_get_attr_val("wan_bw_rule", i, "ul", ul, sizeof(ul),
+                EZPLIB_USE_CLI);
+
+        used_ul = atoi(ul);
+        used_dl = atoi(dl);
+
+        ulmax = used_ul * link_percent / 100;
+        ulmax = ulmax * global_percent / 100;
+        ulmax = ulmax * user_percent / 100;
+        ulmin = ulmax / bw_num;
+
+        dlmax = used_dl * link_percent / 100;
+        dlmax = dlmax * global_percent / 100;
+        dlmax = dlmax * user_percent / 100;
+        dlmin = dlmax / bw_num;
+
+        snprintf(ul_max, sizeof(ul_max), "%d", ulmax);
+        snprintf(ul_min, sizeof(ul_min), "%d", ulmin);
+        snprintf(dl_max, sizeof(dl_max), "%d", dlmax);
+        snprintf(dl_min, sizeof(dl_min), "%d", dlmin);
+
+        ezplib_replace_attr("wan_bw_rule", i, "link_percent", p_link_percent);
+        ezplib_replace_attr("wan_bw_rule", i, "dbm_upmax", ul_max);
+        ezplib_replace_attr("wan_bw_rule", i, "dbm_upmin", ul_min);
+        ezplib_replace_attr("wan_bw_rule", i, "dbm_downmax", dl_max);
+        ezplib_replace_attr("wan_bw_rule", i, "dbm_downmin", dl_min);
+    }
+
+    nvram_unset("bw_dbm_rule");
+    nvram_unset("bw_dbm_rule_num");
+    nvram_unset("bw_sbm_rule");
+    nvram_unset("bw_sbm_rule_num");
+
+    return 0;
+}
+
+int fw_func_1_7_9_to_1_7_10(void)
+{
+    printf("fw_func_1_7_9_to_1_7_10\n");
+    return 0;
+}
+
+int fw_func_1_7_10_to_1_7_9(void)
+{
+    printf("fw_func_1_7_10_to_1_7_9\n");
+    return 0;
+}
+
+int fw_func_1_7_10_to_1_7_11(void)
+{
+    printf("fw_func_1_7_10_to_1_7_11\n");
+    nvram_set("bw_mask", "0xFFFF0000");
+    return 0;
+}
+
+int fw_func_1_7_11_to_1_7_10(void)
+{
+    printf("fw_func_1_7_11_to_1_7_10\n");
+    nvram_set("bw_mask", "0x00FFFFFF");
+    return 0;
+}
+
+int fw_func_1_7_11_to_2_0_0(void)
+{
+    printf("fw_func_1_7_11_to_2_0_0\n");
+    return 0;
+}
+
+int fw_func_2_0_0_to_1_7_11(void)
+{
+    printf("fw_func_2_0_0_to_1_7_11\n");
+    return 0;
+}
+
+int fw_func_2_0_1_to_2_0_0(void)
+{
+    char codepage[64], swap_size[64];
+    char tmp[1024];
+    printf("fw_func_2_0_1_to_2_0_0\n");
+    ezplib_get_attr_val("storage_rule", 0, "codepage",
+            codepage, sizeof(codepage), EZPLIB_USE_CLI);
+    ezplib_get_attr_val("storage_rule", 0, "swap_size",
+            swap_size, sizeof(swap_size), EZPLIB_USE_CLI);
+    snprintf(tmp, sizeof(tmp), "^%s^%s^",
+            codepage, swap_size);
+    ezplib_replace_rule("storage_rule", 0, tmp);
+    nvram_unset("storage_state_rule");
+    return 0;
+}
+
+int fw_func_2_0_0_to_2_0_1(void)
+{
+    char buf[64];
+    char tmp[1024];
+    printf("fw_func_2_0_0_to_2_0_1\n");
+    nvram_fset("storage_state_rule", "^");
+    ezplib_get_subrule("storage_rule", 0, 1, 2, buf, sizeof(buf));
+    snprintf(tmp, sizeof(tmp), "%s^4096", buf);
+    ezplib_replace_rule("storage_rule", 0, tmp);
+    return 0;
+}
+
+int fw_func_2_0_2_to_2_0_1(void)
+{
+    char buf[64];
+    char tmp[1024];
+    printf("fw_func_2_0_2_to_2_0_1\n");
+    ezplib_get_subrule("lan_dhcps_rule", 0, 0, 6, buf, sizeof(buf));
+    snprintf(tmp, sizeof(tmp), "%s", buf);
+    ezplib_replace_rule("lan_dhcps_rule", 0, tmp);
+
+    /* stats_rule */
+#ifdef CONFIG_EZP_ARCH_RT305X
+#if ( WAN_NUM == 1 ) && ( LAN_NUM == 1 )
+    ezplib_replace_rule("stats_rule", 0,
+            "^1^60^vlan1 vlan2 ppp0 br0 ra0");
+#elif ( WAN_NUM == 2 ) && ( LAN_NUM == 1 ) 
+    ezplib_replace_rule("stats_rule", 0,
+        "^1^60^vlan3 vlan1 vlan2 ppp0 ppp1 br0 ra0");
+#endif
+#endif
+    return 0;
+}
+
+int fw_func_2_0_1_to_2_0_2(void)
+{
+    char buf[64];
+    char tmp[1024];
+    printf("fw_func_2_0_1_to_2_0_2\n");
+    ezplib_get_subrule("lan_dhcps_rule", 0, 0, 6, buf, sizeof(buf));
+    snprintf(tmp, sizeof(tmp), "%s^dnsrelay^^^^", buf);
+    ezplib_replace_rule("lan_dhcps_rule", 0, tmp);
+
+    /* stats_rule */
+#ifdef CONFIG_EZP_ARCH_RT305X
+#if ( WAN_NUM == 1 ) && ( LAN_NUM == 1 )
+    ezplib_replace_rule("stats_rule", 0,
+            "^1^60^vlan1 vlan2 ppp0 br0 ra0 usb0 eth0");
+#elif ( WAN_NUM == 2 ) && ( LAN_NUM == 1 ) 
+    ezplib_replace_rule("stats_rule", 0,
+        "^1^60^vlan3 vlan1 vlan2 ppp0 ppp1 br0 ra0 usb0 eth0 eth1");
+#endif
+#endif
+    return 0;
+}
+
+int fw_func_2_0_3_to_2_0_2(void)
+{
+    char buf[256], buf2[256];
+    char tmp[1024];
+    int i, nrule;
+
+	char ModeTmpBuf[32];
+	ezplib_get_attr_val("wl_mode_rule", 0, "mode", ModeTmpBuf, 32, EZPLIB_USE_CLI);
+
+    printf("fw_func_2_0_3_to_2_0_2\n");
+
+    nrule = atoi(nvram_safe_get("wan_num"));
+    /* wan_pppoe_rule */
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_subrule("wan_pppoe_rule", i, 1, 8, buf, sizeof(buf));
+        ezplib_replace_rule("wan_pppoe_rule", i, buf);
+    }
+
+    /* wan_wwan_rule */
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_subrule("wan_wwan_rule", i, 0, 5, buf, sizeof(buf));
+        ezplib_get_subrule("wan_wwan_rule", i, 7, 21, buf2, sizeof(buf2));
+        snprintf(tmp, sizeof(tmp), "%s^%s", buf, buf2);
+        ezplib_replace_rule("wan_wwan_rule", i, tmp);
+    }
+
+    ezplib_get_subrule("ftpd_rule", 0, 0, 9, buf, sizeof(buf));
+    snprintf(tmp, sizeof(tmp), "%s", buf);
+    ezplib_replace_rule("ftpd_rule", 0, tmp);
+    
+    /* Wireless advanced rule downgrade */
+    nrule = atoi(nvram_safe_get("wl_rule_num"));
+    for (i = 0; i < nrule; i++) {
+		if (!strcmp(ModeTmpBuf, "ap")){
+			ezplib_get_subrule("wl_ap_advanced_rule", i, 0, 13, buf, sizeof(buf));
+			ezplib_replace_rule("wl_ap_advanced_rule", i, buf);
+		} else {
+			ezplib_get_subrule("wl_advanced_rule", i, 0, 13, buf, sizeof(buf));
+			ezplib_replace_rule("wl_advanced_rule", i, buf);
+		}
+    }
+
+    /* Routing rule */
+    nrule = atoi(nvram_safe_get("rt_rule_num"));
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_subrule("rt_rule", i, 0, 11, buf, sizeof(buf));
+        ezplib_replace_rule("rt_rule", i, buf);
+    }
+    
+    /* OpenDNS rule */
+    nrule = atoi(nvram_safe_get("wan_num"));
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_subrule("wan_opendns_rule", i, 0, 4, buf, sizeof(buf));
+        ezplib_replace_rule("wan_opendns_rule", i, buf);
+    }
+
+    return 0;
+}
+
+int fw_func_2_0_2_to_2_0_3(void)
+{
+    char buf[256], buf2[256];
+    char tmp[1024];
+    int i, nrule;
+	char ModeTmpBuf[32];
+	ezplib_get_attr_val("wl_mode_rule", 0, "mode", ModeTmpBuf, 32, EZPLIB_USE_CLI);
+
+    printf("fw_func_2_0_2_to_2_0_3\n");
+
+    nrule = atoi(nvram_safe_get("wan_num"));
+    /* wan_pppoe_rule */
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_subrule("wan_pppoe_rule", i, 0, 7, buf, sizeof(buf));
+        snprintf(tmp, sizeof(tmp), "chap^%s", buf);
+        ezplib_replace_rule("wan_pppoe_rule", i, tmp);
+    }
+    /* wan_wwan_rule */
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_subrule("wan_wwan_rule", i, 0, 5, buf, sizeof(buf));
+        ezplib_get_subrule("wan_wwan_rule", i, 6, 20, buf2, sizeof(buf2));
+        snprintf(tmp, sizeof(tmp), "%s^chap^%s", buf, buf2);
+        ezplib_replace_rule("wan_wwan_rule", i, tmp);
+    }
+    
+    ezplib_get_subrule("ftpd_rule", 0, 0, 9, buf, sizeof(buf));
+    snprintf(tmp, sizeof(tmp), "%s^0", buf);
+    ezplib_replace_rule("ftpd_rule", 0, tmp);
+    nvram_unset("samba_rule");
+
+    /* Wireless advanced rule */
+    nrule = atoi(nvram_safe_get("wl_rule_num"));
+    for (i = 0; i < nrule; i++) {
+		if (!strcmp(ModeTmpBuf, "ap")){
+			ezplib_get_rule("wl_ap_advanced_rule", i, buf, sizeof(buf));
+			snprintf(tmp, sizeof(tmp), "%s^1^0^0^0^0^0^1^1^0^33^5^0^1^8^0", buf);
+			ezplib_replace_rule("wl_ap_advanced_rule", i, tmp);
+		} else {
+			ezplib_get_rule("wl_advanced_rule", i, buf, sizeof(buf));
+			snprintf(tmp, sizeof(tmp), "%s^1^0^0^0^0^0^1^1^0^33^5^0^1^8^0", buf);
+			ezplib_replace_rule("wl_advanced_rule", i, tmp);
+		} 
+    }
+
+    /* Routing rule */
+    nrule = atoi(nvram_safe_get("rt_rule_num"));
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_rule("rt_rule", i, buf, sizeof(buf));
+        snprintf(tmp, sizeof(tmp), "%s^default^", buf);
+        ezplib_replace_rule("rt_rule", i, tmp);
+    }
+
+    /* Dhcp rule */
+    /* Replace DNS setting to default opendns */
+    ezplib_replace_attr("lan_dhcps_rule", 0, "dnstype", "opendns");
+    ezplib_replace_attr("lan_dhcps_rule", 0, "dnsaddr1", "208.67.220.220");
+    ezplib_replace_attr("lan_dhcps_rule", 0, "dnsaddr2", "208.67.222.222");
+
+    /* OpenDNS rule */
+    nrule = atoi(nvram_safe_get("wan_num"));
+    for (i = 0; i < nrule; i++) {
+        ezplib_get_rule("wan_opendns_rule", i, buf, sizeof(buf));
+        snprintf(tmp, sizeof(tmp), "%s^", buf);
+        ezplib_replace_rule("wan_opendns_rule", i, tmp);
+    }
+
+    return 0;
+}
+
+int fw_func_2_0_4_to_2_0_3(void)
+{
+    char buf[256], buf2[256];
+    char tmp[1024];
+    int i, nrule;
+    printf("fw_func_2_0_4_to_2_0_3\n");
+    /* get bt rule attr */
+    /* bt rule
+     * enable[0|1]^peer^max_peer^max_task^download_rate^upload_rate^directory^session^load_start^port_range_start^port_range_end^dht_port^check_hash */
+    ezplib_get_subrule("bt_rule", 0, 1, 1, buf, sizeof(buf));
+    ezplib_get_subrule("bt_rule", 0, 3, 12, buf2, sizeof(buf2));
+
+    /* set rtorrent_rule */
+    /*rtorrent rule
+     * enable[0|1]^min_peer^max_peer^max_upload^download_rate^upload_rate^directory^session^load_start^port_range_start^port_range_end^dht_port^check_hash
+     */
+    snprintf(tmp, sizeof(tmp), "1^10^%s^2^%s" , buf, buf2);
+    nvram_set("rtorrent_rule", tmp);
+    ezplib_get_subrule("bt_torrent_max", 0, 0, 0, buf, sizeof(buf));
+    nvram_set("rtorrent_torrent_max", buf);
+    
+    /* unset bt rule */
+    nvram_unset("bt_rule");
+    nvram_unset("bt_torrent_max");
+
+    /* wan_wwan_rule */
+    nrule = atoi(nvram_safe_get("wan_num"));
+    for (i = 0; i < nrule; i++) {
+    /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
+     * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
+     * ctrltty^devname^flag^turbolink
+     */
+        ezplib_get_subrule("wan_wwan_rule", i, 1, 22, buf, sizeof(buf));
+
+    /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
+     * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
+     * ctrltty^devname^flag
+     */
+        ezplib_replace_rule("wan_wwan_rule", i, buf);
+    }
+
+   /* wan_htc_rule */
+    nrule = atoi(nvram_safe_get("wan_num"));
+    for (i = 0; i < nrule; i++) {
+   /* hostname^domain^lease^mtu^turbolink */
+        ezplib_get_subrule("wan_htc_rule", i, 1, 4, buf, sizeof(buf));
+
+   /* hostname^domain^lease^mtu */
+        ezplib_replace_rule("wan_htc_rule", i, buf);
+    }
+    return 0;
+}
+
+int fw_func_2_0_3_to_2_0_4(void)
+{
+    char buf[256], buf2[256];
+    char tmp[1024];
+    int i, nrule;
+    printf("fw_func_2_0_3_to_2_0_4\n");
+    /* get rtorrent rule attr */
+    /*rtorrent rule
+     * enable[0|1]^min_peer^max_peer^max_upload^download_rate^upload_rate^directory^session^load_start^port_range_start^port_range_end^dht_port^check_hash
+     */
+    ezplib_get_subrule("rtorrent_rule", 0, 2, 2, buf, sizeof(buf));
+    ezplib_get_subrule("rtorrent_rule", 0, 4, 12, buf2, sizeof(buf2));
+    /* set bt_rule */
+    /* bt rule
+     * enable[0|1]^peer^max_peer^max_task^download_rate^upload_rate^directory^session^load_start^port_range_start^port_range_end^dht_port^check_hash
+     */
+    snprintf(tmp, sizeof(tmp), "1^%s^250^10^%s" , buf, buf2);
+    nvram_set("bt_rule", tmp);
+    /* unset rtorrent rule */
+    nvram_unset("rtorrent_rule");
+    nvram_unset("rtorrent_torrent_max");
+
+    /* wan_wwan_rule */
+    nrule = atoi(nvram_safe_get("wan_num"));
+    for (i = 0; i < nrule; i++) {
+    /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
+     * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
+     * ctrltty^devname^flag
+     */
+        ezplib_get_subrule("wan_wwan_rule", i, 1, 22, buf, sizeof(buf));
+
+    /* apn_type^location^isp^apn^pin^mode^auth^username^passwd^demand^
+     * idletime^redialperiod^mru^mtu^dialstr^brand^model^numtty^datatty^
+     * ctrltty^devname^flag^turbolink
+     */
+        snprintf(tmp, sizeof(tmp), "%s^0", buf);
+        ezplib_replace_rule("wan_wwan_rule", i, tmp);
+    }
+
+    /* wan_htc_rule */
+    nrule = atoi(nvram_safe_get("wan_num"));
+    for (i = 0; i < nrule; i++) {
+    /* hostname^domain^lease^mtu */
+        ezplib_get_subrule("wan_htc_rule", i, 1, 4, buf, sizeof(buf));
+
+    /* hostname^domain^lease^mtu^turbolink */
+        snprintf(tmp, sizeof(tmp), "%s^0", buf);
+        ezplib_replace_rule("wan_htc_rule", i, tmp);
+    }
+    return 0;
+}
+
+int fw_func_2_0_5_to_2_0_4(void)
+{
+    char tmp[256];
+    printf("fw_func_2_0_5_to_2_0_4\n");
+    /* Modify storage_rule form 
+     * codepage^swap_size^block_size^ext_enable^target_ip^target_dir^user^pw^gp
+     * to
+     * codepage^swap_size^block_size
+     */
+    
+    return 0;
+}
+
+//TODO
+int fw_func_2_0_4_to_2_0_5(void)
+{
+#if 0
+    char tmp[256], buf[256];
+    int rule_num;
+    printf("fw_func_2_0_4_to_2_0_5\n");
+    /* Modify storage_rule form 
+     * codepage^swap_size^block_size
+     * to
+     * codepage^swap_size^block_size^ext_enable^target_ip^target_dir^user^pw^gp
+     */
+    rule_num = atoi(nvram_safe_get("bw_sbm_rule_num"));
+    if (rule_num == 8) {
+        ezplib_append_rule("bw_sbm_rule",GuestLANtoLAN);
+        ezplib_append_rule("bw_sbm_rule",GuestLANtoWAN);
+        rule_num += 2;
+        sprintf(tmp, "%d", rule_num);
+        nvram_set("bw_sbm_rule_num", tmp);
+    }
+    rule_num = atoi(nvram_safe_get("br_rule_num"));
+    if (rule_num == 2) {
+        ezplib_append_rule("br_rule", BR_RULE_GUESTLAN);
+        rule_num += 1;
+        sprintf(tmp, "%d", rule_num);
+        nvram_set("br_rule_num", tmp);
+    }
+    rule_num = atoi(nvram_safe_get("lan_num"));
+    if (rule_num == 1) {
+        ezplib_append_rule("lan_main_rule", LAN_MAIN_GUESTLAN);
+        ezplib_append_rule("lan_static_rule", LAN_STATIC_GUESTLAN);
+        ezplib_append_rule("lan_static_rule_default", LAN_STATIC_GUESTLAN);
+        ezplib_append_rule("lan_dhcps_rule", LAN_DHCPS_GUESTLAN);
+        rule_num += 1;
+        sprintf(tmp, "%d", rule_num);
+        nvram_set("lan_num", tmp);
+    }
+    ezplib_append_rule("",GuestLANtoLAN);
+#endif
+    return 0;
+}
diff --git a/nvram_fw.h b/nvram_fw.h
index 1babb43..b75cdba 100644
--- a/nvram_fw.h
+++ b/nvram_fw.h
@@ -5,6 +5,26 @@ typedef enum
 {
     NVRAM_FW_0_0_0 = 0,
     NVRAM_FW_1_6_5,
+    NVRAM_FW_1_6_6,
+    NVRAM_FW_1_6_7,
+    NVRAM_FW_1_7_0,
+    NVRAM_FW_1_7_1,
+    NVRAM_FW_1_7_2,
+    NVRAM_FW_1_7_3,
+    NVRAM_FW_1_7_4,
+    NVRAM_FW_1_7_5,
+    NVRAM_FW_1_7_6,
+    NVRAM_FW_1_7_7,
+    NVRAM_FW_1_7_8,
+    NVRAM_FW_1_7_9,
+    NVRAM_FW_1_7_10,
+    NVRAM_FW_1_7_11,
+    NVRAM_FW_2_0_0,
+    NVRAM_FW_2_0_1,
+    NVRAM_FW_2_0_2,
+    NVRAM_FW_2_0_3,
+    NVRAM_FW_2_0_4,
+    NVRAM_FW_2_0_5,
 } nvram_fw_version;
 
 struct nvram_fw_tuple {
diff --git a/nvram_public.c b/nvram_public.c
index ecdf85f..542086b 100644
--- a/nvram_public.c
+++ b/nvram_public.c
@@ -1,10 +1,8 @@
 #include "nvram.h"
 #include "nvram_fw.h"
 #include "nvram_factory.h"
-
 /* Global */
 nvram_handle_t *nvram_h = NULL;
-extern struct nvram_fw_tuple nvram_fw_table[];
 
 /* **************** public functions **************** */
 const nvram_handle_t* get_nvram_handle() 
@@ -110,6 +108,7 @@ int nvram_unset(const char *name)
 
 nvram_tuple_t * nvram_getall()
 {
+	char *ret = NULL;
 	if(NULL == nvram_h) {
 		nvram_h = _nvram_open_rdonly();
 		if(NULL == nvram_h) {
@@ -210,7 +209,7 @@ int nvram_import(char *filename)
 	char buf[NVRAM_TMP_LEN];
 	char old_str[32], new_str[32];
 	int old, new = 0;
-//	int i;
+	int i;
 
 	struct nvram_tuple *v;
 	struct nvram_fw_tuple *w;
@@ -263,7 +262,7 @@ int nvram_import(char *filename)
 	/* Very likely we cannot find the matched version since our firmware might
 	 * be older than the config file. */
 	old = 0x0FFFFFFF;
-
+/*
 	for (w = &nvram_fw_table[0]; w->fw_str ; w++) {
 		if (!strcmp(w->fw_str, old_str)) {
 			old = w->fw_version;
@@ -277,7 +276,7 @@ int nvram_import(char *filename)
 		printf("log file format error: newer version configuration format\n");
 		return 1;
 	}
-
+*/
 	while (fgets(buf, sizeof(buf), fp)) {
 		if ((p = strchr(buf, '=')) == NULL)
 			continue;
@@ -332,15 +331,3 @@ int nvram_downgrade(char *target)
 	return change;
 }
 
-int nvram_dump(void)
-{
-	int ret = -1;
-	nvram_tuple_t * t = nvram_getall();
-	while (NULL != t ){
-		ret = 0;	
-		printf("nvram set \"%s=%s\"\n", t->name, t->value);
-		t = t->next;
-	}
-	return ret;
-}
-
diff --git a/nvram_rule.c b/nvram_rule.c
index 067785a..4b99f72 100644
--- a/nvram_rule.c
+++ b/nvram_rule.c
@@ -2,7 +2,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
-#include "nvram.h"
 #include "nvram_rule.h"
 
 char *mask[] = {
@@ -17,41 +16,41 @@ char *mask[] = {
 };
 
 
-int show_enable_value(char *val, char *buf, int bsize)
+int show_enable_value(char *type, char *val, char *buf, int bsize)
 {
     if (!val) {
-        return NVRAM_NO_ATTRIBUTE;
+        return EZPLIB_NO_ATTRIBUTE;
     }
 
     if (snprintf(buf, bsize, "%s", 
                 !strcmp(val, "1") ? "enabled" : "disabled") >= bsize) {
-        return NVRAM_VAL_TRUNC;
+        return EZPLIB_VAL_TRUNC;
     }
 
     return strlen(buf);
 }
 
-int show_value(char *val, char *buf, int bsize)
+int show_value(char *type, char *val, char *buf, int bsize)
 {
     if (!val) {
-        return NVRAM_NO_ATTRIBUTE;
+        return EZPLIB_NO_ATTRIBUTE;
     }
 
     if (snprintf(buf, bsize, "%s", val) >= bsize) {
-        return NVRAM_VAL_TRUNC;
+        return EZPLIB_VAL_TRUNC;
     }
     return strlen(buf);
 }
 
 char *iftype[] = { "wan", "lan", NULL };
 
-int show_if_value(char *val, char *buf, int bsize)
+int show_if_value(char *type, char *val, char *buf, int bsize)
 {
     char *ptr;
     int i, len, idx;
 
     if (!val) {
-        return NVRAM_NO_ATTRIBUTE;
+        return EZPLIB_NO_ATTRIBUTE;
     }
 
     for (i = 0; iftype[i]; i++) {
@@ -63,50 +62,50 @@ int show_if_value(char *val, char *buf, int bsize)
 
     if (!iftype[i]) {
         if (snprintf(buf, bsize, "%s", val) >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     } else {
         ptr = val + len;
         /* 1-based index for GUI display. */
         idx = atoi(ptr) + 1;    
         if (snprintf(buf, bsize, "%s%d", iftype[i], idx) >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     }
 
     return strlen(buf);
 }
 
-int show_proto_value(char *val, char *buf, int bsize)
+int show_proto_value(char *type, char *val, char *buf, int bsize)
 {
     if (!val) {
-        return NVRAM_NO_ATTRIBUTE;
+        return EZPLIB_NO_ATTRIBUTE;
     }
 
     if (!strcmp(val, "both")) {
         if (snprintf(buf, bsize, "UDP/TCP") >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     } else if (!strcmp(val, "tcp")) {
         if (snprintf(buf, bsize, "TCP") >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     } else if (!strcmp(val, "udp")) {
         if (snprintf(buf, bsize, "UDP") >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     } else {
         if (snprintf(buf, bsize, "%s", val) >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     }
     return strlen(buf);
 }
 
-int show_mask_value(char *val, char *buf, int bsize)
+int show_mask_value(char *type, char *val, char *buf, int bsize)
 {
     if (!val) {
-        return NVRAM_NO_ATTRIBUTE;
+        return EZPLIB_NO_ATTRIBUTE;
     }
 
     int idx = atoi(val);
@@ -114,11 +113,11 @@ int show_mask_value(char *val, char *buf, int bsize)
     if (24 <= idx && idx <= 32) {
         /* 24-based. */
         if (snprintf(buf, bsize, "%s", mask[idx - 24]) >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     } else {
         if (snprintf(buf, bsize, "") >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
     }
 
@@ -1950,16 +1949,16 @@ int sep_string(char *word, const char *delim, char **idx_arr, int max_tok)
  * indicates an error.
  * NOTE: If the return value is larger than or equal to bsize, it means the 
  * rule is truncated.
- *
- * \param[in] rule_set: pointer to the specific rule name. Eg., fr_rule
+ * \param[in] rule_set: a point to the specific rule name. Eg., fr_rule
  * \param[in] nth: to specify the nth rule in the rule set.
  * \param[out] buf: a pointer to a buffer for copying the parsed data.
  * \param[in] bsize: to specify the size of the imported area.
  */
-int nvram_get_rule(const char *rule_set, int nth, 
+int ezplib_get_rule(char *rule_set, int nth, 
 	char *buf, int bsize)
 {
-    char tmp[NVRAM_BUF_LEN];
+    char tmp[EZPLIB_BUF_LEN];
+    char *next;
     char *wordlist;
     char *str, *ptr;
     int ret;
@@ -1967,35 +1966,35 @@ int nvram_get_rule(const char *rule_set, int nth,
     assert(strlen(RULE_SEP) == 1);
 
     if (!buf) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
     /* Clean up the buffer that carries the retrieved value. */
     memset(buf, '\0', bsize);
 
     if (!rule_set || !*rule_set) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
     wordlist = nvram_get(rule_set);
     if (!wordlist) {
-        return NVRAM_NO_RULE_SET;
+        return EZPLIB_NO_RULE_SET;
     }
 
     if (!*wordlist) {
-        return NVRAM_NO_RULE;
+        return EZPLIB_NO_RULE;
     }
 
-    ret = snprintf(tmp, NVRAM_BUF_LEN, "%s", wordlist);
-    if (ret >= NVRAM_BUF_LEN) {
-        return NVRAM_VAL_TRUNC;
+    ret = snprintf(tmp, EZPLIB_BUF_LEN, "%s", wordlist);
+    if (ret >= EZPLIB_BUF_LEN) {
+        return EZPLIB_VAL_TRUNC;
     }
 
     str = tmp;
     while (str) {
         ptr = strsep(&str, RULE_SEP);
         if (!ptr) {
-            return NVRAM_NO_RULE;
+            return EZPLIB_NO_RULE;
         }
 
         if (nth != 0) {
@@ -2004,13 +2003,13 @@ int nvram_get_rule(const char *rule_set, int nth,
         }
         ret = snprintf(buf, bsize, ptr);
         if (ret >= bsize) {
-            return NVRAM_VAL_TRUNC;
+            return EZPLIB_VAL_TRUNC;
         }
         return ret;
     }
 
     if (nth >= 0) {
-        return NVRAM_NO_RULE;
+        return EZPLIB_NO_RULE;
     }
     return 0;
 }
@@ -2031,19 +2030,19 @@ int nvram_get_rule(const char *rule_set, int nth,
  * \param[out] buf: a pointer to a buffer for copying the parsed data.
  * \param[in] bsize: to specify the size of the imported area.
  */
-int nvram_get_subrule(const char *rule_set, int nth, 
+int ezplib_get_subrule(char *rule_set, int nth, 
 	int start, int end, char *buf, int bsize)
 {
     char *ptr_array[MAX_ATTR_NUM];
-    char word[NVRAM_BUF_LEN];
+    char word[EZPLIB_BUF_LEN];
     int ret, i, j, len;
 
     if (!rule_set || !*rule_set || !buf) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
     if (start > end) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
     /**
@@ -2052,7 +2051,7 @@ int nvram_get_subrule(const char *rule_set, int nth,
      */
     memset(buf, '\0', bsize);
 
-    ret = nvram_get_rule(rule_set, nth, word, NVRAM_BUF_LEN);
+    ret = ezplib_get_rule(rule_set, nth, word, EZPLIB_BUF_LEN);
     if (ret < 0) {
         return ret;
     }
@@ -2088,16 +2087,16 @@ int nvram_get_subrule(const char *rule_set, int nth,
  * \param[out] buf: a pointer to a buffer for copying the parsed data.
  * \param[in] bsize: to specify the size of the imported area.
  */
-int nvram_get_attr_val(const char *rule_set, int nth, 
-		const char *type, char *buf, int bsize, int use)
+int ezplib_get_attr_val(char *rule_set, int nth, 
+		char *type, char *buf, int bsize, int use)
 {
     char *ptr_array[MAX_ATTR_NUM];
-    char word[NVRAM_BUF_LEN];
+    char word[EZPLIB_BUF_LEN];
     int ret, i;
 
 
     if (!rule_set || !*rule_set || !type || !*type || !buf) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
     /**
@@ -2106,7 +2105,7 @@ int nvram_get_attr_val(const char *rule_set, int nth,
      */
     memset(buf, '\0', bsize);
 
-    ret = nvram_get_rule(rule_set, nth, word, NVRAM_BUF_LEN);
+    ret = ezplib_get_rule(rule_set, nth, word, EZPLIB_BUF_LEN);
     if (ret < 0) {
         return ret;
     }
@@ -2122,42 +2121,50 @@ int nvram_get_attr_val(const char *rule_set, int nth,
         attr = rules[i].attr;
         for (j = 0; attr[j].name && ptr_array[j]; j++) {
             if (strcmp(attr[j].name, type) == 0) {
-                if (use == NVRAM_USE_CLI && attr[j].func_orig) {
+                if (use == EZPLIB_USE_CLI && attr[j].func_orig) {
                     /* Don't wrap. Just get the value stored in nvram. */
-                    return attr[j].func_orig( ptr_array[j], 
+                    return attr[j].func_orig(type, ptr_array[j], 
                                              buf, bsize);
-                } else if (use == NVRAM_USE_WEB && attr[j].func_wrap) {
+                } else if (use == EZPLIB_USE_WEB && attr[j].func_wrap) {
                     /* Wrap the value from nvram. Eg., the attribute
                      * <enable> is 1 will be wrapped to 'checked'.
                      */
-                    return attr[j].func_wrap( ptr_array[j], buf, 
+                    return attr[j].func_wrap(type, ptr_array[j], buf, 
                                              bsize);
                 }
             }
         }
     }
 
-    return NVRAM_NO_ATTRIBUTE;
+    return EZPLIB_NO_ATTRIBUTE;
 }
 
-int nvram_op_rule(const char *rule_set, enum opcode op, int nth, char *new_rule)
+enum opcode {
+    ADD_RULE = 0,
+    DELETE_RULE = 1,
+    REPLACE_RULE = 2
+};
+
+int ezplib_op_rule(char *rule_set, enum opcode op, int nth, char *new_rule)
 {
-    char buf[NVRAM_BUF_LEN];
-    char word[NVRAM_BUF_LEN];
+    char buf[EZPLIB_BUF_LEN];
+    char word[EZPLIB_BUF_LEN];
+    char *wordlist;
     char *ptr;
     int len, ret, i, rule_num;
     char *rule_sep = RULE_SEP;
 
     /* Get the number of rules in the rule set. */
-    rule_num = nvram_get_rule_num(rule_set);
+    rule_num = ezplib_get_rule_num(rule_set);
     if (rule_num < 0) {
-        return NVRAM_NO_RULE_SET;
+        return EZPLIB_NO_RULE_SET;
     }
     
-    len = NVRAM_BUF_LEN;
+    len = EZPLIB_BUF_LEN;
     ptr = buf;
     for (i = 0; i < rule_num; i++) {
-        ret = nvram_get_rule(rule_set, i, word, NVRAM_BUF_LEN);
+        char *rule;
+        ret = ezplib_get_rule(rule_set, i, word, EZPLIB_BUF_LEN);
         if (ret < 0) {
             return ret;
         }
@@ -2165,14 +2172,14 @@ int nvram_op_rule(const char *rule_set, enum opcode op, int nth, char *new_rule)
         if (i != nth) {
             ret = snprintf(ptr, len, "%s%s", word, RULE_SEP);
             if (ret >= len) {
-                return NVRAM_VAL_TRUNC;
+                return EZPLIB_VAL_TRUNC;
             }
         } else {
             switch (op) {
                 case ADD_RULE:
                     ret = snprintf(ptr, len, "%s%s", new_rule, RULE_SEP);
                     if (ret >= len) {
-                        return NVRAM_VAL_TRUNC;
+                        return EZPLIB_VAL_TRUNC;
                     }
 
                     /**
@@ -2191,11 +2198,11 @@ int nvram_op_rule(const char *rule_set, enum opcode op, int nth, char *new_rule)
                 case REPLACE_RULE:
                     ret = snprintf(ptr, len, "%s%s", new_rule, RULE_SEP);
                     if (ret >= len) {
-                        return NVRAM_VAL_TRUNC;
+                        return EZPLIB_VAL_TRUNC;
                     }
                     break;
                 default:
-                    return NVRAM_INVALID;
+                    return EZPLIB_INVALID;
                     break;
             }
         }
@@ -2205,7 +2212,7 @@ int nvram_op_rule(const char *rule_set, enum opcode op, int nth, char *new_rule)
     }
 
     /* Calculate the length of the rule set. */
-    len = NVRAM_BUF_LEN - len;
+    len = EZPLIB_BUF_LEN - len;
 
     /* Remove the last whitespace. */
     assert(strlen(RULE_SEP) == 1);
@@ -2225,24 +2232,24 @@ int nvram_op_rule(const char *rule_set, enum opcode op, int nth, char *new_rule)
  * \param[in] nth: to specify the nth rule in the rule set.
  * \param[in] new_rule: the replacing rule.
  */
-int nvram_replace_rule(const char *rule_set, int nth, char *new_rule)
+int ezplib_replace_rule(char *rule_set, int nth, char *new_rule)
 {
     int rule_num;
 
     if (!rule_set || !*rule_set || !new_rule) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
-    rule_num = nvram_get_rule_num(rule_set);
+    rule_num = ezplib_get_rule_num(rule_set);
     if (rule_num < 0) {
-        return NVRAM_NO_RULE_SET;
+        return EZPLIB_NO_RULE_SET;
     }
 
     if (nth > rule_num || nth < 0) {
-        return NVRAM_IDX_OUT_RANGE;
+        return EZPLIB_IDX_OUT_RANGE;
     }
 
-    nvram_op_rule(rule_set, REPLACE_RULE, nth, new_rule);
+    ezplib_op_rule(rule_set, REPLACE_RULE, nth, new_rule);
     return 0;
 }
 
@@ -2254,20 +2261,20 @@ int nvram_replace_rule(const char *rule_set, int nth, char *new_rule)
  * \param[in] nth: to specify the nth rule in the rule set.
  * \param[in] new_rule: the replacing rule.
  */
-int nvram_replace_attr(const char *rule_set, int nth, 
+int ezplib_replace_attr(char *rule_set, int nth, 
 	char *attr_name, char *new_attr)
 {
     char *ptr_array[MAX_ATTR_NUM];
-    char word[NVRAM_BUF_LEN];
-    char tmp[NVRAM_BUF_LEN];
+    char word[EZPLIB_BUF_LEN];
+    char tmp[EZPLIB_BUF_LEN];
     int ret, i, bytes, attr_len;
     char *val, *str, *sep = ATTR_SEP;
 
     if (!rule_set || !*rule_set || !attr_name || !*attr_name || !new_attr) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
-    ret = nvram_get_rule(rule_set, nth, word, NVRAM_BUF_LEN);
+    ret = ezplib_get_rule(rule_set, nth, word, EZPLIB_BUF_LEN);
     if (ret < 0) {
         return ret;
     }
@@ -2281,7 +2288,7 @@ int nvram_replace_attr(const char *rule_set, int nth,
         }
     
         attr = rules[i].attr;
-        bytes = NVRAM_BUF_LEN;
+        bytes = EZPLIB_BUF_LEN;
         str = tmp;
         for (j = 0; attr[j].name && ptr_array[j]; j++) {
             if (strcmp(attr[j].name, attr_name) == 0) {
@@ -2294,7 +2301,7 @@ int nvram_replace_attr(const char *rule_set, int nth,
             attr_len = strlen(val) + 1;
             ret = snprintf(str, bytes, "%s%s", val, sep);
             if (ret >= bytes) {
-                return NVRAM_VAL_TRUNC;
+                return EZPLIB_VAL_TRUNC;
             }
 
             assert(ret == attr_len);
@@ -2308,10 +2315,10 @@ int nvram_replace_attr(const char *rule_set, int nth,
             *str = '\0';
         }
 
-        return nvram_replace_rule(rule_set, nth, tmp);
+        return ezplib_replace_rule(rule_set, nth, tmp);
     }
 
-    return NVRAM_NO_ATTRIBUTE;
+    return EZPLIB_NO_ATTRIBUTE;
 }
 
 /**
@@ -2321,13 +2328,13 @@ int nvram_replace_attr(const char *rule_set, int nth,
  * \param[in] rule_set: to specify the rule_set.
  * \param[in] nth: to specify the nth rule in the rule set.
  */
-int nvram_delete_rule(const char *rule_set, int nth)
+int ezplib_delete_rule(char *rule_set, int nth)
 {
     if (!rule_set || !*rule_set) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
-    nvram_op_rule(rule_set, DELETE_RULE, nth, NULL);
+    ezplib_op_rule(rule_set, DELETE_RULE, nth, NULL);
     return 0;
 }
 
@@ -2339,27 +2346,27 @@ int nvram_delete_rule(const char *rule_set, int nth)
  * \param[in] nth: to specify the nth rule in the rule set.
  * \param[in] new_rule: the replacing rule.
  */
-int nvram_add_rule(const char *rule_set, int nth, char *new_rule)
+int ezplib_add_rule(char *rule_set, int nth, char *new_rule)
 {
     int rule_num;
 
     if (!rule_set || !*rule_set || !new_rule) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
-    rule_num = nvram_get_rule_num(rule_set);
+    rule_num = ezplib_get_rule_num(rule_set);
     if (rule_num < 0) {
-        return NVRAM_NO_RULE_SET;
+        return EZPLIB_NO_RULE_SET;
     }
 
     if (nth > rule_num || nth < 0) {
-        return NVRAM_IDX_OUT_RANGE;
+        return EZPLIB_IDX_OUT_RANGE;
     }
 
     if (nth == rule_num) {
-        nvram_append_rule(rule_set, new_rule);
+        ezplib_append_rule(rule_set, new_rule);
     } else {
-        nvram_op_rule(rule_set, ADD_RULE, nth, new_rule);
+        ezplib_op_rule(rule_set, ADD_RULE, nth, new_rule);
     }
     return 0;
 }
@@ -2372,13 +2379,13 @@ int nvram_add_rule(const char *rule_set, int nth, char *new_rule)
  * \param[in] nth: to specify the nth rule in the rule set.
  * \param[in] new_rule: the replacing rule.
  */
-int nvram_prepend_rule(const char *rule_set, char *new_rule)
+int ezplib_prepend_rule(char *rule_set, char *new_rule)
 {
     if (!rule_set || !*rule_set || !new_rule) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
-    return nvram_op_rule(rule_set, ADD_RULE, 0, new_rule);
+    return ezplib_op_rule(rule_set, ADD_RULE, 0, new_rule);
 }
 
 /**
@@ -2389,32 +2396,32 @@ int nvram_prepend_rule(const char *rule_set, char *new_rule)
  * \param[in] nth: to specify the nth rule in the rule set.
  * \param[in] new_rule: the replacing rule.
  */
-int nvram_append_rule(const char *rule_set, char *new_rule)
+int ezplib_append_rule(char *rule_set, char *new_rule)
 {
-    char buf[NVRAM_BUF_LEN];
+    char buf[EZPLIB_BUF_LEN];
     int len;
     char *old_rules;
 
     if (!rule_set || !*rule_set || !new_rule) {
-        return NVRAM_INVALID;
+        return EZPLIB_INVALID;
     }
 
     old_rules = nvram_get(rule_set);
     if (!old_rules) {
-        return NVRAM_NO_RULE_SET;
+        return EZPLIB_NO_RULE_SET;
     }
 
     if (!*old_rules) {
         /* Empty rule set. */
-        len = snprintf(buf, NVRAM_BUF_LEN, "%s", new_rule);
+        len = snprintf(buf, EZPLIB_BUF_LEN, "%s", new_rule);
     } else {
         /* Existing rule(s). */
-        len = snprintf(buf, NVRAM_BUF_LEN, "%s%s%s", old_rules, 
+        len = snprintf(buf, EZPLIB_BUF_LEN, "%s%s%s", old_rules, 
                        RULE_SEP, new_rule);
     }
 
-    if (len >= NVRAM_BUF_LEN) {
-        return NVRAM_VAL_TRUNC;
+    if (len >= EZPLIB_BUF_LEN) {
+        return EZPLIB_VAL_TRUNC;
     }
     nvram_set(rule_set, buf);
 
@@ -2422,11 +2429,13 @@ int nvram_append_rule(const char *rule_set, char *new_rule)
 }
 
 /**
- * \return The number of subrule in the rule set.
+ * \brief 
+ * \return The number of rule in the rule set.
  * \param[in] rule_set: to specify the rule_set.
  */
-int nvram_get_rule_num(const char *rule_set)
+int ezplib_get_rule_num(char *rule_set)
 {
+    char *delim;
     char *sep = RULE_SEP;
     int i;
     int count;
@@ -2435,7 +2444,7 @@ int nvram_get_rule_num(const char *rule_set)
 
     rule_set = nvram_get(rule_set);
     if (!rule_set) {
-        return NVRAM_NO_RULE_SET;
+        return EZPLIB_NO_RULE_SET;
     }
 
     /* Empty */
diff --git a/nvram_rule.h b/nvram_rule.h
index a3856c1..264eaa3 100644
--- a/nvram_rule.h
+++ b/nvram_rule.h
@@ -1,39 +1,33 @@
 #ifndef __NVRAM_RULE_H_
 #define __NVRAM_RULE_H_
 
-#define NVRAM_BUF_LEN          8192
+#define EZPLIB_BUF_LEN          8192
 
-#define NVRAM_USE_CLI          0
-#define NVRAM_USE_WEB          1
+#define EZPLIB_USE_CLI          0
+#define EZPLIB_USE_WEB          1
 
-#define NVRAM_INVALID          -1
-#define NVRAM_VAL_TRUNC        -2
-#define NVRAM_NO_RULE_SET      -3
-#define NVRAM_NO_RULE          -4
-#define NVRAM_NO_ATTRIBUTE     -5
-#define NVRAM_IDX_OUT_RANGE    -6
+#define EZPLIB_INVALID          -1
+#define EZPLIB_VAL_TRUNC        -2
+#define EZPLIB_NO_RULE_SET      -3
+#define EZPLIB_NO_RULE          -4
+#define EZPLIB_NO_ATTRIBUTE     -5
+#define EZPLIB_IDX_OUT_RANGE    -6
 
 #define RULE_SEP "|"
 #define ATTR_SEP "^"
 
 struct attr {
     char *name;
-    int (*func_orig)(char *, char *, int);
-    int (*func_wrap)(char *, char *, int);
-};
-
-enum opcode {
-    ADD_RULE = 0,
-    DELETE_RULE = 1,
-    REPLACE_RULE = 2
+    int (*func_orig)(char *, char *, char *, int);
+    int (*func_wrap)(char *, char *, char *, int);
 };
 
 /******************************************/
-int show_enable_value(char *val, char *buf, int bsize);
-int show_value(char *val, char *buf, int bsize);
-int show_if_value(char *val, char *buf, int bsize);
-int show_proto_value(char *val, char *buf, int bsize);
-int show_mask_value(char *val, char *buf, int bsize);
+int show_enable_value(char *type, char *val, char *buf, int bsize);
+int show_value(char *type, char *val, char *buf, int bsize);
+int show_if_value(char *type, char *val, char *buf, int bsize);
+int show_proto_value(char *type, char *val, char *buf, int bsize);
+int show_mask_value(char *type, char *val, char *buf, int bsize);
 
 int sep_string(char *word, const char *delim, char **idx_arr, int max_tok);
 
@@ -41,7 +35,7 @@ int sep_string(char *word, const char *delim, char **idx_arr, int max_tok);
  * \brief Get a specified rule set from nvram, parse it by the RULE_SEP 
  * character, and return the nth rule.
  */
-int nvram_get_rule(const char *rule_set, int nth, 
+int ezplib_get_rule(char *rule_set, int nth, 
 	char *buf, int bsize);
 
 /**
@@ -49,7 +43,7 @@ int nvram_get_rule(const char *rule_set, int nth,
  * RULE_SEP character, and return the subrule with the attribute position in
  * between start and end.
  */
-int nvram_get_subrule(const char *rule_set, int nth, 
+int ezplib_get_subrule(char *rule_set, int nth, 
 	int start, int end, char *buf, int bsize);
 
 /**
@@ -57,46 +51,45 @@ int nvram_get_subrule(const char *rule_set, int nth,
  * from nvram. The rules are separated by blank character and the attributes
  * in a rule are separated by '-' character.
  */
-int nvram_get_attr_val(const char *rule_set, int nth, 
-	const char *type, char *buf, int bsize, int use);
+int ezplib_get_attr_val(char *rule_set, int nth, 
+	char *type, char *buf, int bsize, int use);
 
-int nvram_op_rule(const char *rule_set, enum opcode op, 
-	int nth, char *new_rule);
+//int ezplib_op_rule(char *rule_set, enum opcode op, int nth, char *new_rule);
 
 /**
  * \brief Replace the nth rule in the given rule-name as the specific rule.
  */
-int nvram_replace_rule(const char *rule_set, int nth, char *new_rule);
+int ezplib_replace_rule(char *rule_set, int nth, char *new_rule);
 
 /**
  * \brief Replace the mth attribute of the nth rule in the given rule-name as 
  * the specific rule.
  */
-int nvram_replace_attr(const char *rule_set, int nth, 
+int ezplib_replace_attr(char *rule_set, int nth, 
 	char *attr, char *new_attr);
 
 /**
  * \brief Append a new rule into the given rule-name.
  */
-int nvram_append_rule(const char *rule_set, char *new_rule);
+int ezplib_append_rule(char *rule_set, char *new_rule);
 
 /**
  * \brief Prepend a new rule into the given rule-name.
  */
-int nvram_prepend_rule(const char *rule_set, char *new_rule);
+int ezplib_prepend_rule(char *rule_set, char *new_rule);
 
 /**
  * \brief Add a new rule in the given rule-name as the specific rule.
  */
-int nvram_add_rule(const char *rule_set, int nth, char *new_rule);
+int ezplib_add_rule(char *rule_set, int nth, char *new_rule);
 
 /**
  * \brief Delete nth rule in the given rule-name.
  */
-int nvram_delete_rule(const char *rule_set, int nth);
+int ezplib_delete_rule(char *rule_set, int nth);
 
 /**
  * \brief Get the number of rules in the given rule-name.
  */
-int nvram_get_rule_num(const char *rule_set);
+int ezplib_get_rule_num(char *rule_set);
 #endif
